<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux 安装 MySQL 和 Redis</title>
      <link href="/posts/3475225673/"/>
      <url>/posts/3475225673/</url>
      
        <content type="html"><![CDATA[<h3 id="Install-MySql"><a href="#Install-MySql" class="headerlink" title="Install MySql"></a>Install MySql</h3><ol><li><code>docker docker pull mysql:5.7</code> </li><li><code>docker run -d --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -v /data/mysql_data:/var/lib/mysql mysql:5.7</code></li><li><code>docker exec -it mysql bash</code></li><li><code>mysql -uroot -proot</code></li></ol><h3 id="Install-Redis"><a href="#Install-Redis" class="headerlink" title="Install Redis"></a>Install Redis</h3><ol><li><code>docker pull redis:5</code></li><li><code>docker run -p 6379:6379 --name redis -d redis:5 redis-server --appendonly yes</code></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA create class and method comment use template</title>
      <link href="/posts/1774144165/"/>
      <url>/posts/1774144165/</url>
      
        <content type="html"><![CDATA[<h3 id="Class-comment"><a href="#Class-comment" class="headerlink" title="Class comment"></a>Class comment</h3><p>IDEA - Settings - Editor - File and Code Templates - Class</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: $&#123;description&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: YOUR NAME or &#123;USER&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: $&#123;YEAR&#125;-$&#123;MONTH&#125;-$&#123;DAY&#125; $&#123;HOUR&#125;:$&#123;MINUTE&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@main/uPic/Screenshot%202023-12-09%20at%2014.09.482023%2012%2009%2014%2027%2034" alt="enter template"></p><hr><h3 id="Method-Comment"><a href="#Method-Comment" class="headerlink" title="Method Comment"></a>Method Comment</h3><p>IDEA - Settings - Editor - Live Templates - create a new Template Groups. I my case i create a Template Groups named “Method Comment”.</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@main/uPic/Screenshot%202023-12-09%20at%2014.14.592023%2012%2009%2014%2033%20192023%2012%2009%2014%2033%2029" alt="create a new tmplate groups"></p><p>Then select “Method Comment” add a new Live Template</p><p><strong>NOTICE: there is no / in first line</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line"> * <span class="meta">@Description</span>: $description$</span><br><span class="line"> * <span class="meta">@Param</span>: $params$</span><br><span class="line"> * <span class="meta">@return</span>: $returns$</span><br><span class="line"> * <span class="meta">@Author</span>: IamXGW</span><br><span class="line"> * <span class="meta">@Date</span>: $date$</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>Input Abbreviation, you will use this Abbreviation to create your method comment</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@main/uPic/Screenshot%202023-12-09%20at%2016.15.082023%2012%2009%2016%2016%2002" alt="enter template"></p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@main/uPic/Screenshot%202023-12-09%20at%2014.22.502023%2012%2009%2014%2033%2042" alt="sellet application in"></p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@main/uPic/Screenshot%202023-12-09%20at%2014.25.392023%2012%2009%2014%2033%2058" alt="edit variables"></p><hr><h3 id="USE"><a href="#USE" class="headerlink" title="USE"></a>USE</h3><h4 id="Class-Comment"><a href="#Class-Comment" class="headerlink" title="Class Comment"></a>Class Comment</h4><p>When you create a new Java class, class comment will auto create.</p><h4 id="Method-Comment-1"><a href="#Method-Comment-1" class="headerlink" title="Method Comment"></a>Method Comment</h4><ul><li>Create a new method</li><li>Input “/ + your abbreviation + Enter” at the new added method top, in my case, i will input “/ + mc + Enter”</li><li>Then, you will get a method comment</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在GitHub上部署Hexo网站</title>
      <link href="/posts/3487777106/"/>
      <url>/posts/3487777106/</url>
      
        <content type="html"><![CDATA[<p>换电脑好久了，个人网站一直拖着没有部署。今天决定要搞一下，发现很多步骤都忘记了，因此写篇帖子记录一下，方便以后查阅</p><ol><li><p>要在新 Mac 上安装 Hexo 首先需要有 <a href="https://brew.sh">Homebrew</a>。Homebrew 官网推荐的安装方式因为某些特殊原因，一直报错。尝试在 <code>/etc/hosts</code> 文件中配置 GitHub，但是没起作用。最终解决方法：<a href="https://blog.csdn.net/timtian008/article/details/108465820">使用国内镜像安装 Homebrew</a></p></li><li><p>装好 Homebrew 以后，可以去到 <a href="https://hexo.io">Hexo 官网</a>，按官网提示安装 Hexo</p><ol><li><code>npm install hexo-cli -g</code> 安装 hexo</li><li><code>cd blog</code> 进到本地自己的博客文件夹中</li><li><code>npm install</code></li></ol></li><li><p>将博客文件部署到 github.io 上</p><ol><li>去到博客根文件下修改 <code>_config.yml</code>，将 GitHub 的部署方式修改为 SSH 方式 <code>github: git@github.com:userName/userName.github.io.git</code></li><li>按照 <a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">Generating a new SSH key and adding it to the ssh-agent</a> 一步一步的设置 SSH</li><li>在博客根目录运行 <code>hexo deploy -g</code></li></ol></li><li><p>配置图片 CDN</p><pre><code> 1. 去到 [uPic 官网](https://blog.svend.cc/upic/en/)参考下载命令 2. 在 uPic 中进行如下设置</code></pre><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@main/uPic/Screenshot%202023-11-26%20at%2022.29.172023%2011%2026%2022%2035%2038" alt="Screenshot 2023-11-26 at 22.29.17"></p><p>其中，token 需要去到 GitHub - Setting - Developer Settings - Personal access tokens 获取。注意：该 token 只有在生成的时候显示一次，需要及时记录下来</p><ol><li>去到 Typora 中进行如下设置</li></ol><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@main/uPic/Screenshot%202023-11-26%20at%2022.32.332023%2011%2026%2022%2035%2025" alt="Screenshot 2023-11-26 at 22.32.33"></p><p>Image Uploader 选择 uPic，然后点击「test Uploader」显示 Succee 说明配置成功</p><ol><li>使用：当在 Typora 中插入一张图片后，右键该图片，选择「Upload Image」，此时该图片的地址会由本地的存储地址切换为 CDN 的地址</li></ol></li><li><p>Hexo 常用命令</p><ol><li><code>hexo new title</code> 创建新的文章，<code>title</code> 为文章标题</li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的2022年终总结</title>
      <link href="/posts/1037071310/"/>
      <url>/posts/1037071310/</url>
      
        <content type="html"><![CDATA[<p>今年的重心是秋招和毕业。</p><p>秋招 9 月份开始投递简历，主要投的互联网行业，现在是 0 offer，每天笑哈哈。</p><p>毕业主要是毕业要求和毕业论文，毕业要求已经达到了，论文也有了大体框架，剩下的就差写出来了。</p><p>今年来主要做了如下几件事：</p><ol><li>英语学习。听力，一直在坚持听英语播客「ESLPod」，听了 40 期了。阅读，读了一本「小王子」。写作和口语，无。6 级考了还没出成绩。每天也在坚持用英语。</li><li>准备秋招。做了 2 个简历上的项目，看了些八股文，读了周志明的 Java 虚拟机。刷题见下面第 3 条。去年定的目标是上岸大、中厂，还是大意了。</li><li>刷题。LeetCode 每日一题坚持了 7 个月了，周赛也打了几十场了，算法和数据结构的学习一直没断，每天都在进步，做题也渐入佳境。刷题是打算培养成个人爱好的。</li><li>读书。今年读了 32 本书，离去年的 50+ 目标有点差距。</li><li>健康。今年牙齿动了个小手术，4 颗智齿全部拔掉了，补了几颗蛀牙。其他方面没啥问题。对了，我已经阳过了，发烧最高到了 39.8 度，直逼 40 度，吃了三片对乙酰氨基酚。其他症状有浑身疼、咳嗽、嗓子疼、流鼻涕、味觉嗅觉衰退，感觉也还好。也给家里的老人做了些物资准备。</li><li>运动。天气暖和就坚持跑步，天气冷了就在室内做核心训练。感觉今年的运动量还可以，不过体重还是那样，不增不减。</li></ol><p>2022 年最大的遗憾就是秋招没拿 offer。</p><p>明年的计划。</p><ol><li>拿 offer</li><li>顺利毕业</li><li>读书 30+</li><li>英语不要停，要不准备考下雅思？</li><li>想去三星堆看看</li></ol>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各类DP问题</title>
      <link href="/posts/1025277118/"/>
      <url>/posts/1025277118/</url>
      
        <content type="html"><![CDATA[<h4 id="数位-DP"><a href="#数位-DP" class="headerlink" title="数位 DP"></a>数位 DP</h4><hr><h4 id="序列-DP"><a href="#序列-DP" class="headerlink" title="序列 DP"></a>序列 DP</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>KMP字符串匹配算法</title>
      <link href="/posts/2088575566/"/>
      <url>/posts/2088575566/</url>
      
        <content type="html"><![CDATA[<p>力扣题目：<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">Find the Index of the First Occurrence in a String</a></p><p>给定原串 <code>s</code> 长度为 <code>n</code>，模式串 <code>p</code> 长度为 <code>m</code>。</p><p>先给个暴力解法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length(), m = t.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt;= n - m; idx++) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = idx, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( ; j &lt; m; ++i, ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != t.charAt(j)) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，KMP（Knuth–Morris–Pratt algorithm）和暴力解法的不同之处是，当遇到不相同的字符时，暴力解法采取的措施是：原串指针回到本次开始位置的下一个位置，模式串指针回到第一个位置。而 KMP 采取的措施是：原串指针保持不动，模式串指针回到已匹配模式串的相同前缀的下一个位置。</p><ol><li>为什么当遇到原串和模式串不匹配时，需要回到<strong>已匹配</strong>的模式串的「相同前缀」的下一个位置？</li></ol><p>相同前缀指的是，如果一个字符串中包含相同的前缀和后缀，比如 <code>aabbaa</code> 包含相同的前缀和后缀，都为 <code>aa</code>，那么叫这个前缀为相同前缀（我自己起的名）。</p><p>如果已匹配模式串中存在相同前缀和后缀，并且后缀的最后一个字符和原串未匹配位置字符相同，这时只需要从相同前缀的下一个位置开始和原串不匹配字符处继续往下比较即可。如果模式串中不存在相同的前缀和后缀，那就只能从模式串的第一个字符开始，继续往下和原串进行比较。</p><p>举例子：原串 acbacc，模式串 acbacb，如果现在该比较的是第 6 个字符，发现不相同（c != b），此时应该检查模式串不匹配位置前一个字符是什么（模式串第 5 个字符是 c），发现和原串不匹配字符 c 相同，那么下一轮开始比较的位置应该是：原串第 6 个字符，模式串第 3 个字符。</p><p>如果我们事先不知道已匹配模式串中的相同的前、后缀的位置，那么每当遇到原串和模式串不匹配的时候，我们都要重新扫描一遍模式串的已匹配部分，看是否存在相同的前、后缀，并据此判断模式串下次匹配开始的位置，这个不断扫描查找相同前、后缀过程的时间复杂度是 <code>O(m^2)</code> 的，总体复杂度是 <code>O(n * m^2)</code>，这显然比暴力解法 <code>O(n * m)</code> 更慢。那怎么处理呢？</p><ol><li><code>next</code> 数组是干嘛用的？是怎么生成的？是怎么使用的？</li></ol><p>可以考虑用空间换时间，预先将模式串中每个位置如果不匹配，下次应该跳转的位置给记录下来，放到 <code>next</code> 数组中，那么在遇到不匹配的情况，就可以直接在 <code>next</code> 数组中很快的找出模式串下次匹配应该开始的位置。 那么 <code>next</code> 数组应该怎么生成呢？</p><p>生成 next 的具体步骤：</p><ul><li>初始化：<code>int[] next = new int[m]; int j = 0, i = 1;</code></li><li>如果匹配（p[j] == p[i]）：<code>next[i] = j + 1; ++i; ++j;</code></li><li>如果不匹配（p[j] ！= p[i]）：令 <code>j = next[j - 1]</code>，之后如果匹配，则返回上个步骤；如果不匹配，继续令 <code>j = next[j - 1]</code>，直到 <code>j == 0</code>，此时将 <code>next[i] = j</code>。虽然这里有使用 <code>while</code> 循环，但是时间复杂度应该并不是 <code>O(m)</code>的。</li></ul><p>下面是生成 <code>next</code> 数组的完整代码。其中代码的逻辑和上述步骤相同，但是将上述步骤进行了一些合并，具体请见代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; p[i] != p[j]) j = next[j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j]) ++j;</span><br><span class="line">    next[i] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有了 next 数组，可以方便的查找模式串中当前字符的下一个开始匹配位置了，那么该怎么使用呢？</p><p>在原串中使用指针 <code>i</code>，在模式串中使用指针 <code>j</code>。</p><ul><li>初始化：int i = 0, j = 0;</li><li>如果匹配（s[i] == p[j]）：<code>++i; ++j;</code> 如果 <code>j == m</code>，说明整个模式串匹配成功，直接返回 <code>i - m + 1</code>。</li><li>如果不匹配（s[i] != p[j]）：令 <code>j = next[j - 1]</code>，之后如果匹配，则返回上个步骤；如果不匹配，继续令 <code>j = next[j - 1]</code>，直到 <code>j == 0</code>，说明整个已经匹配过的模式串中不存在相同的前、后缀。</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != p[j]) j = next[j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j]) ++j;</span><br><span class="line">    <span class="keyword">if</span> (j == m) <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是整个 KMP 的完整代码：</p><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">不带哨兵版</button></li><li class="tab"><button type="button" data-href="#1-2">带哨兵版</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">KMP</span><span class="params">(String ss, String pp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] s = ss.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] p = pp.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> n = s.length, m = p.length;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; p[i] != p[j]) j = next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j]) ++j;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != p[j]) j = next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j]) ++j;</span><br><span class="line">        <span class="keyword">if</span> (j == m) <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">KMP</span><span class="params">(String ss, String pp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pp.isEmpty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = ss.length(), m = pp.length();</span><br><span class="line">    <span class="keyword">char</span>[] s = (<span class="string">&quot; &quot;</span> + ss).toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] p = (<span class="string">&quot; &quot;</span> + pp).toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) ++j;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) ++j;</span><br><span class="line">        <span class="keyword">if</span> (j == m) <span class="keyword">return</span> i - m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>希望该篇文章对你有帮助：）</p><p>参考文章：<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solution/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86/">【宫水三叶】简单题学 KMP 算法</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>差分数组</title>
      <link href="/posts/4105932540/"/>
      <url>/posts/4105932540/</url>
      
        <content type="html"><![CDATA[<h3 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h3><p>频繁的对区间进行修改操作，单点查询。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="初始化，以及跟新操作"><a href="#初始化，以及跟新操作" class="headerlink" title="初始化，以及跟新操作"></a>初始化，以及跟新操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] diff = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> l = 修改的左区间;</span><br><span class="line">    <span class="keyword">int</span> r = 修改的右区间 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> val = 对区间修改的值;</span><br><span class="line">    diff[l] += val;</span><br><span class="line">   <span class="keyword">if</span> (r + <span class="number">1</span> &lt; n) diff[r + <span class="number">1</span>] -= val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p><code>diff[L...]+3</code> 表示对 <code>diff[L...]</code>所有的元素都 <code>+3</code>。<code>diff[R+1...]-3</code> 表示对 <code>diff[R+1...]</code> 所有的元素都 <code>-3</code>。</p><p>那么，通过对 <code>diff[R+1...]</code> 所有的元素都 <code>-3</code>，就可以抵消 <code>diff[R+1...]</code> 多余的 <code>+3</code> 操作（该多余操作来自：<code>diff[L...]</code>所有的元素都 <code>+3</code>），从而得到只有 <code>diff[L...R]</code> 中所有的元素都 <code>+3</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计数排序</title>
      <link href="/posts/3412220679/"/>
      <url>/posts/3412220679/</url>
      
        <content type="html"><![CDATA[<p>计数排序（Counting sort）是一种稳定的线性时间排序算法。该算法于 1954 年由 Harold H. Seward 提出。计数排序使用一个额外的数组 C，其中第 i 个元素是待排序数组 A 中值等于 i 的元素的个数。然后根据数组 C 来将 A 中的元素排到正确的位置。维基百科：<a href="https://zh.wikipedia.org/wiki/计数排序">计数排序</a>。</p><p>计数排序要求待排序数组必须是整数，而且值域必须明确。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取最大、最小值</span></span><br><span class="line">    <span class="keyword">int</span> max = Arrays.stream(nums).max().getAsInt();</span><br><span class="line">    <span class="keyword">int</span> min = Arrays.stream(nums).min().getAsInt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为额外数组 count 开空间</span></span><br><span class="line">    <span class="keyword">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[range];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计元素出现次数（需要计算偏移量）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) count[num - min]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求计数和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; range; ++i) count[i] += count[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反向填充数组，</span></span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] output = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        output[count[nums[i] - min] - <span class="number">1</span>] = nums[i];</span><br><span class="line">        count[nums[i] - min]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写回</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) nums[i] = output[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AStar算法</title>
      <link href="/posts/3803732996/"/>
      <url>/posts/3803732996/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/posts/2291390787/"/>
      <url>/posts/2291390787/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树状数组</title>
      <link href="/posts/1503714904/"/>
      <url>/posts/1503714904/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>拓扑排序</title>
      <link href="/posts/4215336901/"/>
      <url>/posts/4215336901/</url>
      
        <content type="html"><![CDATA[<p>相关题目：<a href="https://leetcode.cn/problems/Jf1JuT/">剑指 Offer II 114. 外星文字典</a>、<a href="https://leetcode.cn/problems/find-eventual-safe-states/">802. 找到最终的安全状态</a>。</p><p>拓扑排序只能在<strong>有向无环图（DAG, Directed Acyclic Graph）</strong>中得到正确的结果（在有环图中可以运行拓扑排序，不会报 BUG，但是结果不正确：完成排序的节点个数和总的结点个数不相等），所以，拓扑排序也可以用来检测一个有向图是不是带环。</p><p>拓扑排序的结果不是唯一的。这取决于将入度为 0 的节点插入队列的顺序。队列出队顺序为拓扑排序顺序。</p><p>与拓扑排序相关的两个概念：</p><ul><li><p>入度（indegree）：有多少条边直接指向该节点；</p></li><li><p>出度（outdegree）：由该节点指出的边有多少条。</p></li></ul><p>拓扑排序的基本过程：</p><ol><li>起始时，将所有入度为 <code>0</code> 的结点入队。</li><li>对队列进行出队操作，出队顺序就是拓扑排序的顺序。对于当前出队元素 <code>v</code>，遍历图中所有和其直接相连接的结点 <code>w</code>，并将 <code>w</code> 的入度减 <code>1</code>。</li><li>如果对 <code>w</code> 的入度减 <code>1</code> 后，<code>w</code> 的入度为 <code>0</code>，则将 <code>w</code> 入队。</li><li>重复执行步骤 <code>2、3</code>，直至队列为空。</li></ol><p>拓扑排序思想很好理解，代码也不难。在我看来难点在于，能够识别出一个问题可以用图建模，并正确的进行建模。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] grap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] indegress;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Character&gt; exits;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">alienOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        grap = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>][<span class="number">26</span>];</span><br><span class="line">        indegress = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        exits = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = words.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : words[i].toCharArray()) exits.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">char</span>[] w1 = words[i].toCharArray();</span><br><span class="line">            <span class="keyword">char</span>[] w2 = words[j].toCharArray();</span><br><span class="line">            <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (idx &lt; w1.length &amp;&amp; idx &lt; w2.length &amp;&amp; w1[idx] == w2[idx]) idx++;</span><br><span class="line">            <span class="keyword">if</span> (idx &lt; w1.length &amp;&amp; idx == w2.length) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (idx &lt; w1.length &amp;&amp; idx &lt; w2.length) &#123;</span><br><span class="line">                <span class="keyword">char</span> from = w1[idx], to = w2[idx];</span><br><span class="line">                </span><br><span class="line">                indegress[to - <span class="string">&#x27;a&#x27;</span>] += grap[from - <span class="string">&#x27;a&#x27;</span>][to - <span class="string">&#x27;a&#x27;</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">                grap[from - <span class="string">&#x27;a&#x27;</span>][to - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> topoSort();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">topoSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> cnt = exits.size();</span><br><span class="line">        StringBuilder ret = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exits.contains((<span class="keyword">char</span>)(i + <span class="string">&#x27;a&#x27;</span>)) &amp;&amp; indegress[i] == <span class="number">0</span>)</span><br><span class="line">                queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">            </span><br><span class="line">            ret.append((<span class="keyword">char</span>)(cur + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grap[cur][j]) &#123;</span><br><span class="line">                    grap[cur][j] = <span class="keyword">false</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (--indegress[j] == <span class="number">0</span>) queue.offer(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt == ret.length() ? ret.toString() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记第一次参加力扣周赛</title>
      <link href="/posts/4019694787/"/>
      <url>/posts/4019694787/</url>
      
        <content type="html"><![CDATA[<p>写这篇文章的时候已经是第二次参加力扣周赛了。</p><p>上周是我第一次参加<a href="https://leetcode-cn.com/contest/">力扣周赛</a>，总的来说感觉还行，解对了两题，拿了 7 分（总共 4 题，满分 18 分）。但是这周的周赛只答对了 easy 的题目，第一道 medium 的题目思路是有，但是在细枝末节总是出 BUG，直接搞崩了心态。后面的两题都没来得及看。</p><p>我仅有的竞赛经验，就是在专科的时候参加过一个蓝桥杯，还是参加的 C 组。那时候学校里也没有竞赛兴趣小组，我对数据结构的了解也只停留在链表、堆栈、数组、二叉树这种最基本的，还是在选修课上学的。排序算法也只学过选择和冒泡，至于二分、DP 这种算法更是听都没听过。</p><p>那时候是先去参加省赛，通过省赛选拔再去参加国赛。省赛我都不知道怎么晋级国赛的，我的解题方法只有 for，一层不行就再来一层。但是就凭借这个 for 循环，在国赛的时候拿了个二等奖。后来就没碰过算法竞赛了。</p><p>现在为了找工作开始刷力扣，慢慢学到了各种数据结构、以及各种常用算法（这里强烈推荐一下 <a href="https://www.imooc.com/t/108955">bobo 老师的课程</a>，非常的棒，bobo 老师人也非常的棒，强烈推荐）。每天都在力扣做题，到今天已经坚持了五个月了，总共解决了 231 道题。有时候一道 hard 的题目都可以自己解出来，那成就感满满的。对于大部分的 medium 的题目，如果时间长一点，基本上也可以解得出来。</p><p>参加竞赛的这一个半小时，我都感觉过得很快，很专注，这种感觉很好。现在有点慢慢的喜欢上解题了，不再只是为了工作而刷题，而是为了兴趣而解题。昨晚做梦还梦到了周赛的一道题，不过没考。下一步周赛的目标是稳定前两题，加快解题速度，冲第三题。</p><p>通过周赛我还了解了一位大佬 <a href="https://leetcode-cn.com/u/cuiaoxiang/">Aoxiang Cui</a>，大佬在 YouTube 开了一个频道，参加周赛的视频都会上传。这让我了解到很多东西：1). 原来大佬解题都不需要草稿纸，真的是直接在脑子里跑代码；2). 写代码的时候鼠标也很少用，基本用的是键盘快捷键，光标上蹿下跳、复制粘贴都非常溜；3). 写代码的风格也学到了一些，还了解到大佬一道题从读题、敲代码到最终的 AC 过程是怎样的。非常感谢。</p><p>大佬们都有很多年的竞赛经验，甚至是十多年都很常见。Aoxiang Cui 就是一位有十多年竞赛经验的大佬。还有上面提到的 bobo 老师，今天找到 bobo 老师的力扣账号，一看，过去一年有 1591 次提交，当场跪了。大佬们都这么用功，我这普通小菜鸡还有什么理由松懈呢？</p><p>王老师说，普通人就要脚踏实地，一步一个脚印的往前走。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用「前缀和」解决力扣 560 号问题：和为 K 的子数组</title>
      <link href="/posts/3420367927/"/>
      <url>/posts/3420367927/</url>
      
        <content type="html"><![CDATA[<p>前缀和，是指一个数组的某下标 <code>i</code> 之前的所有数组元素的和（包不包括 i 都可）。比如，现有数组：[1, 2, 3, 4, 5]，那么对应的前缀和数组就是 [0, 1, 3, 6, 10, 15]。使用前缀和可以通过预处理数组来降低每次求和的复杂度。</p><p>如果没有前缀和数组，我们想计算数组位置 [1, 3] 的和，是不是需要写一个 <code>for(int i = 1; i &lt;= 3; i++) sum += nums[i];</code> 循环。计算一次还好，如果是需要计算上千上万次呢？如果数组非常大呢？这样简单的用 for 循环是不是很费时间？</p><p>我们通过预处理计算出前缀和数组，就能很容易的在 <code>O(1)</code> 的时间复杂度内求得任意数组位置的和。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] prefixSum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">prefixSum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    prefixSum[i + <span class="number">1</span>] = nums[i] + prefixSum[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们计算任意数组位置 [l, r] 的和：<code>prefixSum[r + 1] - prefixSum[l]</code>。假如计算  [1, 3] 的和就是：<code>prefixSum[3 + 1] - prefixSum[1]</code>。</p><p>现在看一下 <a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">力扣 560 号问题：和为 K 的子数组</a>。题目让你计算和为 k 的连续子数组的和。</p><p>很容易想到使用前缀和的暴力解法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = nums.length;</span><br><span class="line"><span class="keyword">int</span>[] prefixSum = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">prefixSum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    prefixSum[i + <span class="number">1</span>] = nums[i] + prefixSum[i];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prefixSum[i] - prefixSum[j] == k) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure><p>接下来该怎么优化呢？</p><p>从内层循环下手。先来看下内层循环的作用：循环 <code>i</code> 次，找出符合 <code>if</code> 条件的组合一共有多少个。显然对于 <code>if</code> 条件，只有 j 是一直在变的，所以换句话说就是：找出符合 <code>if</code> 条件的 j 一共有多少个。</p><p>将 <code>if</code> 条件移项得：<code>if (prefixSum[j] == prefixSum[i] - k)</code>。那么现在只要知道有几个 <code>prefixSum[j]</code> 和 <code>prefixSum[i] - k</code> 相等，就可以避免内层 <code>for</code> 循环。我们还可以使用一个 <code>HashMap</code> 来记录和 <code>prefixSum[i] - k</code> 相等的 <code>prefixSum[j]</code> 有几个，这样内存循环就可以直接省掉了。</p><p>另外，<code>prefixSum[i]</code> 是不是就是 <code>nums[0...i]</code>的和？因此可以使用一个变量 <code>sum0_i</code> 来承接。这样连前缀和数组也省掉了，就只剩前缀和思想在这了。</p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">HashMap&lt;Integer, Integer&gt; sumMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> sum0_i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">sumMap.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    sum0_i += nums[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (sumMap.containsKey(sum0_i - k)) &#123;</span><br><span class="line">        ans += sumMap.get(sum0_i - k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sumMap.put(sum0_i, sumMap.getOrDefault(sum0_i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure><p>总结：使用前缀和的关键点就是：<code>suml_r = prefixSum[r] - prefixSum[l]</code>。我们可以 <code>O(1)</code> 复杂度求得任一区间的和。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网ACM编程模式Java模版</title>
      <link href="/posts/1909648611/"/>
      <url>/posts/1909648611/</url>
      
        <content type="html"><![CDATA[<h3 id="数组输入"><a href="#数组输入" class="headerlink" title="数组输入"></a>数组输入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    对于每一组测试数据，第一行输入两个整数 n，k 代表这个序列的长度和要判断的元素</span></span><br><span class="line"><span class="comment">    接下来输入 n 个整数，a[i] 表示序列中第 i 个元素</span></span><br><span class="line"><span class="comment">    举例：</span></span><br><span class="line"><span class="comment">    5 8</span></span><br><span class="line"><span class="comment">    1 2 3 4 5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">            <span class="keyword">int</span> k = sc.nextInt();</span><br><span class="line">            <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                nums[i] = sc.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// write code here ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一个 n * m 的图</span></span><br><span class="line"><span class="comment"> * 举例：</span></span><br><span class="line"><span class="comment"> * 4 4</span></span><br><span class="line"><span class="comment"> * 1122</span></span><br><span class="line"><span class="comment"> * 1222</span></span><br><span class="line"><span class="comment"> * 3111</span></span><br><span class="line"><span class="comment"> * 3333</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记得抛异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String[] params = br.readLine().trim().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(params[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> m = Integer.parseInt(params[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">char</span>[][] grid = <span class="keyword">new</span> <span class="keyword">char</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            grid[i] = br.readLine().trim().toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="链表输入"><a href="#链表输入" class="headerlink" title="链表输入"></a>链表输入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输入一串数字，用逗号分隔</span></span><br><span class="line"><span class="comment">    举例：</span></span><br><span class="line"><span class="comment">    1,2,3,4,5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line"></span><br><span class="line">        ListNode() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val, ListNode next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">            String s = sc.next().toString();</span><br><span class="line">            String[] arr = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">                ints[i] = Integer.parseInt(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            ListNode cur = dummyHead;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">                cur.next = <span class="keyword">new</span> ListNode(ints[i]);</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// write code here ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="树的输入-1"><a href="#树的输入-1" class="headerlink" title="树的输入 1"></a>树的输入 1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    第一行两个数 n, root，分别表示二叉树有 n 个节点，第 root 个节点是二叉树的根</span></span><br><span class="line"><span class="comment">    接下来共 n 行，第 i 行三个数 val_i, left_i, right_i</span></span><br><span class="line"><span class="comment">    分别表示第 i 个节点的值 val 是 val_i，左孩子 left 是第 left_i 个节点，右孩子 right 是第 right_i 个节点</span></span><br><span class="line"><span class="comment">    节点 0 表示空</span></span><br><span class="line"><span class="comment">    举例：</span></span><br><span class="line"><span class="comment">    5 1</span></span><br><span class="line"><span class="comment">    5 2 3</span></span><br><span class="line"><span class="comment">    1 0 0</span></span><br><span class="line"><span class="comment">    3 4 5</span></span><br><span class="line"><span class="comment">    4 0 0</span></span><br><span class="line"><span class="comment">    6 0 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// write code here ...</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树的输入-2"><a href="#树的输入-2" class="headerlink" title="树的输入 2"></a>树的输入 2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输入的第一行表示节点的个数 n（2 ≤ n ≤ 1000，节点的编号为 0 到 n - 1）组成</span></span><br><span class="line"><span class="comment">    下面是 n-1 行，每行有两个整数，第一个数表示父节点的编号，第二个数表示子节点的编号</span></span><br><span class="line"><span class="comment">    举例：</span></span><br><span class="line"><span class="comment">    5</span></span><br><span class="line"><span class="comment">    0 1</span></span><br><span class="line"><span class="comment">    0 2</span></span><br><span class="line"><span class="comment">    1 3</span></span><br><span class="line"><span class="comment">    1 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numberOfNode = sc.nextInt();</span><br><span class="line">        HashMap&lt;Integer, TreeNode&gt; nodeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> rootVal = sc.nextInt();</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="keyword">int</span> firstChildVal = sc.nextInt();</span><br><span class="line">        TreeNode firstChild = <span class="keyword">new</span> TreeNode(firstChildVal);</span><br><span class="line">        root.left = firstChild;</span><br><span class="line"></span><br><span class="line">        nodeMap.put(firstChildVal, firstChild);</span><br><span class="line">        nodeMap.put(rootVal, root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfNode - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> parentVal = sc.nextInt();</span><br><span class="line">            <span class="keyword">int</span> childVal = sc.nextInt();</span><br><span class="line">            TreeNode child = <span class="keyword">new</span> TreeNode(childVal);</span><br><span class="line">            TreeNode parent = nodeMap.get(parentVal);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    parent.left = child;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    parent.right = child;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent = <span class="keyword">new</span> TreeNode(parentVal);</span><br><span class="line">                parent.left = child;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nodeMap.put(parentVal, parent);</span><br><span class="line">            nodeMap.put(childVal, child);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write code here ...</span></span><br><span class="line"></span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU（最近最少使用）缓存</title>
      <link href="/posts/4222403320/"/>
      <url>/posts/4222403320/</url>
      
        <content type="html"><![CDATA[<p>这道题是 LeetCode 中的第 <a href="https://leetcode-cn.com/problems/lru-cache/">146</a> 号问题。LRU（Least Recently Used） 对计算机科班出身的同学应该不会陌生，那么今天就自己动手实现一个 LRU。</p><p>这是题目给出的模版：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"> 特殊要求：get 和 put 方法都要是 O(<span class="number">1</span>) 的时间复杂度</span><br></pre></td></tr></table></figure><p>首先我们可以很容易想到，用 HashMap 来存储 LRUCache 的 <code>&lt;key, value&gt;</code> 对。</p><p>但是仅用简单的 <code>HashMap&lt;Integer, Integer&gt;</code> 是不行的，因为你需要保证「最近最少使用」。那怎么保证「最近最少使用」这一特性呢？有一个思路是：使用一种<strong>线性的数据结构</strong>来维护这个特性，让这个线性结构满足：越靠近头部就说明越是最近被用到的。相反，越靠近尾部就说明越是最久没被用到的。那么当超出缓存 capacity 以后，直接删除尾部值就相当于删除了最久没使用的。</p><p>照这样描述很容易想到这个线性结构可以是链表。而且需要该链表支持如下方法：头部添加结点、删除结点、删除尾结点、找到结点并将其移动到头部。</p><p>但是不要忘了，题目还要求 O(1) 的时间复杂度。显然在单链表中查找一个值的时间复杂度时 O(n) 的，是不满足 O(1) 时间复杂度的。</p><p>那么为了满足这个条件我们可以将单链表改为「双向链表」。</p><p>为什么选择双向链表呢？</p><p>双向链表可以在 O(1) 的时间复杂度：在头部添加结点、删除结点、删除尾结点。同时「找到结点并将其移动到头部」可以通过 「删除结点 + 头部添加结点」来实现。</p><blockquote><p>Tips：建议使用带虚拟头、尾结点的双向量表</p></blockquote><p>那么我们首先根据上面关于双向链表的描述将其相关的数据结构和方法写出来。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    DLinkedNode prev, next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>&#123;<span class="keyword">this</span>.key = key; <span class="keyword">this</span>.value = value;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> DLinkedNode dummyHead, dummyTail;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">    dummyHead.next.prev = node;</span><br><span class="line">    node.next = dummyHead.next;</span><br><span class="line">    dummyHead.next = node;</span><br><span class="line">    node.prev = dummyHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">    node.prev.next = node.next;</span><br><span class="line">    node.next.prev = node.prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> DLinkedNode <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DLinkedNode tail = dummyTail.prev;</span><br><span class="line"></span><br><span class="line">    removeNode(tail);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">    removeNode(node);</span><br><span class="line">    addToHead(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们的 HashMap 存的不再是 <code>&lt;Integer, Integer&gt;</code> 了，而是 <code>&lt;Integer, DLinkedNode&gt;</code>。</p><p>你可能会问，那 value 存哪去了？答案是存在了 DlinkedNode 中的 value 中了。DlinkedNode 中包含了 key 和 value。</p><p>数据结构选好了，实现 LRU 的思路其实是很简单的。照着题目中的文字描述就可以写出伪代码。</p><p><code>get</code> 方法的伪代码是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (key 在 cache 中) &#123;</span><br><span class="line">     返回 key 对应的 value 值</span><br><span class="line">     将双向链表中的 key 对应的结点移动到链表头部</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>put</code> 方法的伪代码是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (key 在 cache 中) &#123;</span><br><span class="line">    将双向链表中的 key 对应的结点移动到链表头部</span><br><span class="line">    更新 cache 中 key 对应的结点</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    为新来的创建一个对象</span><br><span class="line">    将新对象添加到 cache 中</span><br><span class="line">    将新对象添加到双向链表的头部</span><br><span class="line">    维护 size++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">        删除尾结点</span><br><span class="line">        在 cache 中删除尾结点</span><br><span class="line">        维护 size--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上伪代码，写出完整的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 双向链表</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        DLinkedNode prev, next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span> <span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>&#123;<span class="keyword">this</span>.key = key; <span class="keyword">this</span>.value = value;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode dummyHead, dummyTail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        dummyHead = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        dummyTail = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line"></span><br><span class="line">        dummyHead.next = dummyTail;</span><br><span class="line">        dummyTail.prev = dummyHead;</span><br><span class="line"></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        DLinkedNode node = cache.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            moveToHead(node);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        DLinkedNode node = cache.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = <span class="keyword">new</span> DLinkedNode(key, value);</span><br><span class="line"></span><br><span class="line">            addToHead(node);</span><br><span class="line">            cache.put(key, node);</span><br><span class="line">            size++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                DLinkedNode tailNode = removeTail();</span><br><span class="line">                cache.remove(tailNode.key);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">            <span class="comment">// cache.put(key, node);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向链表有关操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">        node.next = dummyHead.next;</span><br><span class="line">        dummyHead.next.prev = node;</span><br><span class="line">        dummyHead.next = node;</span><br><span class="line">        node.prev = dummyHead;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">        node.prev.next = node.next;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span> <span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DLinkedNode <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode node = dummyTail.prev;</span><br><span class="line">        removeNode(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾收集器</title>
      <link href="/posts/3012520187/"/>
      <url>/posts/3012520187/</url>
      
        <content type="html"><![CDATA[<p>Java 与 C++ 之间有一堵由<strong>内存动态分配</strong>和<strong>垃圾收集技术</strong>所围成的高墙，墙外的人想进来，墙里面的人想出去。</p><p>本文用的是 HotSpot 虚拟机，其垃圾收集器有 10 种，分别是：</p><ul><li>Serial</li><li>ParNew</li><li>Parallel Scavenge</li><li>Serial Old</li><li>Parallel Old</li><li>CMS</li><li>G1（Garbage First）</li></ul><p>低延迟收集器：</p><ul><li>Shenandoah</li><li>ZGC</li></ul><p>不清理垃圾的收集器：</p><ul><li>Epsilon</li></ul><p><img src="" alt="P90 3-6"></p><h3 id="Serial（最经典）"><a href="#Serial（最经典）" class="headerlink" title="Serial（最经典）"></a>Serial（最经典）</h3><p>Serial 是 HotSpot 中最经典的垃圾收集器。因为它是<strong>单线程</strong>收集器，因此其工作的时候一定要「Stop The World」。</p><p>其采取的收集策略是：新生代采用「标记-复制」算法，老年代采用「标记-整理」算法。</p><p>其优势是：简单而高效。因此 Serial 是 HotSpot 在客户端模式下的默认收集器。</p><h3 id="ParNew（HotSpot-中第一款退出历史舞台的收集器）"><a href="#ParNew（HotSpot-中第一款退出历史舞台的收集器）" class="headerlink" title="ParNew（HotSpot 中第一款退出历史舞台的收集器）"></a>ParNew（HotSpot 中第一款退出历史舞台的收集器）</h3><p>ParNew 可以理解为是 Serial 的<strong>多线程并行</strong>版本。</p><blockquote><p>并行（Parallel）：多条垃圾收集器之间的关系。</p><p>并发（Concurrent）：垃圾收集器线程与用户线程之间的关系。</p></blockquote><h3 id="Parallel-Scavenge（吞吐量优先收集器）"><a href="#Parallel-Scavenge（吞吐量优先收集器）" class="headerlink" title="Parallel Scavenge（吞吐量优先收集器）"></a>Parallel Scavenge（吞吐量优先收集器）</h3><p>也是基于「标记-复制」算法，多线程并行收集器，诸多特性类似 ParNew。</p><p>但是，它的关注点不是尽可能的缩短垃圾收集时用户线程的停顿时间，而是<strong>达到一个可控的吞吐量（Throughput）</strong>。</p><script type="math/tex; mode=display">吞吐量=\frac{运行用户代码时间}{运行用户代码时间 + 运行垃圾收集时间}</script><p>假设，虚拟机执行完某个任务，用户代码加上垃圾收集的时间一共花了 100 分钟，垃圾收集花费了 1 分钟，那么吞吐量就是 99%。</p><p>高吞吐量表明可以最高效率的利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。</p><p>相应参数：</p><p><code>-XX:MaxGCPauseMillis</code>：控制最大垃圾收集停顿时间。</p><p><code>-XX:GCTimeRatio</code>：设置吞吐量大小。</p><p><code>-XX:UseAdaptiveSizePolicy</code>：开启后，虚拟机会根据当前系统的运行情况收集性能监控信息，动态的调整这些参数（-Xmn：新生代大小，-XX:SurvivorRatio：Eden 与 Survivor 区的比例，-XX:PretenureSizeThreshold：晋升老年代对象大小）以提供最适合的停顿时间或最大的吞吐量。</p><h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><p>单线程收集器。使用「标记-整理」算法。</p><p>主要供客户端模式下的 HotSpot 使用。在服务端下有两种用途：1). 在 JDK 5 及之前的版本中与 Parallel Scavenge 搭配使用；2). 作为 CMS 收集器在并发收集中发生 <code>Concurrent Mode Failure</code> 错误时的替补方案。</p><h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p>多线程并行收集器。使用「标记-整理」算法。</p><p>在注重吞吐量或者处理器资源较为紧缺的场合，都可以优先选择 Parallel Scavenge 加 Parallel Old 的组合。</p><h3 id="CMS（Concurrent-Mark-Sweep，并发低停顿收集器）"><a href="#CMS（Concurrent-Mark-Sweep，并发低停顿收集器）" class="headerlink" title="CMS（Concurrent Mark Sweep，并发低停顿收集器）"></a>CMS（Concurrent Mark Sweep，并发低停顿收集器）</h3><p>以最短回收停顿时间为目标。基于「标记-清除」算法。</p><p>运行过程分为如下四个步骤：</p><ol><li>初始标记（CMS initial mark），仅标记一下 GC Roots 可以关联到的对象，速度很快。</li><li>并发标记（CMS <strong>concurrent</strong> mark），从 GC Roots 的直接关联对象开始遍历整个对象图的过程。</li><li>重新标记（CMS remark），修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（增量更新）。</li><li>并发清除（CMS <strong>concurrent</strong> sweep），清理删除掉标记阶段判断的已经死亡对象。</li></ol><p>1、3 需要 Stop The World。</p><p>缺点：</p><ol><li>处理器资源敏感。面向并发设计的程序的通病。其默认开启的回收线程数是：<code>（处理器核心数量 + 3）/ 4</code>。</li><li>无法处理浮动垃圾（Floating Garbage），有可能出现 <code>Concurrent Mode Faliure</code> 失败，进而导致另一次完全 Stop The World 的 Full GC 产生。同样，在垃圾收集阶段用户线程还在运行，因此需要预留足够空间来存放用户线程产生的垃圾。可以通过 <code>-XX:CMSItitiatingOccu-pancyFraction</code> 参数来设置，当老年代空间占用率达到多少时开启垃圾回收（触发百分比）。这个参数的设定要根据实际环境来选择：太小，如果垃圾增长不是很快，就有点浪费空间；太大，容易出现 <code>Concurrent Mode Faliure</code> 异常，这时会启动后备预案，冻结用户线程执行，临时启用 Serial Old 来收集老年代的垃圾。</li><li>因为采用了「标记-清除」算法，因此会导致空间碎片过多。会给大对象分配带来麻烦，明明老年代总空间够，但是因为都是分散的所以不能用来分配给大对象，这会导致 Full GC。提供的两个相关参数 <code>-XX:UseCMSCompactAtFullCollection</code> 和 <code>-XX:CMSFullGCsBeforeCompaction</code> 在 JDK 9 以后都废弃了。</li></ol><p>CMS 已经被标为 Deprecate（不推荐使用）。</p><h3 id="Garbage-First（G1，全功能垃圾收集器）"><a href="#Garbage-First（G1，全功能垃圾收集器）" class="headerlink" title="Garbage First（G1，全功能垃圾收集器）"></a>Garbage First（G1，全功能垃圾收集器）</h3><p>G1 是垃圾收集器技术发展史上的里程碑式成果，开创了收集器<strong>面向局部收集</strong>的设计思路和<strong>基于 Region 的内存布局</strong>形式。其主要面向服务端，在 JDK 9 发布以后，已经取代了 Parallel Scavenge 加 Parallel Old 组合，成为服务端默认的收集器。</p><p>G1 收集器的设计者希望能做出一款「停顿预测模型」（Pause Prediction Mode）的收集器。停顿预测模型：能够支持指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过 N 毫秒的目标。</p><p>想要实现这样的目标，那就不能再面向分代或者是整个 Java 堆来收集垃圾了。G1 的做法是：可以面向堆内任何部分来组成回收集（Collection Set）进行回收。其衡量标准不再是它属于哪个分代，而是<strong>哪块内存中存放的垃圾数量最多，回收收益最大</strong>，这就是 G1 的 Mixed GC 模式。</p><p>在 Java 堆的划分上，G1 将整个堆空间划分成<strong>多个大小相等的独立区域</strong>（Region），每个 Region 可以扮演 Edin、Survivor 或老年代空间，Region 大小可用参数 <code>-XX:G1HeapRegionSize</code> 来设定。将 Region 看作是最小的回收单元，这样可以有计划的避免在整个 Java 堆中进行全区域的垃圾收集。</p><p>Region 中还有一类特殊区域：Humongous，专门用来存放大对象（超过一个 Region 容量的一半）。如果一个超大对象超过了一个 Region 的空间，那么会分配 N 个连续的 Humongous Region。G1 将 Humongous Region 作为老年代来对待。</p><p>具体回收思路是：G1 收集器去跟踪各个 Region 里面的垃圾堆积的「价值」（回收所获得的空间大小以及回收所需要的时间经验值）大小，然后维护一个优先级列表，每次根据用户设定的收集停顿时间（-XX:MaxGCPauseMillis，默认 200ms）优先处理回收价值收益最大的 Region，这也是 Garbage First 名称的由来。</p><p>同时，G1 也有一些细节需要妥善处理：</p><ul><li>如何处理跨 Region 引用对象？</li></ul><p>使用记忆集（Remembered Set）。每个 Region 都要维护自己的记忆集。G1 的记忆集本质是一种哈希表，Key 是别的 Region 的起始地址（谁指向我），Value 是一个集合，里边存储的是卡表的索引号（我指向谁）。这是一种「双向」卡表结构。因为 Region 个数比传统分代多，同时是双向的，所以 G1 有更高的内存占用负担。</p><ul><li>在并发标记阶段如何保证收集线程与用户线程会不干扰？</li></ul><p>采用原始快照（SATB）算法。另外，针对在 G1 运行过程中新创建的对象，G1 设立了两个 TAMS（Top At Mark Start）指针，把 Region 中一部分空间划分出来用于并发回收过程中的新对象分配。并发过程中新分配的对象的地址必须要在这两个 TAMS 指针位置以上。如果 G1 回收速度赶不上新对象的分配速度，那么会被迫冻结所有用户线程，执行一次 Full GC。</p><ul><li>怎样建立可靠的停顿预测模型？</li></ul><p>使用「衰减均值」（Decaying Average）。衰减平均值：比普通的平均值更容易受到新数据的影响，更准确的代表最近的平均状态。Region 的统计状态越新越能决定其回收的价值。</p><p>G1 运行过程：</p><ol><li>初始标记（Initial Marking）。仅标记一下 GC Roots 能直接关联的对象，并修改 TAMS 指针。</li><li>并发标记（Concurrent Marking）。从 GC Roots 开始进行可达性分析，递归的找出要回收对象。</li><li>最终标记（Final Marking）。短暂暂停用户线程，用于处理并发阶段结束后仍遗留下来的最后那少量的 SATB 记录。</li><li>筛选回收（Live Data Counting and Evacuation）。更新 Region 的统计数据，对 Region 的回收价值和成本进行排序，根据期望停顿时间来制定回收计划。将回收的 Region 中的存活对象<strong>复制</strong>到空的 Region 中，再清理掉整个旧 Region 全部空间。</li></ol><p>其目标是：在延迟可控的基础上，尽可能提高吞吐量。</p><p>不足：内存占用（Footprint）和程序运行时的额外执行负载（Overload）都比较高。</p><h3 id="Shenandoah"><a href="#Shenandoah" class="headerlink" title="Shenandoah"></a>Shenandoah</h3><p>「免费开源版」比「收费商业版」功能更多，只在 OpenJDK 才会包含，OracleJDK 中不可用。</p><p>设计目标：能在任何堆内存大小下都可以把垃圾收集的停顿时间控制在<strong>十毫米以内</strong>。</p><p>Shenandoah 类似是 G1 的继承者。但是也有一些不同：</p><ol><li>支持并发的整理算法。</li><li>默认不使用分代收集。</li><li>废弃记忆集，使用「连接矩阵」（Connection Matrix）这种全局的数据结构来记录跨 Region 引用。可以简单理解为一张二维表格，如果 Region N 有对象指向 Region M，就在该表格的 N 行 M 列打上一个标记。</li></ol><p>运行过程：</p><ol><li>初始标记（Initial Mark）。标记 GC Roots 直接关联对象。</li><li><strong>并发标记（Concurrent Marking）</strong>。遍历对象图，标记所有可达对象。</li><li>最终标记（Final Marking）。处理剩余的 SATB 扫描，并统计出回收价值最高的 Region。</li><li>并发清理（Concurrent Cleanup）。清理整个区域 0 存活的 Region（Immediate Garbage Region）。</li><li><strong>并发回收（Concurrent Evacuation）</strong>。先将回收集里面的存活对象复制一份到其他未被使用的 Region 中。但在移动时，用户线程可能继续读写访问被移动对象，而且对象移动后，整个内存中所有指向该对象的引用还是旧对象的引用，很难一瞬间改过来。解决方法是，使用读屏障和「Brooks Pointers」的转发指针。</li><li>初始引用更新（Initial Update Reference）。并没有实际进行引用更新。设立这个阶段只是为了建立一个线程集合点，用来确保所有并发回收阶段中进行的收集器线程都已经完成分配给它们的对象移动任务。</li><li><strong>并发引用更新（COncurrent Update Reference）</strong>。真正进行引用更新操作，只需要按照内存物理地址顺序，线性的搜索出引用类型，把旧值改为新值。</li><li>最终引用更新（Final Update Reference）。修正存在于 GC Roots 中的引用。</li><li>并发清理（Concurrent Cleanup）。回收 Region 空间。</li></ol><p>重点是「并发标记」、「并发回收」和「并发引用更新」三个阶段。</p><p><img src="" alt="P08 3-16"></p><p>转发指针（Forwarding Pointer 或者 Indirection Pointer）：一种用来实现对象移动与用户线程并发的解决方案。该方法不用需要使用需要操作系统层面支持的「内存保护陷阱」。而是在原有对象布局结构的最前面统一增加一个新的引用字段，在正常处于不并发移动的情况下，该对象指向对象自己。当需要并发移动时，只需要修改旧对象上转发指针的引用位置，使其指向新对象。</p><p>同时，必须要对转发指针的访问操作采取同步措施（尤其是在并发读写时），收集器线程和用户线程只有其中之一可以访问成功，另一个必须等待。Shenandoah 采用「比较并交换」（Compare And Swap，CAS）来保证并发时对象访问的正确性。</p><p>不足：</p><ul><li>因为为每一个对象都添加了转发指针，在「对象访问」时（Java 万事万物皆对象），都必须要访问该指针，因此需要注意「执行频率」的问题。同时为了覆盖全部对象访问操作，Shenandoah 不得不设置读、写访问屏障。</li><li>读屏障的使用代价比写屏障要到，因为对象读取比写入频率要更大。为了缓解这个问题，Shenandoah 计划在 JDK 13 中使用「引用访问屏障」（Load Reference Barrier）：内存屏障只拦截对象中数据类型为引用类型的读写操作。</li></ul><h3 id="ZGC（Z-Garbage-Collection）"><a href="#ZGC（Z-Garbage-Collection）" class="headerlink" title="ZGC（Z Garbage Collection）"></a>ZGC（Z Garbage Collection）</h3><p>与 Shenandoah 的目标高度相似，但是实现思路存在显著差异。</p><p>主要特征：基于 Region 内存布局的，（暂时）不设分代的（因此无跨代引用问题），使用了读屏障、染色指针和内存多重映射等技术来实现可并发「标记-整理」算法的，以低延迟为首要目标的一款垃圾收集器。</p><p>ZGC 的 Region 具有动态性——动态的创建和销毁，以及动态的区域容量大小。Region 区域分为小型、中型和大型三种。</p><ul><li>小型 Region（Small Region）：容量固定为 2MB，用于存放小于 256KB 的小对象。</li><li>中型 Region（Medium Region）：容量固定为 32MB，用于存放大于等于 256KB 但小于 4MB 的对象。</li><li>大型 Region（Large Region）：容量不固定，可以动态变化，但必须是 2 的整数倍，用于存放 4MB 或以上的大对象。大型 Region 在 ZGC 中不会被重新分配。</li></ul><p><strong>ZGC 的核心问题：并发整理算法。</strong>ZGC 采用染色指针（Colored Pointer）直接把标记信息记录在引用对象的指针上，之前是遍历引用图来标记对象，现在可以说是遍历引用图来标记「引用」。</p><p>染色指针：一种将少量额外的信息存储在指针上的技术。64 位操作系统，实际只用了 4、50 位（架构不同，使用数量不同），剩下的高位地址并没有被使用到，不可以用来寻址。如果只用 46 位寻址，这样可以支持 64TB 的内存，但大部分的服务器都用不到这么大。因此 GC 就盯上了这 46 位地址的高 4 位，用来存储 4 个标志信息，分别是：是否只能通过 finalize() 方法才能被访问（Finalizable）、是否进入重分配集（Remapped）、三色标记（Marked 1 和 Marked 0）。</p><p>染色指针三大优势：</p><ol><li>一旦某个 Region 的存活对象被移走之后，这个 Region 就能立即被清理解放和重用掉，不用等待堆中所有指向该 Region 的引用都被修正后才清理。这也是染色指针的「自愈」特性。</li><li>大幅减少垃圾收集过程中内存屏障的使用数量。</li><li>染色指针作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后能进一步提高性能。</li></ol><p>实现染色指针在操作系统层面的难点：JVM 只是操作系统中一个普通的线程，那 JVM 对操作系统的地址空间的修改，能让操作系统正确的执行么？</p><p>在 Solaris/SPARC 平台中可以使用「虚拟地址掩码」，设置以后机器指令可以自动忽略掉染色指针的标记位。但在 x86-64 平台就需要用到「虚拟内存映射」技术。</p><p>ZGC 运行过程：</p><ol><li>并发标记（Concurrent Mark）。遍历对象图做可达性分析，ZGC 会更新染色指针中的 Marked 0 和 Marked 1 标记位。</li><li>并发预备重分配（Concurrent Prepare for Relocate）。这个阶段根据特定的查询条件统计出本次收集过程中要清理哪些 Region。</li><li><strong>并发重分配（Concurrent Reloca）</strong>。将重分配集中的存活对象复制到新的 Region 上，并为重分配集中的每个 Region 维护一张转发表（Forward Table）记录从旧对象到新对象的转向关系。得益于染色指针的使用，ZGC 可以仅从引用就明确得知一个对象是否处于重分配集中，如果此时用户线程访问了位于重分配集中的对象，这次访问就会被预置的内存屏障所截获，然后立即根据 Region 上的转发表记录将访问转发到新复制的对象上，并且同时修正更新该引用的值。ZGC 将这种行为称为指针的「自愈」（Self-Healing）。只有第一次访问就对象才会陷入转发。</li><li>并发重映射（Concurrent Remap）。修正整个堆中指向重分配集中旧对象的所有引用。该任务并不迫切，因为可以自愈。ZGC 巧妙的将并发重映射阶段的工作，合并到下一次垃圾收集循环中的并发标记阶段去做。因为它们都要遍历所有的对象，这样就可以省一次遍历。一旦所有指针被修正，转发表就可以释放了。</li></ol><p>ZGC 的不足：因为不分代，所以承受的对象分配速率不会太高。</p><p><a href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">新一代垃圾回收器ZGC的探索与实践 - 美团技术团队</a></p><h3 id="Epsilon"><a href="#Epsilon" class="headerlink" title="Epsilon"></a>Epsilon</h3><p>被形容为一个无操作的收集器（A No-Op Garbage Collector）。</p><p>垃圾收集器除了垃圾收集这个本职工作以外，还要负责<strong>堆的管理与布局</strong>、<strong>对象的分配</strong>、与解释器的协作、与编译器的协作、与监控子系统协作等职责。其中堆的管理与布局和对象的分配是一个垃圾收集器必须具备的内容。</p><p>如果用户程序只需要运行数分钟甚至数秒的时间，只要 Java 虚拟机能正确分配内存，在堆耗尽之前就会退出，那么负载极小、没有任何回收行为的 Epsilon 便是很好的选择。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归回溯问题（排列和组合）</title>
      <link href="/posts/3689224355/"/>
      <url>/posts/3689224355/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写在前面：本文的一些定义不一定是对的，我就是把我的思路写出来了。</p></blockquote><p>递归一般是和树紧密相连的。回溯也可以认为是在树形结构中进行的。</p><p>回溯就是递归触底了然后向上返。同时在向上返的过程中要注意「恢复状态」。不能说返回到上一级了，状态还是当前层级的。</p><p>回溯问题一般和排列、组合问题关系比较密切。排列、组合需要枚举所有的可能性，枚举的过程就可以画出一棵树形图，然后在树里边选择符合题意的。<strong>因此解答回溯问题一般都是建议要先画出树形图。</strong></p><p>画好树形图，就可以写代码了。</p><p>下面总结了几个技巧：</p><ul><li>大概的框架：</li></ul><p>这题是 39 号问题，这里只用来说明一般的代码框架。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 一般都会用到这两个变量，ans 存放最终答案，curAns 存放当前答案</span></span><br><span class="line">        <span class="comment">// 存放当前答案的 curAns 也不一定是一个，也可能是多个。比如二进制手表问题</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; curAns = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        dfs(candidates, target, <span class="number">0</span>, ans, curAns);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * candidates 和 target 是题目给定的</span></span><br><span class="line"><span class="comment">    * idx 是用来控制下层递归的开始位置的。这个参数比较多变</span></span><br><span class="line"><span class="comment">    * ans 和 curAns 是用来保存答案的</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> idx, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; curAns)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在什么条件下就不继续走了</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在什么条件下需要将 curAns 存入到 ans</span></span><br><span class="line">        <span class="comment">// 也有的题目不需要这个 if，只要见到 curAns 就存到 ans 里面。比如子集问题</span></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curAns));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一般都有这层循环，循环整个给定的数组，还是只循环 idx 之后的部分要根据题目来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 这里可以进行一些「剪枝」操作。根据树形图来想</span></span><br><span class="line">            <span class="comment">// break、continue、return 都可以用来剪枝，但是具体的要根据题目来</span></span><br><span class="line">            <span class="keyword">if</span> (target - candidates[i] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将当前的内容加到 curAns</span></span><br><span class="line">            curAns.add(candidates[i]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 递归调用</span></span><br><span class="line">            dfs(candidates, target - candidates[i], i, ans, curAns);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 「恢复状态」。递归之前改了什么，这里就再改回来</span></span><br><span class="line">            curAns.remove(curAns.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>如果题目给的数据有重复元素，那么一般的做法是：</li></ul><ol><li>将给定的数组排序</li><li>在递归函数里用这句话处理重复元素：<code>if (i &gt; idx &amp;&amp; nums[i] == nums[i - 1]) continue;</code>。这样可以省略掉 <code>used</code> 数组，如果想用 <code>used</code> 数组的话，这样处理重复元素：<code>if (used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) continue;</code>。注意这两种方式的 <code>i</code> 条件不一样，一个是 <code>i&gt;idx</code> 一个是 <code>i&gt;0</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的2021年终总结</title>
      <link href="/posts/2149195520/"/>
      <url>/posts/2149195520/</url>
      
        <content type="html"><![CDATA[<p>回头看看 2020 年立下的 flag，一共 3 个，有 1 个没完成。</p><p>实习，一直没去投简历。无论怎样 2022 年一定要去实习的了，必须要抓住秋招。</p><p>虽然没去实习但是也一直在准备当中。分门别类的刷了 100+ 力扣，坚持了两个月了。2022 年希望也不要落下。打算充个力扣会员，重点练一下各个大厂的算法题。还要在保持题目熟练度的同时，开始准备其他面试考点。</p><p>英语，其实当时是买了一本英文原著的，但是看了几页就发现有问题：查词太麻烦。有的词可以猜或者是跳过，但是遇到必须要查的词就要一个个的手动查，同样有的句子实在看不懂，就要一个句子手动查，有点打击积极性行。</p><p>后来就改变了学英语的策略。看 Youtube、听 TED、刷 Twitter、读文章、用英文 Google 等等，反正就是尽可能的多用英语，主要还是用起来。</p><p>2021 年的后半年，英语确实有一些提升。阅读更顺畅了，听力也不是光听见吧啦吧啦了，起码有的可以听懂原文大意。所以我觉得英语方面，其实可以算是完成的了。</p><p>如果说再往前看看 2019 年的 flag，那可以说是完全脱节了。视频剪辑、日语、公号写文章，可以说是都没了，对象也没了，只有每天读书半小时还在（读书在持续，每天不一定半小时），写公号也变成了写知乎。</p><p>提到知乎，今年知乎好物入账 4000+，这其中有自己买东西返的，也有今年还没结算的。知乎基本上就是写写 Apple 产品，写的不多。2022 年这个收入来源还可以稳住。</p><p>顺便看了下基金收益，今年的收益率是 2.60%，着实有点低了啊。一开始随便看了几只鸡定投，结果收益并不理想。再多拿一些时间看吧。总之不亏。</p><p>健康方面，每周都在坚持锻炼，天热就跑步，天冷就锻炼核心。总之一直在坚持。还做了基因检测，结果说我会头秃，真是让人头秃。还有每年体检，每半年洗牙。</p><p>2021 年读了 50 本书。看了 139 部电影。听歌发现了新大陆，Queen、David Bowie、Bob Dylan、The Cure 等等好多，越听越开心。</p><p>2022 年的 flag：</p><ol><li><strong>准备秋招，争取上岸大、中厂</strong></li><li>英语学习继续不要停，每天都要用英语。六级达到 550+</li><li>读书 50+ 本</li></ol><p>万物之中，希望之美。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自底向上的归并排序（可用于链表排序）</title>
      <link href="/posts/3065856477/"/>
      <url>/posts/3065856477/</url>
      
        <content type="html"><![CDATA[<p>从 1 个元素开始归并，逐渐向上归并到全部元素。</p><p>链表排序，就可以使用这种「自底向上的归并排序」思想。但是又因为链表不能通过下标来划分子序列，所以操作上和数组还是有些区别的，但是思路是一样的。详见 <a href="https://leetcode-cn.com/problems/sort-list/">LeetCode  148 号问题：排序链表</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortBU</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 和自顶向下的归并排序中的 merge 函数一样</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        Comparable[] aux = Arrays.copyOfRange(arr, l, r + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">                arr[k] = aux[j - l];</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; r) &#123;</span><br><span class="line">                arr[k] = aux[i - l];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i - l].compareTo(aux[j - l]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[k] = aux[i - l];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[k] = aux[j - l];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化：对于小数组, 使用插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">16</span>)</span><br><span class="line">            InsertionSort.sort(arr, i, Math.min(i + <span class="number">15</span>, n - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sz：元素个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">16</span>; sz &lt; n; sz &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// i：每轮操作的起点元素位置，每次归并 2*sz 个元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - sz; i += sz + sz) &#123;</span><br><span class="line">                <span class="comment">// 优化：对于 arr[mid] &lt;= arr[mid+1] 的情况，不进行 merge</span></span><br><span class="line">                <span class="comment">// 详见：https://xuguangwei.com/posts/3037455158/</span></span><br><span class="line">                <span class="keyword">if</span> (arr[i + sz - <span class="number">1</span>].compareTo(arr[i + sz]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// merge(arr, left, mid, right)</span></span><br><span class="line">                    <span class="comment">// 防止剩下的右半部分不够 sz 个，所以用了 min 方法。</span></span><br><span class="line">                    merge(arr, i, i + sz - <span class="number">1</span>, Math.min(i + sz + sz - <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/posts/2522177458/"/>
      <url>/posts/2522177458/</url>
      
        <content type="html"><![CDATA[<p>相信扑克牌大家都玩过，当随机发给你一捋扑克牌，你会先将牌理好，然后再想一下这手牌的好坏。那你会怎样将这捋扑克牌理好呢？</p><p>这时你可以借助「插入排序」的算法思想：从最后一张牌开始看，看这张牌之前的牌比它大还是小，如果前面的牌比它大（假设进行升序排序），那就继续往前看一张，直到看到第一张比它小的牌。此时你就可以将它插在比它小的牌后边。如果发现看到这捋牌的第一张，发现每张都比它大，那说明它是最小的，直接插在第一张的位置就好了。插好这张牌的位置后，继续从后往前看下一张牌，重复上述步骤，直到最后一张牌看完为止。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InsertionSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 arr 数组使用 InsertionSort 排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Comparable e = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>].compareTo(e) &gt; <span class="number">0</span>; j--)</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">            arr[j] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 arr[l...r] 的区间使用 InsertionSort 排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">            Comparable e = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; l &amp;&amp; arr[j - <span class="number">1</span>].compareTo(e) &gt; <span class="number">0</span>; j--)</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">            arr[j] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序（优化）</title>
      <link href="/posts/3037455158/"/>
      <url>/posts/3037455158/</url>
      
        <content type="html"><![CDATA[<p>归并排序的算法思想：递归的将待排序大数组一分为二，直至不可再分，即分割后的小数组只有一个待排序元素为止。此时使用合并算法思想，对已经有序的数组进行合并，合并为一个大数组。不断重复合并过程，直至所有小数组合并为一个数组为止。</p><p>归并排序的时间复杂度是：O($N \log_{}N$)。假如有待排序大数组有 8 个元素，那么只需要分割 $\log_{2}8=3$ 次，就可以达到不可再分的状态。然后每一步都需要 O(N) 的复杂度来合并。因此总的时间复杂度是 O($N \log_{}N$)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 arr[l...mid] 和 arr[mid+1...r] 两部分进行归并，注意前后都是闭区间</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        Comparable[] aux = Arrays.copyOfRange(arr, l, r + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化，i 指向左半部分的起始索引位置 l；j 指向右半部分起始索引位置 mid+1</span></span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid) &#123;  <span class="comment">// 如果左半部分元素已经全部处理完毕</span></span><br><span class="line">                arr[k] = aux[j - l];</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; r) &#123;   <span class="comment">// 如果右半部分元素已经全部处理完毕</span></span><br><span class="line">                arr[k] = aux[i - l];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i - l].compareTo(aux[j - l]) &lt; <span class="number">0</span>) &#123;  <span class="comment">// 左半部分所指元素 &lt; 右半部分所指元素</span></span><br><span class="line">                arr[k] = aux[i - l];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 左半部分所指元素 &gt;= 右半部分所指元素</span></span><br><span class="line">                arr[k] = aux[j - l];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归的调用归并排序，对 arr[l...r] 的范围进行排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 优化: 对于小规模数组, 使用插入排序</span></span><br><span class="line">        <span class="keyword">if</span> (r - l &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">            InsertionSort.sort(arr, l, r);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        sort(arr, l, mid);</span><br><span class="line">        sort(arr, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化: 对于 arr[mid] &lt;= arr[mid+1] 的情况，不进行 merge</span></span><br><span class="line">        <span class="comment">// ---</span></span><br><span class="line">        <span class="comment">// 因为，通过上面递归的对左、右部分分别排序后，左半部分的最后一个元素，即 arr[mid]，一定是左半部分中最大的</span></span><br><span class="line">        <span class="comment">// 同理，右半部分的第一个元素，即 arr[mid+1]，一定是右半部分中最小的。因此如果 arr[mid] &lt;= arr[mid+1]，</span></span><br><span class="line">        <span class="comment">// 则说明，当前 sort 递归子函数处理的数据范围已经是排好序的了，因此可以不用再进行一次 merge</span></span><br><span class="line">        <span class="comment">// ---</span></span><br><span class="line">        <span class="comment">// 对于近乎有序的数组非常有效，但是对于一般情况，有一定的性能损失。因为每次都会调用 if</span></span><br><span class="line">        <span class="comment">// 所以，如果你知道你的待排序数据近乎有序，那可以加上这条优化，否则去掉这个 if 判断就好</span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid].compareTo(arr[mid + <span class="number">1</span>]) &gt; <span class="number">0</span>)</span><br><span class="line">            merge(arr, l, mid, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line"></span><br><span class="line">        sort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年我的桌面布局</title>
      <link href="/posts/1269404121/"/>
      <url>/posts/1269404121/</url>
      
        <content type="html"><![CDATA[<p>我也是读了研才享受到宿舍这种「上床下桌」的待遇的。</p><p>专科的时候，住的是 7 人间，只有一个下铺是书桌。但是空间太小只能满足 3 连坐，所以一般都是用抢的。我在上铺，为了方便就买了一个直接放床上的多层书桌。不过没用多久，导员查宿舍就给我收走了。后来只好买的那种可折叠的小桌板。而且我的电脑是游戏本，特别沉。每天都要在衣橱里拿出来，用完了，再放回去。就这样过了三年。</p><p>升本以后，更惨。直接没有书桌。就只好继续用小桌板。不过好在买了一个 MacBook Air，比较游戏本整体上省事了不少。</p><p>后来考研的时候我就想，一定要考去一个有「上床下铺」的学校。这也算是我考研的一大动力。</p><p>终于，在研究生的时候，用上了「上床下铺」。</p><h3 id="0-全景"><a href="#0-全景" class="headerlink" title="0.全景"></a>0.全景</h3><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.22/img/postImg/IMG_0459.jpeg" alt=""></p><p>很简单，没有贴壁纸，也没有花里胡哨的灯光秀。</p><p>我从左上开始逆时针，逐个介绍一下。</p><h3 id="1-左上"><a href="#1-左上" class="headerlink" title="1. 左上"></a>1. 左上</h3><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.22/img/postImg/IMG_0460.jpeg" alt=""></p><p>这个框里没啥，就是一些专业书。最上面那个是国誉的活页本。纸质非常好，用钢笔写起来唰唰的，很得劲。不过现在也基本上不记笔记了，因此就闲置了。</p><h3 id="2-左中"><a href="#2-左中" class="headerlink" title="2. 左中"></a>2. 左中</h3><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.22/img/postImg/IMG_0470.jpeg" alt=""></p><p>那个汤姆猫是吃麦当劳儿童套餐送的玩具。</p><p>中间那个是手冲壶，平时会做一些手冲咖啡。有时候泡早餐也会用到它。</p><p>右边是镜子。现在被我用的调整角度的时候有点松了。</p><p>镜子后面是洁柔的手帕纸。很小一包，放在口袋里刚好。上次在老罗直播间抢的时候手速太快了，选错香型了，发过来一看买的是古龙香的。平时我更喜欢用无香的。</p><p>汤姆猫后面是手冲滤纸和治光师咖啡。</p><h3 id="3-左下"><a href="#3-左下" class="headerlink" title="3. 左下"></a>3. 左下</h3><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.22/img/postImg/IMG_0471.jpeg" alt=""></p><p>这些是我平时用的护肤品。</p><p>freeplus 的水和乳。我每用完一套之后，都会换。这次用的是 freeplus 的，洗面奶也是他家的。觉得还挺好用的，不油腻，也不会干燥起皮。</p><p>怀尔德的牙膏，听说可以美白牙齿，买来试用一下。</p><p>美润护手霜。非常好用，强烈推荐。我用过十多种护手霜，美润排第一。质地很细腻，非常容易推开。</p><p>妮维雅唇膏和曼秀雷敦唇膏。冬天嘴唇容易干，唇膏是必备的。妮维雅的有点油，曼秀雷敦的比较清爽，味道和清凉油差不多，薄荷味的。</p><p>欧乐 B 的牙线。平时多注意口腔卫生，半年洗一次牙，电动牙刷用起来。</p><p>牙签没啥好说的，剔牙和用来吃东西。</p><p>最前面是鳄鱼夹，洗脸的时候用来夹刘海的。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.22/img/postImg/IMG_0463.jpeg" alt=""></p><p>最左边是一个放杂物的盒子，比如指甲刀、挖耳勺、备用机等。</p><p>3M 的屏幕清洁剂。平时擦擦电脑屏幕，擦擦手机和平板都非常好用。</p><p>3M 下面是铅笔盒，一般都用不到了。</p><p>最右边是两瓶墨水，鲶鱼和极黑。平时我比较爱用钢笔。等下介绍我用的钢笔。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.22/img/postImg/IMG_0479.jpeg" alt=""></p><p>一个电子秤和 Rivers sleek 咖啡杯。电子秤是用来称麦片和代餐的。</p><h3 id="4-中间"><a href="#4-中间" class="headerlink" title="4. 中间"></a>4. 中间</h3><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.23/img/postImg/IMG_0472.jpeg" alt=""></p><p>中间就是主战场了。</p><p>最左边和最右边角落，是香薰。也是老罗直播间抢的，说实话味道有点淡。</p><p>iPad Pro 10.5。最主要的用途就是给 MBP 做外接显示器。其次是记记笔记，看看电子书。</p><p>iPad 前面是晨光的自动笔，便签纸和<strong>百乐 Capless decimal 18K</strong>。百乐是我的日常主力笔，Capless 就是「没有笔帽」，采用的按压式的设计。是的，钢笔也可以像圆珠笔一样按压出笔尖。这样平时就不用担心笔帽不小心掉地上或者是找不见的问题，而且也省了一只手来旋笔帽。我用的是 F 尖，粗细刚好，阻尼适中，日用神器。以前考虑过买万宝龙 146 T 舌 EF，握感和书写阻尼感倒是非常好，但是太粗了，非常不适合日常使用。</p><p>对了，钢笔原来的上墨器因为储墨量太小也被我替换掉了。我直接用的这种一次性的墨囊。墨水用完，我就会用打疫苗用的那种小针管，给墨囊上墨。储墨量可以有 0.8ml，上一次可以用很久，而且用针管上墨也不会染黑笔尖。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.22/img/postImg/IMG_0475.jpeg" alt=""></p><p>笔架是一只小螃蟹，个人非常喜欢。</p><p>对了还有三菱 SXN-1000，这支笔也非常好用。有的场景，比如画图，需要快速画出长直线，我怕磨损钢笔尖，就会用它。无奈我的那支放在实验室不知道被谁顺走了。后来就用晨光这支自动笔代替了。</p><p>主力机 MBP Intel 版本的。够用，暂时觉得没必要升 M1。平时用的最多的就是它了，手机都排在它后边。学习娱乐都非常带劲。</p><p>MBP 前面的那本蓝色的书，是用来做掌托的。高度正好和 MBP 平齐。自从买了 MBP 我平时就基本不用鼠标了，直接用触控板。但是 MBP 和桌面是有高度差的，因此有个掌托就非常有必要。选来选去，最终灵机一动在书架上选中了这本书，书名是《超文本和超链接》。还会散发出纸质书的香气，非常带劲。</p><p>小黄鸭，和戴在脖子上的星球手串。手串是以前携程搞菠萝奖什么的买的，还有一件 T 恤，几包太空种子等。</p><p>小黄鸭前面是 AirPods Pro。也是非常带劲。大家都知道，我就不多介绍了。</p><p>鼠标垫是 CHERRY 的。这还是以前用鼠标的时候买的了。现在用来放一些怕刮花的物品，耳机、Pencil、手机和 Watch 等。</p><p>Apple Pencil。也没啥好介绍的，大家都知道。</p><p>鼠标垫上最右边是 Watch 和 iPhone 的充电器。等下在「充电」里一起介绍。</p><h3 id="5-中上"><a href="#5-中上" class="headerlink" title="5. 中上"></a>5. 中上</h3><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.22/img/postImg/IMG_0464.jpeg" alt=""></p><p>主要还是放书的。</p><p>最左边是雨伞。雨伞旁边是一个置物盒，就是携程的包装盒。</p><p>最右边是两种麦片，水果麦片和原味麦片，早餐。</p><h3 id="6-台灯"><a href="#6-台灯" class="headerlink" title="6. 台灯"></a>6. 台灯</h3><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.22/img/postImg/IMG_0473.jpeg" alt=""></p><p>这个台灯要单独说一下，它跟了我至少 5 年了。触控无极亮度和色温调节，角度也可以说是无极调节。非常带劲。</p><p>同样跟了我这么这么久的，还有我的腰带，跟了我至少 10 年了。N+a 的，不知道现在还有没有人记得这个牌子。</p><h3 id="7-充电"><a href="#7-充电" class="headerlink" title="7. 充电"></a>7. 充电</h3><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.22/img/postImg/IMG_0466.jpeg" alt=""></p><p>我用了两个插排，一个给 MBP 充电，以及早上用吹风机。一个给给 MBP 充电的插排供电，还给手表和手机充电，这个插排我用淘宝买的插排固定器给固定在侧面板上了。这些插头平时都是一直插在上边。</p><p>就像这样。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.22/img/postImg/IMG_0469.jpeg" alt=""></p><p>虽然没有做无线处理，但是看着也还行，乱有乱的美，手动狗头.jpg</p><p>一切都在我的掌握之中。</p><h3 id="8-椅子"><a href="#8-椅子" class="headerlink" title="8. 椅子"></a>8. 椅子</h3><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.22/img/postImg/IMG_0478.jpeg" alt=""></p><p>椅子我买的是西昊 M18。平时基本天天在电脑前面坐着，所以决定买个好点的椅子。不过就有一点不好，有杂音，后来上过一次润滑油，但还是会发出轻微的杂音。</p><p>椅子上面的白布是一件 T 恤，放了一年发现莫名的变黄了，正好就用来垫椅子了。</p><p>椅子后面是我的书包。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.22/img/postImg/IMG_0467.jpeg" alt=""></p><p>书包也用了好久了，肩带都有点掉皮了，最近一直想重新买一个，但也一直没碰到喜欢的，再看吧。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>双路快速排序</title>
      <link href="/posts/1945709387/"/>
      <url>/posts/1945709387/</url>
      
        <content type="html"><![CDATA[<p>双路快速排序是快排的优化版。</p><p>双路快排的思想是，在待排序数组 <code>[l, r]</code> 的头和尾分别设置一个指针 <code>i = l + 1</code> 和 <code>j = r</code>，使得  <code>arr[l+1...i) &lt;= v；arr(j...r] &gt;= v</code>。这样可以使算法在待排序数组的左右两边同时推进。</p><p>问题：</p><ol><li>为什么是 <code>arr[l+1...i) &lt;= v</code> 而不是 <code>arr[l...i) &lt;= v</code>？因为 <code>l</code> 被拿去用来做标定点 <code>v</code> 了。</li><li>为什么标定点两边都有等于 <code>v</code> 的元素？具体原因请看代码注释。</li></ol><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">注释版</button></li><li class="tab"><button type="button" data-href="#1-2">纯净版</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort2Ways</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line"></span><br><span class="line">        quickSort2Ways(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归调用 quickSort2Ways，对 arr[l...r] 的范围进行排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort2Ways</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= l) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p = partition(arr, l, r);</span><br><span class="line"></span><br><span class="line">        quickSort2Ways(arr, l, p - <span class="number">1</span>);</span><br><span class="line">        quickSort2Ways(arr, p + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 p，使得 arr[l...p-1] &lt;= arr[p]，arr[p+1...r] &gt;= arr[p]</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 考虑一个近乎有序的数组，如果只是简单的选择第一个元素作为标定点，那么分出的左右子数组长度就会严重不对等</span></span><br><span class="line">        <span class="comment">// 极端情况，对于一个有序的数组，排序二叉树就会退化成链表，时间复杂度由 logn 退化为 n^n</span></span><br><span class="line">        <span class="comment">// 优化措施就是，随机在 arr[l...r] 的范围中选择一个数值作为标定点</span></span><br><span class="line">        swap(arr, l, (<span class="keyword">int</span>) (Math.random() * (r - l + <span class="number">1</span>)) + l);</span><br><span class="line"></span><br><span class="line">        Comparable v = arr[l];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// arr[l+1...i) &lt;= v; arr(j...r] &gt;= v，注意开区间</span></span><br><span class="line">        <span class="keyword">int</span> i = l + <span class="number">1</span>, j = r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 为什么标定点两边都有等于 v 的元素？为什么 arr[i].compareTo(v) &lt; 0，而不是 &lt;= 0</span></span><br><span class="line">            <span class="comment">// 因为如果对于一个**具有非常多相同元素**的待排序数组来说，如果进行 &lt;= 0 比较，这会导致标定点 p 的左右部分严重失衡</span></span><br><span class="line">            <span class="comment">// 这样做可以让 arr[i].compareTo(v) == 0 的元素**随机**的分布在标定点 p 的左右部分，不至于失衡</span></span><br><span class="line">            <span class="comment">// 比如：待排序数组 [0,1,1,1,1,1,1]，选中 p = 1</span></span><br><span class="line">            <span class="comment">// 那么第一个 while 循环完成后，[l + 1 ... i) 已经包含整个数组了，严重失衡。</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= r &amp;&amp; arr[i].compareTo(v) &lt; <span class="number">0</span>) i++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= l + <span class="number">1</span> &amp;&amp; arr[j].compareTo(v) &gt; <span class="number">0</span>) j--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            swap(arr, i, j);</span><br><span class="line"></span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里要交换 l 和 j 的值，而不是 i 的值</span></span><br><span class="line">        <span class="comment">// 因为，i 存在越界的可能。同理下面返回的也是 j 的值</span></span><br><span class="line">        <span class="comment">// 比如： 待排序数组：[1, 2, 3, 4]。选中 p = 4，那么进行完第一个 while 循环后，i = 4，越界了。</span></span><br><span class="line">        swap(arr, l, j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Object[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Object t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort2Ways</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line"></span><br><span class="line">        quickSort2Ways(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归调用 quickSort2Ways，对 arr[l...r] 的范围进行排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort2Ways</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= l) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p = partition(arr, l, r);</span><br><span class="line"></span><br><span class="line">        quickSort2Ways(arr, l, p - <span class="number">1</span>);</span><br><span class="line">        quickSort2Ways(arr, p + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        swap(arr, l, (<span class="keyword">int</span>) (Math.random() * (r - l + <span class="number">1</span>)) + l);</span><br><span class="line"></span><br><span class="line">        Comparable v = arr[l];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = l + <span class="number">1</span>, j = r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= r &amp;&amp; arr[i].compareTo(v) &lt; <span class="number">0</span>) i++;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= l + <span class="number">1</span> &amp;&amp; arr[j].compareTo(v) &gt; <span class="number">0</span>) j--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            swap(arr, i, j);</span><br><span class="line"></span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(arr, l, j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Object[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Object t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>另外，使用快速排序还可以解决<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">「数组中的第 K 个最大元素」</a>问题。</p><p>第 <code>K</code> 个最大元素，在升序排序的数组中对应的位置是 <code>[len - K]</code>，假设数组长度为 <code>len</code>。</p><p><code>partition</code> 方法的返回值就是：<code>partition</code> 方法中的标定点 <code>p</code> 在当前排序好的数组中的位置。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划之0-1背包问题</title>
      <link href="/posts/4171904134/"/>
      <url>/posts/4171904134/</url>
      
        <content type="html"><![CDATA[<p>最近在学习动态规划（Dynamic programming），其经典问题之一就是 0-1 背包问题。</p><p>题目描述为：有一个背包，其容量为 C（capacity）。现在有 n 种不同的物品，编号为 0…n-1，其中每个物品的重量为 w(i)，价值为 v(i)。问可以向这个背包中放入哪些物品，使得在不超过背包容量的前提下，物品的价值最大。</p><p>函数签名为：<code>int knapsack01(int[] w, int[] v, int C)</code></p><h3 id="下面先说「自顶向下」的记忆化搜索递归解法"><a href="#下面先说「自顶向下」的记忆化搜索递归解法" class="headerlink" title="下面先说「自顶向下」的记忆化搜索递归解法"></a>下面先说「自顶向下」的记忆化搜索递归解法</h3><p>递归解法的函数签名为：<code>int tryBestValue(int[] w, int[] v, int index, int c)</code>。</p><p>对于一个 dp 问题，我们要先明确「状态」和「选择」。<strong>状态</strong>是，「背包的容量」和「可选的物品」。就是递归参数 <code>index</code> 和 <code>c</code>。<strong>选择</strong>是，放入背包，或者不放入背包。</p><p>对于选择可能好理解，一个物品要么放要么不放。对状态的简单理解就是，如果你用递归的方式求解，递归传入的参数就是状态。这里要排除那些不会变的参数，比如 <code>w</code> 和 <code>v</code>，因为每个物品的重量和价值是不变的，其状态是不需要转移的。</p><p>对于背包问题，递归函数可以定义为 <code>F(n, C)</code>，<strong>考虑</strong>将 <code>n</code> 个物品放入放进容量为 <code>C</code> 的背包，使得价值最大。注意用的是<strong>考虑</strong>，说明当前的递归函数的解可能并不是最优解。</p><p>状态转移也好理解。当调用到递归函数时，给递归函数传入的参数是要变的。这一变，状态就转移了，将当前状态转移为下一个状态。</p><p>那么状态转移方程就是：<img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.21/img/postImg/2021-1125-01.jpeg" alt=""></p><p>其实进行到这里，如果不考虑时间、空间消耗的话，已经可以求出最优解了。</p><p>但是该问题是有重叠子问题的，那么我们就要用 <code>memo</code> 来进行记忆化搜索，以排除递归过程中的重复计算。因为状态有两个，<code>index</code> 和 <code>c</code>，所以这里的 <code>memo</code> 应该是一个二维数组，<strong>行</strong>表示背包的容量，<strong>列</strong>表示物品编号。</p><p>完整代码是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = w.length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[n][C + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] m : memo) &#123;</span><br><span class="line">            Arrays.fill(m, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tryBestValue(w, v, n - <span class="number">1</span>, C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 [0...index] 的物品，填充容积为 c 的背包的最大价值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">tryBestValue</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> index, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case，当前背包没容量了，或者背包有容量但是没物品了</span></span><br><span class="line">        <span class="keyword">if</span> (c &lt;= <span class="number">0</span> || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// memo[index][c] 的值被更改过，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(memo[index][c] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[index][c];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// index 不放入背包</span></span><br><span class="line">        <span class="keyword">int</span> res = tryBestValue(w, v, index-<span class="number">1</span>, c);</span><br><span class="line">        <span class="comment">// 在确保背包剩余容量可以容纳物品 index 的情况下，将index 放入背包。</span></span><br><span class="line">        <span class="keyword">if</span>(c &gt;= w[index]) &#123;</span><br><span class="line">            <span class="comment">// 求两种选择的最大值</span></span><br><span class="line">            res = Math.max(res, v[index] + tryBestValue(w, v, index - <span class="number">1</span>, c - w[index]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> memo[index][c] = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="说完「自顶向下」的记忆化搜索解法，接下来再说下「自底向上」的动态规划解法"><a href="#说完「自顶向下」的记忆化搜索解法，接下来再说下「自底向上」的动态规划解法" class="headerlink" title="说完「自顶向下」的记忆化搜索解法，接下来再说下「自底向上」的动态规划解法"></a>说完「自顶向下」的记忆化搜索解法，接下来再说下「自底向上」的动态规划解法</h3><p>动态规划需要有<strong>最基本的情况</strong>，后面的情况可以根据前面的情况来推导。在推导后面的情况时，前面的情况已经是最优解了，不会再变了。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.21/img/postImg/2021-1125-02.jpeg" alt=""></p><blockquote><p>Tip: 建议先画出 dp 数组的结构，并添上一些值。就像上图的 dp 数组。然后根据画出的 dp 数组来推导状态转移方程。不然光用脑袋想太抽象了。</p></blockquote><p>完整代码是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = w.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][C + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 memo。初始情况只考虑物品 0</span></span><br><span class="line">        <span class="comment">// 看只给你物品 0 的情况下，背包的每种容量中可以放入的最大价值是多少</span></span><br><span class="line">        <span class="comment">// 也就是初始化 memo 数组的第一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= C ; j ++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = (j &gt;= w[<span class="number">0</span>] ? v[<span class="number">0</span>] : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= C; j++) &#123;</span><br><span class="line">                <span class="comment">// 物品 i 不放入背包</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= w[i])</span><br><span class="line">                    <span class="comment">// 物品 i 放入背包：v[i] + memo[i - 1][j - w[i]]</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], v[i] + dp[i - <span class="number">1</span>][j - w[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][C];</span><br><span class="line">    &#125;&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>背包问题的变种：</p><p><a href="https://leetcode-cn.com/problems/target-sum/solution/mu-biao-he-by-leetcode-solution-o0cp/">Leetcode 494. 目标和</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) sum += n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> diff = sum - target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (diff &lt; <span class="number">0</span> || diff % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// neg：「加负号的元素」的和</span></span><br><span class="line">    <span class="comment">// 等价于背包总容量就为 neg</span></span><br><span class="line">    <span class="keyword">int</span> neg = diff / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][neg + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = nums[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= neg; j++) &#123;</span><br><span class="line">            <span class="comment">// 不将元素 i-1 放入背包</span></span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= num) &#123;</span><br><span class="line">                <span class="comment">// 将元素 i-1 放入背包</span></span><br><span class="line">                dp[i][j] += dp[i - <span class="number">1</span>][j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n][neg];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关问题：<a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不拘一格</title>
      <link href="/posts/3693869343/"/>
      <url>/posts/3693869343/</url>
      
        <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/35102294/">《不拘一格》</a>虽说是管理者看的书，但是对于个人我觉得也有一定启发性。</p><h3 id="4A-反馈准则"><a href="#4A-反馈准则" class="headerlink" title="4A 反馈准则"></a>4A 反馈准则</h3><blockquote><ol><li>Aim to assist（目的在于帮助）</li><li>Actionable（反馈具有可行性）</li><li>Appreciate（感激与赞赏）</li><li>Accept or discard（接受或拒绝）</li></ol></blockquote><p>在<strong>给别人提建议</strong>或者是<strong>别人给你提建议</strong>时可以应用这个准则。</p><p>给别人提建议，目的一定要是帮助别人，必须是积极的。而不应该是发泄，恶意中伤别人。不要把个人感情加入到反馈中。同时你的反馈也一定要具备可行性，不要提一些不切实际的要求，或者干脆只反馈，但是没有说具体的可行代替方案。</p><p>举个例子。比如，有人在聊天时特别喜欢发「嗯」。<strong>不正确</strong>的反馈是这样的：你能不能不要一直在聊天时发「嗯」，这样让我看着很烦。<strong>正确</strong>的反馈是：建议你不要一直在聊天中使用「嗯」这一个字，这样会给对方一种特别敷衍的感觉。你可以使用「嗯嗯」、「好的」等词汇来代替「嗯」。</p><p>在别人给你提建议时，你要以积极的心态去听，既不辩护，也不生气，还应该满怀欣赏与感激。不要别人一给你指出问题，就认为对方针对你，故意让你丢脸等。自我保护是人类的本能，这一点也确实挺难做到的，但是面子又不能当饭吃。</p><p>对方给你反馈的方式可能不会像 4A 这样让你觉得得劲，但是嘴长在别人身上，你无权干涉别人怎么给你提建议。但是选择权在你手上，你认真思考一下对方的反馈，觉得有没有道理？是不是可以让你进步？如果是的话，那你可以欣然接受该建议，并感谢对方。如果不是那左耳朵进右耳朵出就好了。</p><p>同时你也可以选择将 4A 分享给别人，这样下次别人给你提反馈时可能就会好一些。</p><h3 id="花钱，让网飞利益至上"><a href="#花钱，让网飞利益至上" class="headerlink" title="花钱，让网飞利益至上"></a>花钱，让网飞利益至上</h3><p>只要是对公司有益的花费，不需要层层上报，网飞员工自己就可以决定。当然这里边还有许多具体实施方案，这里不多介绍。</p><p>我想说，如果你觉得你需要一样东西，这件东西<strong>可以为你带来价值</strong>，那买就完了。不要比来比去，看看哪里便宜。</p><p>更应该是，需要的时候就买，买来以后好好使用，让它为你带来更多的价值。</p><p>当然价格要在自己的可接受范围内，而且不要盲目消费。比如为了更舒服的做一名程序猿，花几万块钱买一台 MBP，或者是一台其他的好机器。</p><h3 id="成功了小声说，犯错了大声说"><a href="#成功了小声说，犯错了大声说" class="headerlink" title="成功了小声说，犯错了大声说"></a>成功了小声说，犯错了大声说</h3><p>人人都会犯错，在错误中吸取教训就好了。我们跌倒是为了再次爬起。</p><h3 id="情景管理-OR-控制管理"><a href="#情景管理-OR-控制管理" class="headerlink" title="情景管理 OR 控制管理"></a>情景管理 OR 控制管理</h3><p>情景管理，我们可以指定一个情景，然后让实施者（知情指挥）自己决定该怎么干。</p><p>控制管理，制定严格的工作流程，必须按部就班的进行。</p><p>情景管理适合创新，控制管理适合防止犯错误。</p><p>想象一下场景：假如你有一个 18 岁的儿子，最近他经常出去聚会，但是你不希望他酒驾或者是乘坐酒驾司机的车。此时针对这一问题你有两种解决方法。</p><ol><li>明确告诉他，哪些聚会不可以去，哪些人不可以交往，甚至是监督他在聚会上的一举一动。</li><li>你可以设定情景，并与孩子达成共识。你可以和他聊聊酒驾的危险性，带他看一些酒驾教育片，也可以在家测试一下他的酒量。让他充分知晓酒驾的危害。</li></ol><p>第 1 种是控制管理，第 2 种是情景管理。这两者没有绝对的谁好谁坏。在有的场景下控制管理是要优于情景管理的。比如对安全要求极高的场景，像医院、采矿等。</p><p>而且我觉得情景管理和阿德勒心理学的课题分离也很类似。阿德勒认为一切烦恼都是源于人际关系，所以我们要课题分离，只做自己的课题。你的课题是把你能控制的事做好，比如告诉孩子酒驾的坏处等。而对方做不做以及怎么做，就不是你的课题了。如果妄加干预别人的课题只会徒增烦恼。</p><p>如果你和孩子充分沟通了，并保证孩子已经了解酒驾的危害了。但是聚会时孩子就是玩嗨了，就是酒驾然后出事了，那怎么办？</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乔布斯在斯坦福毕业典礼上的演讲（英文）</title>
      <link href="/posts/3227518935/"/>
      <url>/posts/3227518935/</url>
      
        <content type="html"><![CDATA[<p>New York: I am honored to be with you today at your commencement from one of the finest universities in the world. I never graduated from college. Truth be told, this is the closest I’ve ever gotten to a college graduation. Today I want to tell you three stories from my life. That’s it. No big deal. Just three stories.</p><p><strong>The first story is about connecting the dots.</strong></p><p>I dropped out of Reed College after the first 6 months, but then stayed around as a drop-in for another 18 months or so before I really quit. So why did I drop out?</p><p>It started before I was born. My biological mother was a young, unwed college graduate student, and she decided to put me up for adoption. She felt very strongly that I should be adopted by college graduates, so everything was all set for me to be adopted at birth by a lawyer and his wife. Except that when I popped out they decided at the last minute that they really wanted a girl. So my parents, who were on a waiting list, got a call in the middle of the night asking: “We have an unexpected baby boy; do you want him?” They said: “Of course.” My biological mother later found out that my mother had never graduated from college and that my father had never graduated from high school. She refused to sign the final adoption papers. She only relented a few months later when my parents promised that I would someday go to college.</p><p>And 17 years later I did go to college. But I naively chose a college that was almost as expensive as Stanford, and all of my working-class parents’ savings were being spent on my college tuition. After six months, I couldn’t see the value in it. I had no idea what I wanted to do with my life and no idea how college was going to help me figure it out. And here I was spending all of the money my parents had saved their entire life. So I decided to drop out and trust that it would all work out OK. It was pretty scary at the time, but looking back it was one of the best decisions I ever made. The minute I dropped out I could stop taking the required classes that didn’t interest me, and begin dropping in on the ones that looked interesting.</p><p>It wasn’t all romantic. I didn’t have a dorm room, so I slept on the floor in friends’ rooms, I returned coke bottles for the 5¢ deposits to buy food with, and I would walk the 7 miles across town every Sunday night to get one good meal a week at the Hare Krishna temple. I loved it. And much of what I stumbled into by following my curiosity and intuition turned out to be priceless later on. Let me give you one example:</p><p>Reed College at that time offered perhaps the best calligraphy instruction in the country. Throughout the campus every poster, every label on every drawer, was beautifully hand calligraphed. Because I had dropped out and didn’t have to take the normal classes, I decided to take a calligraphy class to learn how to do this. I learned about serif and san serif typefaces, about varying the amount of space between different letter combinations, about what makes great typography great. It was beautiful, historical, artistically subtle in a way that science can’t capture, and I found it fascinating.</p><p>None of this had even a hope of any practical application in my life. But ten years later, when we were designing the first Macintosh computer, it all came back to me. And we designed it all into the Mac. It was the first computer with beautiful typography. If I had never dropped in on that single course in college, the Mac would have never had multiple typefaces or proportionally spaced fonts. And since Windows just copied the Mac, it’s likely that no personal computer would have them. If I had never dropped out, I would have never dropped in on this calligraphy class, and personal computers might not have the wonderful typography that they do. Of course it was impossible to connect the dots looking forward when I was in college. But it was very, very clear looking backwards ten years later.</p><p>Again, you can’t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future. You have to trust in something - your gut, destiny, life, karma, whatever. This approach has never let me down, and it has made all the difference in my life.</p><p><strong>My second story is about love and loss.</strong></p><p>I was lucky - I found what I loved to do early in life. Woz and I started Apple in my parents garage when I was 20. We worked hard, and in 10 years Apple had grown from just the two of us in a garage into a $2 billion company with over 4000 employees. We had just released our finest creation - the Macintosh - a year earlier, and I had just turned 30. And then I got fired. How can you get fired from a company you started? Well, as Apple grew we hired someone who I thought was very talented to run the company with me, and for the first year or so things went well. But then our visions of the future began to diverge and eventually we had a falling out. When we did, our Board of Directors sided with him. So at 30 I was out. And very publicly out. What had been the focus of my entire adult life was gone, and it was devastating.</p><p>I really didn’t know what to do for a few months. I felt that I had let the previous generation of entrepreneurs down - that I had dropped the baton as it was being passed to me. I met with David Packard and Bob Noyce and tried to apologize for screwing up so badly. I was a very public failure, and I even thought about running away from the valley. But something slowly began to dawn on me - I still loved what I did. The turn of events at Apple had not changed that one bit. I had been rejected, but I was still in love. And so I decided to start over.</p><p>I didn’t see it then, but it turned out that getting fired from Apple was the best thing that could have ever happened to me. The heaviness of being successful was replaced by the lightness of being a beginner again, less sure about everything. It freed me to enter one of the most creative periods of my life.</p><p>During the next five years, I started a company named NeXT, another company named Pixar, and fell in love with an amazing woman who would become my wife. Pixar went on to create the worlds first computer animated feature film, Toy Story, and is now the most successful animation studio in the world. In a remarkable turn of events, Apple bought NeXT, I returned to Apple, and the technology we developed at NeXT is at the heart of Apple’s current renaissance. And Laurene and I have a wonderful family together.</p><p>I’m pretty sure none of this would have happened if I hadn’t been fired from Apple. It was awful tasting medicine, but I guess the patient needed it. Sometimes life hits you in the head with a brick. Don’t lose faith. I’m convinced that the only thing that kept me going was that I loved what I did. You’ve got to find what you love. And that is as true for your work as it is for your lovers. Your work is going to fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work. And the only way to do great work is to love what you do. If you haven’t found it yet, keep looking. Don’t settle. As with all matters of the heart, you’ll know when you find it. And, like any great relationship, it just gets better and better as the years roll on. So keep looking until you find it. Don’t settle.</p><p><strong>My third story is about death.</strong></p><p>When I was 17, I read a quote that went something like: “If you live each day as if it was your last, someday you’ll most certainly be right.” It made an impression on me, and since then, for the past 33 years, I have looked in the mirror every morning and asked myself: “If today were the last day of my life, would I want to do what I am about to do today?” And whenever the answer has been “No” for too many days in a row, I know I need to change something.</p><p>Remembering that I’ll be dead soon is the most important tool I’ve ever encountered to help me make the big choices in life. Because almost everything - all external expectations, all pride, all fear of embarrassment or failure - these things just fall away in the face of death, leaving only what is truly important. Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose. You are already naked. There is no reason not to follow your heart.</p><p>About a year ago I was diagnosed with cancer. I had a scan at 7:30 in the morning, and it clearly showed a tumor on my pancreas. I didn’t even know what a pancreas was. The doctors told me this was almost certainly a type of cancer that is incurable, and that I should expect to live no longer than three to six months. My doctor advised me to go home and get my affairs in order, which is doctor’s code for prepare to die. It means to try to tell your kids everything you thought you’d have the next 10 years to tell them in just a few months. It means to make sure everything is buttoned up so that it will be as easy as possible for your family. It means to say your goodbyes.</p><p>I lived with that diagnosis all day. Later that evening I had a biopsy, where they stuck an endoscope down my throat, through my stomach and into my intestines, put a needle into my pancreas and got a few cells from the tumor. I was sedated, but my wife, who was there, told me that when they viewed the cells under a microscope the doctors started crying because it turned out to be a very rare form of pancreatic cancer that is curable with surgery. I had the surgery and I’m fine now.</p><p>This was the closest I’ve been to facing death, and I hope it’s the closest I get for a few more decades. Having lived through it, I can now say this to you with a bit more certainty than when death was a useful but purely intellectual concept:</p><p>No one wants to die. Even people who want to go to heaven don’t want to die to get there. And yet death is the destination we all share. No one has ever escaped it. And that is as it should be, because Death is very likely the single best invention of Life. It is Life’s change agent. It clears out the old to make way for the new. Right now the new is you, but someday not too long from now, you will gradually become the old and be cleared away. Sorry to be so dramatic, but it is quite true.</p><p>Your time is limited, so don’t waste it living someone else’s life. Don’t be trapped by dogma - which is living with the results of other people’s thinking. Don’t let the noise of others’ opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary.</p><p>When I was young, there was an amazing publication called The Whole Earth Catalog, which was one of the bibles of my generation. It was created by a fellow named Stewart Brand not far from here in Menlo Park, and he brought it to life with his poetic touch. This was in the late 1960’s, before personal computers and desktop publishing, so it was all made with typewriters, scissors, and polaroid cameras. It was sort of like Google in paperback form, 35 years before Google came along: it was idealistic, and overflowing with neat tools and great notions.</p><p>Stewart and his team put out several issues of The Whole Earth Catalog, and then when it had run its course, they put out a final issue. It was the mid-1970s, and I was your age. On the back cover of their final issue was a photograph of an early morning country road, the kind you might find yourself hitchhiking on if you were so adventurous. Beneath it were the words: “Stay Hungry. Stay Foolish.” It was their farewell message as they signed off. Stay Hungry. Stay Foolish. And I have always wished that for myself. And now, as you graduate to begin anew, I wish that for you.</p><p>Stay Hungry. Stay Foolish.</p><p>Thank you all very much.</p><blockquote><p><a href="https://www.youtube.com/watch?v=UF8uR6Z6KLc&amp;t=66s">Steve Jobs’ 2005 Stanford Commencement Address</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 文章分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>纸书和电子书</title>
      <link href="/posts/4000706218/"/>
      <url>/posts/4000706218/</url>
      
        <content type="html"><![CDATA[<p>书的材质大致可以分为：纸质、手机平板 OLED\LED 屏、Kindle 墨水屏。</p><p>纸质书的优点：</p><ol><li>物理翻页（我自创的词），两页甚至更多页的内容可以同时对照着看。而电子书只可以同时看一屏（页）的内容。</li><li>拿在手里感觉踏实。</li><li>没有其他消息干扰。</li></ol><p>手机平板 OLED\LED 屏电子书的优点：</p><ol><li>携带方便，现在人们出门最不可能忘记带的就是手机了吧，带了手机就相当于带了书。</li><li>搜索方便，比如忘记了某个人的身份，可以直接搜索。</li><li>容量大，还联网。如果没有限制的话，一部手机可以看到整个世界的书。</li><li>支持划词搜索，遇到不认识的汉字、不认识的单词，都可以方便的划词搜索。</li></ol><p>Kindle 墨水屏的优点：</p><ol><li>接近纸书的视觉感受，护眼。</li><li>可以直接在 Amazon 买书，可以看的资源更丰富一些。</li><li>没有其他消息干扰。</li></ol><p>我买过 Kindle PW4，后来又出掉了，感觉不是很实用。Kindle 的这几个优点对于我来说相当于没有。现在大部分时间都在看手机电子书，但是眼睛也没有感觉不适，反而是有时候看纸书看多了，会觉得眼睛有点迷。其他的功能（搜索、携带、流畅度等）对比手机看书也都要差一些，所以出出掉了。</p><p>用手机看书，我一般看的都是非专业类的书，这种书不需要你做特别复杂的笔记，而且大概率只看一遍。不过手机看书会有其他消息干扰，这就要考验你的抗干扰能力了。</p><p>纸书的话，专业类的一定会看纸书，因为要认真的做笔记，你可能会说用 iPad+Pencil 不一样可以做笔记么，为什么要选择纸书。其中一个很大的原因就是纸书可以<strong>物理翻页</strong>，前后对照不受限制。另外如果是电子书没有资源，我也会买纸书或去图书馆借纸书来看。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《谷粒商城》项目错误合集macOS</title>
      <link href="/posts/264117559/"/>
      <url>/posts/264117559/</url>
      
        <content type="html"><![CDATA[<blockquote><p>系统环境：</p><p>macOS 版本 Big Sur 11.4</p><p>Intellig IDEA 版本 2021.1</p><p>DataGrip 版本 2021.1.3</p><p>Parallels Desktop 版本 16.1.2 (49151)</p><p>CentOS 版本 7</p><p>Docker 版本 20.10.7</p><p>MySql 版本 5.7</p><p>Spring Boot 版本 2.5.1</p><p>Spring Cloud 版本 2020.0.3</p><p>Spring Cloud Alibaba 版本 2.2.5.RELEASE</p><p>Nacos 版本 2.0.2</p></blockquote><hr><h4 id="项目地址：GitHub-gulimall-IamXGW"><a href="#项目地址：GitHub-gulimall-IamXGW" class="headerlink" title="项目地址：GitHub gulimall-IamXGW"></a>项目地址：<a href="https://github.com/IamXGW/gulimall-IamXGW">GitHub gulimall-IamXGW</a></h4><hr><h4 id="DataGrip-错误：java-io-EOFException-Can-not-read-response-from-server-Expected-to-read-4-bytes-read-0-bytes-before-connection-was-unexpectedly-lost"><a href="#DataGrip-错误：java-io-EOFException-Can-not-read-response-from-server-Expected-to-read-4-bytes-read-0-bytes-before-connection-was-unexpectedly-lost" class="headerlink" title="DataGrip 错误：java.io.EOFException: Can not read response from server. Expected to read 4 bytes, read 0 bytes before connection was unexpectedly lost"></a>DataGrip 错误：java.io.EOFException: Can not read response from server. Expected to read 4 bytes, read 0 bytes before connection was unexpectedly lost</h4><p><strong>分析：</strong></p><p>发生这个错误的时候都是在我重开电脑以后，所以我就想重启一下虚拟机。</p><p><strong>解决方法：</strong></p><p>在虚拟机终端输入 <code>reboot</code> 命令重启虚拟机，然后在 Docker 中打开 MySql 即可。</p><p><code>sudo docker update redis --restart=always</code> 这个命令是设置 MySql 开机自启。</p><p>另外，如果数据库平时能连上，但是突然不知道咋回事就连不上了。如果遇见这种情况，请检查一下你的梯子是不是开的全局连接，如果是的话，请换掉。</p><hr><h4 id="Mac-使用-nacos-启动不起来"><a href="#Mac-使用-nacos-启动不起来" class="headerlink" title="Mac 使用 nacos 启动不起来"></a>Mac 使用 nacos 启动不起来</h4><p><strong>解决方法：</strong></p><p><a href="https://blog.csdn.net/onlyMilky/article/details/114532108">Mac 启动 nacos 失败 日志报“nohup: /Library/Internet: No such file or directory”</a></p><hr><h4 id="Failed-to-parse-configuration-class"><a href="#Failed-to-parse-configuration-class" class="headerlink" title="Failed to parse configuration class"></a>Failed to parse configuration class</h4><p>运行时报如下错误：</p><p><code>org.springframework.beans.factory.BeanDefinitionStoreException: Failed to parse configuration class [com.iamxgw.gulimall.coupon.GulimallCouponApplication]; nested exception is java.io.FileNotFoundException: class path resource [com/iamxgw/gulimall/coupon/service/HomeAdvService.class] cannot be opened because it does not exist</code></p><p><strong>分析：</strong></p><p>提示 <code>HomeAdvService.class</code> 文件找不到。 <code>*.class</code> 文件应该是编译时产生的，所以直接删掉以前的 <code>*.class</code> 重新编译即可。</p><p><strong>解决方法：</strong></p><p>将 <code>coupon</code> 的 <code>target</code> 文件夹删除，重新运生成即可。</p><p><strong>遗留问题：</strong></p><p>为什么不删除 <code>target</code>  文件夹，直接运行项目不会生成缺失的 <code>HomeAdvService.class</code> 文件呢？</p><hr><h4 id="Did-you-forget-to-include-spring-cloud-starter-loadbalancer"><a href="#Did-you-forget-to-include-spring-cloud-starter-loadbalancer" class="headerlink" title="Did you forget to include spring-cloud-starter-loadbalancer?"></a>Did you forget to include spring-cloud-starter-loadbalancer?</h4><p><strong>分析：</strong></p><p>你忘记 include spring-cloud-starter-loadbalancer 了么？</p><p>那就 include 进去。</p><p><strong>解决方法：</strong></p><p>在 common 的 pom.xml 中，加入依赖：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;exclusion&gt;</span><br><span class="line">    &lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-loadbalancer&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="使用-Nacos-时，bootstrap-properties-配置文件无效"><a href="#使用-Nacos-时，bootstrap-properties-配置文件无效" class="headerlink" title="使用 Nacos 时，bootstrap.properties 配置文件无效"></a>使用 Nacos 时，<code>bootstrap.properties</code> 配置文件无效</h4><p><strong>分析：</strong></p><p>一开始在 <code>application.propertie</code> 中设置 <code>name</code> 和 <code>age</code>，是可以正常访问到的。</p><p>但是使用 Nacos 作为配置中心却无法获取到配置中心的 <code>name</code> 和 <code>age</code>，而且控制台也没有同老师一样打印 <code>located proper source</code>，所以我怀疑是 <code>bootstrap.properties</code> 这个配置文件没起作用。</p><p><strong>解决方法：</strong></p><p>在 common 的 pom.xml 中加入依赖：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.0.3&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="Parameter-1-of-constructor-in-com-baomidou-mybatisplus-autoconfigure-IdentifierGeneratorAutoConfiguration-InetUtilsAutoConfig-required-a-bean-of-type-‘com-baomidou-mybatisplus-autoconfigure……"><a href="#Parameter-1-of-constructor-in-com-baomidou-mybatisplus-autoconfigure-IdentifierGeneratorAutoConfiguration-InetUtilsAutoConfig-required-a-bean-of-type-‘com-baomidou-mybatisplus-autoconfigure……" class="headerlink" title="Parameter 1 of constructor in com.baomidou.mybatisplus.autoconfigure.IdentifierGeneratorAutoConfiguration$InetUtilsAutoConfig required a bean of type ‘com.baomidou.mybatisplus.autoconfigure…….."></a>Parameter 1 of constructor in com.baomidou.mybatisplus.autoconfigure.IdentifierGeneratorAutoConfiguration$InetUtilsAutoConfig required a bean of type ‘com.baomidou.mybatisplus.autoconfigure……..</h4><p><strong>解决方法：</strong></p><p>如果跟老师一样，在 Java 文件中加注解 <code>@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</code> 是报错的。于是修改 gateway 的 pom.xml 文件，来排除不需要的依赖：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.iamxgw.gulimall&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;gulimall-common&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;exclusion&gt;</span><br><span class="line">    &lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>注意这个 <code>&lt;exclusions&gt;</code> 是新加入的。</p><hr><h4 id="java-You-aren’t-using-a-compiler-supported-by-lombok-so-lombok-will-not-work-and-has-been-disabled"><a href="#java-You-aren’t-using-a-compiler-supported-by-lombok-so-lombok-will-not-work-and-has-been-disabled" class="headerlink" title="java: You aren’t using a compiler supported by lombok, so lombok will not work and has been disabled"></a>java: You aren’t using a compiler supported by lombok, so lombok will not work and has been disabled</h4><p><strong>解决方法：</strong></p><p>这个问题是 Lombok 版本的问题。在 renren-fast 的 pom.xml 中修改 Lombok 版本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.18.16&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>如果不知道这个 Lombok 版本在哪里修改，可以使用全局搜索 Lombok。</p><p><a href="https://stackoverflow.com/questions/65128763/java-you-arent-using-a-compiler-supported-by-lombok-so-lombok-will-not-work-a">参考连接</a></p><hr><h4 id="网关-Gateway-配置-filters-重写路径-RewritePath-出问题"><a href="#网关-Gateway-配置-filters-重写路径-RewritePath-出问题" class="headerlink" title="网关 Gateway 配置 filters 重写路径 RewritePath 出问题"></a>网关 Gateway 配置 <code>filters</code> 重写路径 <code>RewritePath</code> 出问题</h4><p><strong>解决方法：</strong></p><p>一定要根据 Gateway 的版本来查看对应的官方文档，然后按照官方文档做修改。</p><p>我是 <code>3.0.3</code> 版本的 Gateway RewritePath（而且 <code>renren-fast</code> 前面也要加个 <code>/</code>）：</p><p><code>- RewritePath=/api/?(?&lt;segment&gt;.*), /renren-fast/$\&#123;segment&#125;</code></p><p>PS：其实不一定非要和老师的版本严格一致，你可以使用其他的版本。但重要的是，你要能自己分析出发生问题的原因是，然后逐个击破。我认为这才是真正学到了东西。</p>]]></content>
      
      
      <categories>
          
          <category> 谷粒商城 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 错误合集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC常用命令总结</title>
      <link href="/posts/152748040/"/>
      <url>/posts/152748040/</url>
      
        <content type="html"><![CDATA[<h2 id="GCC-简介"><a href="#GCC-简介" class="headerlink" title="GCC 简介"></a>GCC 简介</h2><p>要了解 GCC 我觉得有必要先了解一下 GNU 项目。GNU（GNU 是 GNU`s Not Unix 的缩写） 项目是 1984 年由 Richard Stallman 发起的一个免税的慈善项目。该项目的目标非常宏大，就是开发一个完整的类 Unix 的系统，其源码能够不受限制的被修改和传播。GNU 项目已经开发出了一个包含 Unix 系统的所有主要部件的环境，但内核除外，内核是由 Linux 项目独立发展而来的。GNU 环境包括 EMACS 编辑器、<em>GCC 编译器</em>、GDB 调试器、汇编器、连接器、处理二进制文件的工具以及其他一些部件。</p><p>GCC 一开始叫做 GNU C Compiler。后来经过不断的发展，不仅仅是支持 C，而且还支持 C++、Objective-C、Ada 和 Go 等多种语言。因此后来 GCC 也就变成了 GNU Compiler Collection 的缩写。<a href="https://gcc.gnu.org">GCC 官网</a>。</p><h2 id="GCC-使用格式及可选项"><a href="#GCC-使用格式及可选项" class="headerlink" title="GCC 使用格式及可选项"></a>GCC 使用格式及可选项</h2><p>gcc 的使用格式为：<code>gcc [选项][文件名][选项][文件名]</code></p><p>选项可以分为以下几大类：</p><p><strong>（1）总体选项，用于控制编译的整个流程。</strong></p><p><code>-c</code> 对源文件进行编译或者汇编。</p><p><code>-E</code> 对源文件进行预处理。</p><p><code>-S</code> 对原文件进行编译。</p><p><code>-o file</code> 输出目标文件 file。</p><p><code>-v</code> 显示编译阶段的命令。</p><p><strong>（2）语言选项，用来支持各个版本的C语言程序。</strong></p><p><code>-ansi</code> 支持符合 ANSI 标准的 C 语言。</p><p><strong>（3）警告选择，用于控编译过程中出现的警告信息。常用的选项。</strong></p><p><code>-W</code> 屏蔽所有的警警告信息。</p><p><code>-wall</code> 显示所有类型的警告信息。</p><p><code>-Werror</code> 出现任何警告信息就停止编译。</p><p><strong>（4）调试选项，用于控制调试信息。</strong></p><p><code>-g</code> 产生调试信息。</p><p><strong>（5）优化选项，对于对目标文件进行优化。</strong></p><p><code>-O1</code> 对目标文件的性能进行优化。</p><p><code>-O2</code> 进一步优化，提高目标文件的运行性能。</p><p><code>-O3</code> 进一步优化，支持函数集成优化。</p><p><code>-OO</code> 不进行优化。</p><p><strong>（6）连接器选项，用于控制链接过程。</strong></p><p><code>-static</code> 使用静态链接。</p><p><code>-llibrary</code> 链接 library 函数库文件。</p><p><code>-L dir</code> 置顶连接器的搜索目录 dir。</p><p><code>-shared</code> 生成共享文件。</p><p><strong>（7）目录选项，用于指定编译器的文件搜索目录。</strong></p><p><code>-Idir</code> 指定头文件的搜索目录 dir。</p><p><code>-Ldir</code> 指定搜索目目录 dir。</p><h2 id="GCC-简单编译"><a href="#GCC-简单编译" class="headerlink" title="GCC 简单编译"></a>GCC 简单编译</h2><p>假设有示例程序如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用GCC编译程序的时候，编译过程分为四个阶段:</p><p><strong>预处理 （Pre-Processing）。</strong>该阶段预处理器（cpp）根据以字符 <code>#</code> 开头的命令，修改原始的 C 程序。比如，test.c 文件中第一行 <code>#include &lt;stdio.h&gt;</code> 命令告诉预处理器读取系统头文件 <code>stdio.h</code> 的内容，并把其直接插入程序文本中。结果就会得到另一个 C 程序，通常以 <code>.i</code> 作为文件扩展名。</p><p><strong>编译 （Compiling）。</strong>编译器（ccl）将文本文件 test.i 翻译成文本文件 test.s，它包含一个<em>汇编语言程序</em>。</p><p><strong>汇编 （Assembling）。</strong>汇编器（as）将 test.s 翻译成机器语言指令，把这些指令打包成一种叫做<em>可重定位目标程序</em>的格式，并把结果保存在目标文件 test.o 中，test.o 是一个二进制文件，如果直接打开看的话是乱码。</p><p><strong>链接 （Linking）。</strong><code>printf</code> 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 test.o 程序中。连接器（ld）负责处理这些合并，得到 test 文件，它是一个<em>可执行目标文件</em>，可以被加载到内存中，由系统执行。</p><h4 id="一步到位编译指令"><a href="#一步到位编译指令" class="headerlink" title="一步到位编译指令"></a>一步到位编译指令</h4><p><code>gcc test.c -o test</code></p><p>这条命令直接把上述四个步骤一次性执行完了。产生文件 test。</p><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p><code>gcc -E test.c</code></p><p>如果直接在命令行执行这条指令，则将结果直接打印在终端界面。如果想把预处理结果保存在文件中，可以使用下面这条指令：</p><p><code>gcc -E test.c -o test.i</code></p><p>这条指令会将预处理结果存放在文件 test.i 中。</p><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>可以对预处理后的文件 test.i 进行编译处理，产生汇编代码。</p><p><code>gcc -S test.i -o test.s</code></p><p>打开 test.s 文件，其内容是 test.i  的汇编代码。</p><p>执行优化：</p><p><code>gcc -O1 -S test.i -o test.s</code>。</p><h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><p><code>gcc -c test.s -o test.o</code></p><p>将编译产生的汇编代码翻译成机器指令。</p><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p><code>gcc test.o -o test</code></p><p>如果你一步一步的执行了上述四条指令，那么现在你可以在终端执行 <code>./test</code>，会打印出来 <code>Hello World!</code> 。</p><h2 id="编译多个程序文件"><a href="#编译多个程序文件" class="headerlink" title="编译多个程序文件"></a>编译多个程序文件</h2><p>如果你的项目包括多个 C 源文件，比如有两个源文件 test1.c 和 test2.c，那么可以用下面的命令来对它们进行编译：</p><p><code>gcc test1.c test2.c -o test</code></p><p>这条指令实际上是分如下三步来执行的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -c test1.c -o test1.o</span><br><span class="line">gcc -c test2.c -o test2.o</span><br><span class="line">gcc test1.o test2.o -o test</span><br></pre></td></tr></table></figure><h2 id="检错"><a href="#检错" class="headerlink" title="检错"></a>检错</h2><p><code>gcc -pedantic illcode.c -o illcode</code></p><p><code>-pedantic</code> 编译选项并不能保证被编译程序与 ANSI/ISO C 标准的完全兼容，它仅仅只能用来帮助 Linux 程序员离这个目标越来越近。或者换句话说，<code>-pedantic</code> 选项能够帮助程序员发现一些不符合 ANSI/ISO C 标准的代码，但不是全部，事实上只有 ANSI/ISO C 语言标准中要求进行编译器诊断的那些情况，才有可能被 GCC 发现并提出警告。</p><p>除了 <code>-pedantic</code> 之外，GCC 还有一些其它编译选项也能够产生有用的警告信息。这些选项大多以 <code>-W</code> 开头，其中最有价值的当数 <code>-Wall</code> 了，使用它能够使 GCC 产生尽可能多的警告信息。</p><p><code>gcc -Wall illcode.c -o illcode</code></p><p>GCC 给出的警告信息虽然从严格意义上说不能算作错误，但却很可能成为错误的栖身之所。一个优秀的 Linux 程序员应该尽量避免产生警告信息，使自己的代码始终保持标准、健壮的特性。所以将警告信息当成编码错误来对待，是一种值得赞扬的行为！所以，在编译程序时带上 <code>-Werror</code> 选项，那么 GCC 会在所有产生警告的地方停止编译，迫使程序员对自己的代码进行修改，如下：</p><p><code>gcc -Werror test.c -o test</code></p><h2 id="库文件连接"><a href="#库文件连接" class="headerlink" title="库文件连接"></a>库文件连接</h2><p>开发软件时，完全不使用第三方函数库的情况是比较少见的，通常来讲都需要借助许多函数库的支持才能够完成相应的功能。从程序员的角度看，函数库实际上就是一些头文件（.h）和库文件（so、或 lib、dll）的集合。虽然 Linux 下的大多数函数都默认将头文件放到 <code>/usr/include/</code> 目录下，而库文件则放到 <code>/usr/lib/</code> 目录下；Windows 所使用的库文件主要放在 Visual Stido 的目录下的 include 和 lib，以及系统文件夹下。但也有的时候，我们要用的库不再这些目录下，所以 GCC 在编译时必须用自己的办法来查找所需要的头文件和库文件。</p><p>例如我们的程序 test.c 是在 Linux 上使用 C 连接 MySQL，这个时候我们需要去 MySQL 官网下载MySQL Connectors 的 C 库，下载下来解压之后，有一个 include 文件夹，里面包含 mysql connectors 的头文件，还有一个 lib 文件夹，里面包含二进制 so 文件 libmysqlclient.so。</p><p>其中 inclulde 文件夹的路径是 <code>/usr/dev/mysql/include</code>，lib 文件夹是 <code>/usr/dev/mysql/lib</code>。</p><h4 id="编译成可执行文件"><a href="#编译成可执行文件" class="headerlink" title="编译成可执行文件"></a>编译成可执行文件</h4><p>首先我们要进行编译 test.c 为目标文件，这个时候需要执行：</p><p><code>gcc –c –I /usr/dev/mysql/include test.c –o test.o</code></p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>最后我们把所有目标文件链接成可执行文件：</p><p><code>gcc –L /usr/dev/mysql/lib –lmysqlclient test.o –o test</code></p><p>Linux 下的库文件分为两大类分别是动态链接库（通常以 .so 结尾）和静态链接库（通常以 .a 结尾），二者的区别仅在于程序执行时所需的代码是在运行时动态加载的，还是在编译时静态加载的。</p><h4 id="强制链接时使用静态链接库"><a href="#强制链接时使用静态链接库" class="headerlink" title="强制链接时使用静态链接库"></a>强制链接时使用静态链接库</h4><p>默认情况下， GCC 在链接时优先使用动态链接库，只有当动态链接库不存在时才考虑使用静态链接库，如果需要的话可以在编译时加上 -static 选项，强制使用静态链接库。</p><p>在 <code>/usr/dev/mysql/lib</code> 目录下有链接时所需要的库文件 libmysqlclient.so 和 libmysqlclient.a，为了让GCC 在链接时只用到静态链接库，可以使用下面的命令：</p><p><code>gcc –L /usr/dev/mysql/lib –static –lmysqlclient test.o –o test</code></p><h4 id="静态库链接时搜索路径顺序"><a href="#静态库链接时搜索路径顺序" class="headerlink" title="静态库链接时搜索路径顺序"></a>静态库链接时搜索路径顺序</h4><ol><li>ld 会去找 GCC 命令中的参数 <code>-L</code>。</li><li>再找 GCC 的环境变量 LIBRARY_PATH。</li><li>再找内定目录 <code>/lib /usr/lib /usr/local/lib</code> 这是当初 compile gcc 时写在程序内的。</li></ol><p>动态链接时、执行时搜索路径顺序:</p><ol><li>编译目标代码时指定的动态库搜索路径。</li><li>环境变量 LD_LIBRARY_PATH 指定的动态库搜索路径。</li><li>配置文件 /etc/ld.so.conf 中指定的动态库搜索路径。</li><li>默认的动态库搜索路径 <code>/lib</code>。</li><li>默认的动态库搜索路径 <code>/usr/lib</code>。</li></ol><p>有关环境变量：</p><p>LIBRARY_PATH 环境变量：指定程序静态链接库文件搜索路径。</p><p>LD_LIBRARY_PATH 环境变量：指定程序动态链接库文件搜索路径。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/ggjucheng/archive/2011/12/14/2287738.html">Linux GCC常用命令</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux/Unix </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解计算机系统_3e_第三章家庭作业答案</title>
      <link href="/posts/1561383893/"/>
      <url>/posts/1561383893/</url>
      
        <content type="html"><![CDATA[<h2 id="3-58"><a href="#3-58" class="headerlink" title="3.58"></a>3.58</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">decode2</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y, <span class="keyword">long</span> z)</span> </span>&#123;</span><br><span class="line">    y -= z;</span><br><span class="line">    x *= y;</span><br><span class="line">    <span class="keyword">long</span> ret = y;</span><br><span class="line">    ret &lt;&lt;= <span class="number">63</span>;</span><br><span class="line">    ret &gt;&gt;= <span class="number">63</span>;</span><br><span class="line">    ret ^= x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-59"><a href="#3-59" class="headerlink" title="3.59"></a>3.59</h2><p>参考本书的 2.3.4 和 2.3.5，其中有两条定理：</p><ol><li>w 位无符号乘法，其结果可能要用 2w 位来表示。但是在 C 语言中 w 位无符号乘法被定义为产生 w 位的值，就是 2w 位的整数乘积的低 w 位表示的值。将一个无符号数截断为 w 位等价于计算模 $2^w$。（这条定理同样适用于补码乘法）。</li><li>对于无符号数和补码乘法来说，乘法运算的位级表示都是一样的。</li></ol><p>现在让我们看这道题目。</p><p>将一个 64 位的补码转换为 128 位的补码数，可以通过以下公式实现：$x=2^{64} \cdot x_h + x_l$，其中 $x_h$ 和 $x_l$ 都是 64 位值。</p><p>那么如果计算两个 64 位有符号值 x 和 y 的 128 位乘积，就可以这样表示：$x \cdot y=(2^{64} \cdot x_h + x_l) \cdot (2^{64} \cdot y_h + y_l)=2^{128} \cdot x_h \cdot y_l+2^{64} \cdot x_h \cdot y_l+2^{64} \cdot x_l \cdot y_h + x_l \cdot y_l$。</p><p>将以上公式套用该题的寄存器，得到如下结果（dest：%rdi，x：%rsi，y：%rdx）：$x \cdot y = rdx \cdot rcx \cdot 2^{128} + rdx \cdot rsi \cdot 2^{64} + rcx \cdot rax \cdot 2^{64} + rax \cdot rsi$。</p><p>现在得到的结果是 2w=256 位的。要得到 128 位的话，就需要对结果 mod128，得到：$rdx \cdot rsi*2^{64} mod 2^{128}+rcx \cdot rax \cdot 2^{64} mod 2^{128}+rax \cdot rsi$。其中 $rdx \cdot rcx \cdot 2^{128}$ 这项为什么没有了？是因为 $\cdot 2^{128}$ 就是左移 128 位，所以已经超出题目要求的 128 位了。</p><p>画了个图：</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.17/img/20210516.jpeg" alt=""></p><p>到这原理基本上讲完了，下面看具体的代码。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">store_prod</span><br><span class="line">movq%rdx, %rax# 将 y 拷贝一份放到 %rdx 中。</span><br><span class="line">cqto# 将 %rax 的符号位复制到 %rdx 的每一位中。即将 y 的符号位扩展到 %rdx 中。现在的 y 已经扩展到 <span class="number">128</span> 位了，y 变为 %rdx:%rax（%rdx 表示高 <span class="number">64</span> 位，%rax 表示低 <span class="number">64</span> 位），即 y = rdx*<span class="number">2</span>^<span class="number">64</span> + rax。</span><br><span class="line">movq%rsi, %rcx# 将 x 拷贝到 %rcx 中。</span><br><span class="line">sarq$<span class="number">63</span>, %rcx# 将 %rcx 的每一位扩展成 x 的符号位。作用同上面的 y。此时 x = rcx*<span class="number">2</span>^<span class="number">64</span> + rsi。</span><br><span class="line"># 对于 rdx*rsi*<span class="number">2</span>^<span class="number">64</span>mod2^<span class="number">128</span> 这样的计算。因为寄存器都是 <span class="number">64</span> 位的，所以我们只需对两个数进行 imulq 计算，然后将结果截取低 <span class="number">64</span> 位，并将其加到 rax*rsi 的高<span class="number">64</span>位（因为这里有 *<span class="number">2</span>^<span class="number">64</span>，即左移 <span class="number">64</span> 位，所以就是加到高 <span class="number">64</span> 位）。</span><br><span class="line">imulq%rax, %rcx# 计算 rcx*rax</span><br><span class="line">imulq%rsi, %rdx# 计算 rdx*rsi</span><br><span class="line">addq%rdx, %rcx# 计算 rcx*rax + rdx*rsi 并将结果放在最终结果的高 <span class="number">64</span> 位（体现 * <span class="number">2</span>^<span class="number">64</span>）。</span><br><span class="line">mulq%rsi<span class="meta"># x 全乘 y 即 rax*rsi，结果放在 %rdx:%rax（共 128 位）。</span></span><br><span class="line">addq%rcx, %rdx# 计算 rcx*rax + rdx*rsi + rdx，作为高 <span class="number">64</span> 位。</span><br><span class="line">movq%rax, (%rdi)      # 存储低<span class="number">64</span>位。</span><br><span class="line">movq%rdx, <span class="number">8</span>(%rdi)# 存储高<span class="number">64</span>位。</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><hr><h2 id="3-60"><a href="#3-60" class="headerlink" title="3.60"></a>3.60</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x: %rdi</span><br><span class="line"></span><br><span class="line">n: %esi</span><br><span class="line"></span><br><span class="line">result: %rax</span><br><span class="line"></span><br><span class="line">mask: %rdx</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">loop</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> mask;</span><br><span class="line">    <span class="keyword">for</span> (max = <span class="number">1</span>; mask != <span class="number">0</span>; mask = mask &lt;&lt; n) &#123;</span><br><span class="line">        result |= (x &amp; mask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-61"><a href="#3-61" class="headerlink" title="3.61"></a>3.61</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">cread_alt</span><span class="params">(<span class="keyword">long</span> *xp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (xp != <span class="number">0</span>) &#123;</span><br><span class="line">        res = *xp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-62"><a href="#3-62" class="headerlink" title="3.62"></a>3.62</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>MODE_A, MODE_B, MODE_C, MODE_D, MODE_E&#125; <span class="keyword">modee_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">switch3</span><span class="params">(<span class="keyword">long</span> *p1, <span class="keyword">long</span> *p2, <span class="keyword">modee_t</span> action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">        <span class="keyword">case</span> MODE_A:</span><br><span class="line">            result = *p2;</span><br><span class="line">            *p2 = *p1;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MODE_B:</span><br><span class="line">            result = *p1 + *p2;</span><br><span class="line">            *p1 = result;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MODE_C:</span><br><span class="line">            *p1 = <span class="number">59</span>;</span><br><span class="line">            result = *p2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//        case MODE_D:</span></span><br><span class="line"><span class="comment">//            *p1 = *p2;</span></span><br><span class="line"><span class="comment">//            result = 27;</span></span><br><span class="line"><span class="comment">//            break;</span></span><br><span class="line"><span class="comment">//        case MODE_E:</span></span><br><span class="line"><span class="comment">//            result = 27;</span></span><br><span class="line"><span class="comment">//            break;</span></span><br><span class="line">            <span class="comment">// MODE_D 和 MODE_E 换成下面这种是不是更好？</span></span><br><span class="line">        <span class="keyword">case</span> MODE_D:</span><br><span class="line">              *p1 = *p2;</span><br><span class="line">        <span class="keyword">case</span> MODE_E:</span><br><span class="line">          result = <span class="number">27</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = <span class="number">12</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-63"><a href="#3-63" class="headerlink" title="3.63"></a>3.63</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">switch_prob</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> result = x;</span><br><span class="line"><span class="keyword">switch</span>(n) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">60</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">62</span>:</span><br><span class="line">result *= <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">63</span>:</span><br><span class="line">    result &gt;&gt;= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">64</span>:</span><br><span class="line">    result = (result &lt;&lt; <span class="number">4</span>) - x;</span><br><span class="line"><span class="keyword">case</span> <span class="number">65</span>:</span><br><span class="line">    result *= result;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    result += <span class="number">0x4b</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加餐：(gdb) x/6gx 0x4006F8 指令是什么？</strong></p><p>可以使用 examine 命令（简写是 x）来查看内存地址中的值。x 命令的语法如下所示：<code>x/&lt;n/f/u&gt; &lt;addr&gt;</code>。n、f、u 是可选的参数。</p><p>n：是一个正整数，表示需要显示的内存单元的个数，也就是说从当前地址向后显示几个内存单元的内容，一个内存单元的大小由后面的 u 定义。</p><p>f：表示显示的格式，参见下面。如果地址所指的是字符串，那么格式可以是 s，如果地十是指令地址，那么格式可以是 i。</p><p>u：表示从当前地址往后请求的字节数，如果不指定的话，GDB 默认是 4 个 bytes。u 参数可以用下面的字符来代替，b 表示单字节，h 表示双字节，w 表示四字节，g 表示八字节。当我们指定了字节长度后，GDB 会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。</p><p><addr> 表示一个内存地址。</p><p>输出格式：</p><p>一般来说，GDB 会根据变量的类型输出变量的值。但你也可以自定义 GDB 的输出的格式。例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量的中的位的情况。要做到这样，你可以使用GDB 的数据显示格式：</p><p>x 按十六进制格式显示变量。</p><p>d 按十进制格式显示变量。</p><p>u 按十六进制格式显示无符号整型。</p><p>o 按八进制格式显示变量。</p><p>t 按二进制格式显示变量。</p><p>a 按十六进制格式显示变量。</p><p>c 按字符格式显示变量。</p><p>f 按浮点数格式显示变量。</p><p><code>x/6gx 0x4006F8</code> 这条指令就是从地址 0x4006F8 开始，往后读取 6 个，每个 8 字节字的内存。</p><hr><h2 id="3-64"><a href="#3-64" class="headerlink" title="3.64"></a>3.64</h2><hr><h2 id="3-65"><a href="#3-65" class="headerlink" title="3.65"></a>3.65</h2><p>A：%rdx。</p><p>B：%rax。</p><p>C：M=15。</p><p>解释：</p><p>由汇编代码可以看到，rdx 每次移动 8，rax 移动 120。可以判断，rdx 表示的是按行移动，rax 表示的是按列移动。</p><p>根据 rdx 每次移动 8，可以得出每个数组元素大小为 8。rdx 每次移动 120，说明每行有 120/8=15 个元素，即 M=15。</p><hr><h2 id="3-66"><a href="#3-66" class="headerlink" title="3.66"></a>3.66</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR(n) (3*(n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NC(n) (4*(n)+1)</span></span><br></pre></td></tr></table></figure><p>解释：</p><p>如果通读汇编代码会发现，L3 部分（12-16 行）才是真正的循环体。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.L3</span><br><span class="line">    addq    (%rcx), %rax    # %rax(result）= *rcx。往上读代码，发现到第 <span class="number">8</span> 行，rcx=<span class="number">8</span>*j+A，这里的 j 可以当作一个常数，因为 j 列是固定的。</span><br><span class="line">    addq    $<span class="number">1</span>, %rdx          # %rdx 已经不存储 j 了（因为 j 的作用已经在第 <span class="number">8</span> 行用掉了），现存储 i。该行计算 ++i。</span><br><span class="line">    addq    %r8, %rcx       # 第 <span class="number">7</span> 行计算得出 r8=(<span class="number">4</span>*n+<span class="number">1</span>)*<span class="number">8</span>，r8 代表每行的长度。经过该行之后，指针指向的是下一行的 j 列。得到 NC(n)。</span><br><span class="line">    cmpq    %rdi, %rdx。  # 比较 i 和 rdi 的值，rdi 在第 <span class="number">4</span> 行算出等于 <span class="number">3</span>n。所以 rdi 代表的是行数。得出 NR(n)。</span><br><span class="line">    jne     .L3</span><br></pre></td></tr></table></figure><hr><h2 id="3-67"><a href="#3-67" class="headerlink" title="3.67"></a>3.67</h2><p>A.</p><p>为了便于对比，我把这题和 E 的图放在一起了。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.18/img/20210521.jpeg" alt=""></p><p>B.</p><p>传的是 %rsp+64。</p><p>C.</p><p>使用 %rsp+C 来访问，其中 %rsp 是基址，常数 C 作为偏移量，取值为 0、8 、16 和 24。</p><p>D.</p><p>这里要注意，<strong>call 指令实际上是执行了两步，1）将程序下一条指令的位置的 IP 压入堆栈中；2）转移到调用的子程序 。</strong></p><p>所以执行 call 指令以后，%rsp 的值要减去 8，以用来保存「返回地址」（如 A. 右侧图所示）。</p><p>process 通过地址表达式 %rsp+C 来设置结构体 r，C 的取值为 8、16 和 24（注意这里的 %rsp 的值为 -8）。</p><p>E.</p><p>传递聚合类型的变量，应当传递地址，而不是传递整个数据结构。</p><hr><h2 id="3-68"><a href="#3-68" class="headerlink" title="3.68"></a>3.68</h2><hr><h2 id="3-69"><a href="#3-69" class="headerlink" title="3.69"></a>3.69</h2><hr><h2 id="3-70"><a href="#3-70" class="headerlink" title="3.70"></a>3.70</h2><hr><h2 id="3-71"><a href="#3-71" class="headerlink" title="3.71"></a>3.71</h2><p><strong>char *fgets(char *s, int n, FILE *stream)</strong></p><p>fgets 函数最多将下 n-1 个字符读入到数组 s 中。当遇到换行符时，把换行符读入到数组 s 中，读取过程终止。数组 s 以 <code>\0</code> 结尾。fgets 函数返回数组 s。如果到达文件的末尾或发生错误，返回 NULL。</p><p><strong>void *memset(s, c, n)</strong></p><p>将 s 中的前 n 个字符替换为 c，并返回 s。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_OF_BUFFER 10 <span class="comment">// buff 默认大小为 10。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">good_echo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *buff = <span class="built_in">calloc</span>(SIZE_OF_BUFFER, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (buff == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: failed to allocate buffer.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        fgets(buff, SIZE_OF_BUFFER, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(buff) == SIZE_OF_BUFFER - <span class="number">1</span>) &#123; <span class="comment">// 存在 读完、未读完 两种情况。</span></span><br><span class="line">            <span class="built_in">fputs</span>(buff, <span class="built_in">stdout</span>);</span><br><span class="line">            <span class="keyword">if</span> (buff[SIZE_OF_BUFFER - <span class="number">1</span> - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>) &#123; <span class="comment">// 读完。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="built_in">strlen</span>(buff)); <span class="comment">// 未读完。所以要将 buff 清空，以开始再一轮的读取。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strlen</span>(buff) &lt; SIZE_OF_BUFFER - <span class="number">1</span>) &#123; <span class="comment">// 一定读完。</span></span><br><span class="line">            <span class="built_in">fputs</span>(buff, <span class="built_in">stdout</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(buff);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-72"><a href="#3-72" class="headerlink" title="3.72"></a>3.72</h2><p>A.</p><p>汇编代码第 5 行 leaq 指令计算 8<em>n+30，第 6 行 and 指令向下舍入到最接近 16 的整数。当 n 是奇数时，结果是 8\</em>n+24，当 n 是偶数时，结果是 8*n+16。s1 减去这个值就得到 s2。</p><p>B.</p><p>将 s2 向下舍入到最接近 16 的倍数。</p><p>C.</p><p>D.</p><p>都向 16 的倍数对齐。</p><hr><h2 id="3-73"><a href="#3-73" class="headerlink" title="3.73"></a>3.73</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">find_range:</span><br><span class="line">vxorps %xmm1, %xmm1, %xmm1</span><br><span class="line">vucomiss %xmm0, %xmm1</span><br><span class="line">ja .L5</span><br><span class="line">jp .L8</span><br><span class="line">movl $<span class="number">1</span>, %eax</span><br><span class="line">je .L3</span><br><span class="line">.L8:</span><br><span class="line">seta %al</span><br><span class="line">movzbl %al, %eax</span><br><span class="line">addl $<span class="number">2</span>, %eax</span><br><span class="line">ret</span><br><span class="line">.L5:</span><br><span class="line">movl $<span class="number">0</span>, %eax</span><br><span class="line">.L3:</span><br><span class="line">rep;ret</span><br></pre></td></tr></table></figure><p>（这题还没搞懂。）</p><hr><h2 id="3-74"><a href="#3-74" class="headerlink" title="3.74"></a>3.74</h2><hr><h2 id="3-75"><a href="#3-75" class="headerlink" title="3.75"></a>3.75</h2><p>A.</p><p>传值使用两个 %xmm 寄存器，一个寄存器表示真部（real），一个寄存器表示虚部（imag）。</p><p>B.</p><p>返回使用 %xmm0 和 %xmm1 两个寄存器。</p>]]></content>
      
      
      <categories>
          
          <category> CSAPP 深入理解计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP 家庭作业答案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程打印「的士数」</title>
      <link href="/posts/2420731903/"/>
      <url>/posts/2420731903/</url>
      
        <content type="html"><![CDATA[<p>今天看电影<a href="https://movie.douban.com/subject/3269088/">《知无涯着》</a>看到的，所以想编程验证一下。</p><p>「的士数」在电影里和在维基百科上看到的故事来源是不一样的，鉴于维基百科更真实一些，所以此处引用维基百科关于「的士数」的故事：</p><blockquote><p>拉马努金病重，哈代前往探望。哈代说：“我乘的士来，车牌号码是 1729，这数真没趣，希望不是不祥之兆。”拉马努金答道：“不，那是个有趣得很的数。可以用两个立方之和来表达而且有两种表达方式的数之中， 1729 是最小的。”（即 ${1729=1^{3}+12^{3}=9^{3}+10^{3}}$，后来这类数称为的士数。）利特尔伍德回应这宗轶闻说：“每个整数都是拉马努金的朋友。”</p></blockquote><p>关于拉马努金：英国皇家学会院士（亚洲第一人），英属印度人，是英属印度史上最著名的数学家之一。</p><p>关于哈代：是他在剑桥三一学院任教的时候发现并帮助了拉马努金，可以说是拉马努金的伯乐。</p><p>关于利特尔伍德：人们常开玩笑说：利特尔伍德是哈代幻想出来的影子。两人经常合作。</p><p>那么该怎么定义「的士数」呢？还是直接引用维基百科：</p><blockquote><p>第 n 个的士数（Taxicab number），一般写作${Ta}(n)$ 或 ${Taxicab}(n)$，定义为最小的数能以 n 个不同的方法表示成两个正立方数之和。</p></blockquote><p>用 C++ 来求解的代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTaxicab2</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count != N) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">pow</span>(ans, <span class="number">1.0</span> / <span class="number">3</span>); ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">double</span> j = i + <span class="number">1</span>; j &lt;= <span class="built_in">pow</span>(ans, <span class="number">1.0</span> / <span class="number">3</span>); ++ j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i * i * i + j * j * j == ans) &#123;</span><br><span class="line">                    ++ cur_count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 这里 n 取 2</span></span><br><span class="line">        <span class="keyword">if</span> (cur_count == <span class="number">2</span>) &#123;</span><br><span class="line">            ++ count;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++ ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实到目前为止也只是找出了 6 个的士数，它们分别是：</p><p>$Ta(1)=2=1^{3}+1^{3}$</p><p>$Ta(2)=1729=1^{3}+12^{3}=9^{3}+10^{3}$</p><p>$Ta(3)=87539319=167^{3}+436^{3}=228^{3}+423^{3}=255^{3}+414^{3}$</p><p>$Ta(4)=6963472309248=2421^{3}+19083^{3}=5436^{3}+18948^{3}=10200^{3}+18072^{3}=13322^{3}+16630^{3}$</p><p>$Ta(5)=48988659276962496=38787^{3}+365757^{3}=107839^{3}+362753^{3}=205292^{3}+342952^{3}=221424^{3}+336588^{3}=231518^{3}+331954^{3}$</p><p>$Ta(6)=24153319581254312065344=582162^{3}+28906206^{3}=3064173^{3}+28894803^{3}=8519281^{3}+28657487^{3}=16218068^{3}+27093208^{3}=17492496^{3}+26590452^{3}=18289922^{3}+26224366^{3}$</p>]]></content>
      
      
      <categories>
          
          <category> 有趣的知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解计算机系统_3e_第二章家庭作业答案</title>
      <link href="/posts/4212127740/"/>
      <url>/posts/4212127740/</url>
      
        <content type="html"><![CDATA[<h2 id="本机环境"><a href="#本机环境" class="headerlink" title="本机环境"></a>本机环境</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ uname -ap</span><br><span class="line">Darwin Apple0.local <span class="number">20.3</span><span class="number">.0</span> Darwin Kernel Version <span class="number">20.3</span><span class="number">.0</span>: Thu Jan <span class="number">21</span> <span class="number">00</span>:<span class="number">07</span>:<span class="number">06</span> PST <span class="number">2021</span>; root:xnu<span class="number">-7195.81</span><span class="number">.3</span>~<span class="number">1</span>/RELEASE_X86_64 x86_64 i386</span><br></pre></td></tr></table></figure><p>另外，配置原因，题目要求的在不同的机器上运行都只在一台机器上运行的。</p><blockquote><p>知识点：</p><p>IEEE 浮点标准是 $V=(-1)^s\times M\times2^E$ 来表示一个数。</p><p>假设有 <code>k</code> 位阶码位，<code>n</code> 位尾数位。</p><p>Bias 对于规格化和非规格化的值都一样，都等于 $Bias=2^{(k-1)}-1$。</p><p><strong>规格化的值：</strong></p><p>E=e-Bias。</p><p>E 表示 2 的 E 次幂（可能为负数）。</p><p>e 为阶码字段 $e_{k-1}…e_1e_0$。</p><p>M=1+f。</p><p>f 为尾数字段 $\frac{f_{n-1}…f_1f_0} {2^n}$。</p><p><strong>非规格化的值：</strong></p><p>E=1-Bias。</p><p>M=f。</p><p>f 同规格化的 f。</p></blockquote><hr><h2 id="2-55"><a href="#2-55" class="headerlink" title="2.55"></a>2.55</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*这一段代码的大部分来自http://csapp.cs.cmu.edu/3e/students.html*/</span></span><br><span class="line"><span class="comment">/* $begin show-bytes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/* $end show-bytes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/* $begin show-bytes */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bytes</span><span class="params">(byte_pointer start, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; %.2x&quot;</span>, start[i]);    <span class="comment">//line:data:show_bytes_printf</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_int</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">//line:data:show_bytes_amp1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_float</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">float</span>)); <span class="comment">//line:data:show_bytes_amp2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_pointer</span><span class="params">(<span class="keyword">void</span> *x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)); <span class="comment">//line:data:show_bytes_amp3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end show-bytes */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin test-show-bytes */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_show_bytes</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ival = val;</span><br><span class="line">    <span class="keyword">float</span> fval = (<span class="keyword">float</span>) ival;</span><br><span class="line">    <span class="keyword">int</span> *pval = &amp;ival;</span><br><span class="line">    show_int(ival);</span><br><span class="line">    show_float(fval);</span><br><span class="line">    show_pointer(pval);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end test-show-bytes */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple_show_a</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/* $begin simple-show-a */</span></span><br><span class="line"><span class="keyword">int</span> val = <span class="number">0x87654321</span>;</span><br><span class="line">byte_pointer valp = (byte_pointer) &amp;val;</span><br><span class="line">show_bytes(valp, <span class="number">1</span>); <span class="comment">/* A. */</span></span><br><span class="line">show_bytes(valp, <span class="number">2</span>); <span class="comment">/* B. */</span></span><br><span class="line">show_bytes(valp, <span class="number">3</span>); <span class="comment">/* C. */</span></span><br><span class="line"><span class="comment">/* $end simple-show-a */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple_show_b</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/* $begin simple-show-b */</span></span><br><span class="line"><span class="keyword">int</span> val = <span class="number">0x12345678</span>;</span><br><span class="line">byte_pointer valp = (byte_pointer) &amp;val;</span><br><span class="line">show_bytes(valp, <span class="number">1</span>); <span class="comment">/* A. */</span></span><br><span class="line">show_bytes(valp, <span class="number">2</span>); <span class="comment">/* B. */</span></span><br><span class="line">show_bytes(valp, <span class="number">3</span>); <span class="comment">/* C. */</span></span><br><span class="line"><span class="comment">/* $end simple-show-b */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">float_eg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">3490593</span>;</span><br><span class="line">  <span class="keyword">float</span> f = (<span class="keyword">float</span>) x;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;For x = %d\n&quot;</span>, x);</span><br><span class="line">  show_int(x);</span><br><span class="line">  show_float(f);</span><br><span class="line"></span><br><span class="line">  x = <span class="number">3510593</span>;</span><br><span class="line">  f = (<span class="keyword">float</span>) x;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;For x = %d\n&quot;</span>, x);</span><br><span class="line">  show_int(x);</span><br><span class="line">  show_float(f);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">string_ueg</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/* $begin show-ustring */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s = <span class="string">&quot;ABCDEF&quot;</span>;</span><br><span class="line">show_bytes((byte_pointer) s, <span class="built_in">strlen</span>(s)); </span><br><span class="line"><span class="comment">/* $end show-ustring */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">string_leg</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/* $begin show-lstring */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">show_bytes((byte_pointer) s, <span class="built_in">strlen</span>(s)); </span><br><span class="line"><span class="comment">/* $end show-lstring */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_twocomp</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* $begin show-twocomp */</span></span><br><span class="line">    <span class="keyword">short</span> x = <span class="number">12345</span>; </span><br><span class="line">    <span class="keyword">short</span> mx = -x; </span><br><span class="line">    </span><br><span class="line">    show_bytes((byte_pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">short</span>)); </span><br><span class="line">    show_bytes((byte_pointer) &amp;mx, <span class="keyword">sizeof</span>(<span class="keyword">short</span>)); </span><br><span class="line"><span class="comment">/* $end show-twocomp */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    val = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calling test_show_bytes\n&quot;</span>);</span><br><span class="line">test_show_bytes(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;calling show_twocomp\n&quot;</span>);</span><br><span class="line">show_twocomp();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Calling simple_show_a\n&quot;</span>);</span><br><span class="line">simple_show_a();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Calling simple_show_b\n&quot;</span>);</span><br><span class="line">simple_show_b();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Calling float_eg\n&quot;</span>);</span><br><span class="line">float_eg();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Calling string_ueg\n&quot;</span>);</span><br><span class="line">string_ueg();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Calling string_leg\n&quot;</span>);</span><br><span class="line">string_leg();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">打印输出为：</span><br><span class="line">calling show_twocomp</span><br><span class="line"> <span class="number">39</span> <span class="number">30</span></span><br><span class="line"> c7 cf</span><br><span class="line">Calling simple_show_a</span><br><span class="line"> <span class="number">21</span></span><br><span class="line"> <span class="number">21</span> <span class="number">43</span></span><br><span class="line"> <span class="number">21</span> <span class="number">43</span> <span class="number">65</span></span><br><span class="line">Calling simple_show_b</span><br><span class="line"> <span class="number">78</span></span><br><span class="line"> <span class="number">78</span> <span class="number">56</span></span><br><span class="line"> <span class="number">78</span> <span class="number">56</span> <span class="number">34</span></span><br><span class="line">Calling float_eg</span><br><span class="line">For x = <span class="number">3490593</span></span><br><span class="line"> <span class="number">21</span> <span class="number">43</span> <span class="number">35</span> <span class="number">00</span></span><br><span class="line"> <span class="number">84</span> <span class="number">0</span>c <span class="number">55</span> <span class="number">4</span>a</span><br><span class="line">For x = <span class="number">3510593</span></span><br><span class="line"> <span class="number">41</span> <span class="number">91</span> <span class="number">35</span> <span class="number">00</span></span><br><span class="line"> <span class="number">04</span> <span class="number">45</span> <span class="number">56</span> <span class="number">4</span>a</span><br><span class="line">Calling string_ueg</span><br><span class="line"> <span class="number">41</span> <span class="number">42</span> <span class="number">43</span> <span class="number">44</span> <span class="number">45</span> <span class="number">46</span></span><br><span class="line">Calling string_leg</span><br><span class="line"> <span class="number">61</span> <span class="number">62</span> <span class="number">63</span> <span class="number">64</span> <span class="number">65</span> <span class="number">66</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-56"><a href="#2-56" class="headerlink" title="2.56"></a>2.56</h2><p>更改数值为：192833445</p><p>编译运行输出为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">calling test_show_bytes</span><br><span class="line"> a5 <span class="number">67</span> <span class="number">7</span>e <span class="number">0b</span></span><br><span class="line"> <span class="number">7</span>a e6 <span class="number">37</span> <span class="number">4</span>d</span><br><span class="line"> <span class="number">38</span> f4 bf ef fe <span class="number">7f</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure><p>解释：</p><p>十进制：192833445 对应二进制表示为：1011011111100110011110100101，十六进制表示为：0xb7e67a5。</p><p>根据 IEEE 754 标准，单精度小数（float）的二进制位格式为：1 位符号位，8 位阶码位，23 位尾数位。</p><p>将二进制小数点向左移动 27 位（因为规格化表示要求所有的浮点数都表示为 <code>1.XXX</code>，而且前面的 1 不会实际存储，这样有多争取了 1 位来表示尾数），结果为 <code>1.01101111110011001111010*0101*</code>。因为尾数只有 23 位，因此将末尾的 <code>0101</code> 舍去（默认为向偶数舍去）结果为 <code>1.01101111110011001111010</code>，所以尾数的位表示为 <code>01101111110011001111010</code>。</p><p>EXP=00011011（27 的二进制表示），Bias=127，因此 E=EXP+Bias=01001101，符号为的位表示为 <code>00011011</code>。</p><p>综上：<code>0，01001101，01101111110011001111010</code>，十六进制表示位 <code>0x4d37e67a</code>。</p><p>另外一个例子：</p><p>十进制：9978 二进制表示为：<code>10011011111010</code>，十六进制表示为：<code>0x26fa</code>。</p><p>编译运行输出为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">calling test_show_bytes</span><br><span class="line"> fa <span class="number">26</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"> <span class="number">00</span> e8 <span class="number">1b</span> <span class="number">46</span></span><br><span class="line"> <span class="number">38</span> f4 bf ef fe <span class="number">7f</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure><p> 将二进制位向左移动 13 位，结果为 <code>1.0011011111010</code>，又因为 IEEE 754 规定尾号位 23 位，所以在后边补 10 个 0，尾数的位表示为 <code>00110111110100000000000</code>。</p><p> EXP=00001101（13 的二进制表示），Bias=127，因此 E=EXP+Bias=140，二进制位表示为 <code>10001100</code>，也就是符号位的二进制表示。</p><p>所以综上：<code>0，10001100，00110111110100000000000</code>。十六进制为 <code>0x461be800</code>。</p><hr><h2 id="2-57"><a href="#2-57" class="headerlink" title="2.57"></a>2.57</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bytes</span><span class="params">(byte_pointer start, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++ i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %.2x&quot;</span>, start[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_short</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">short</span> n = <span class="number">1234</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;short n = %hd\n&quot;</span>, n);</span><br><span class="line">    show_bytes((byte_pointer)&amp;n, <span class="keyword">sizeof</span>(n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_long</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = <span class="number">123456789</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;long n = %ld\n&quot;</span>, n);</span><br><span class="line">    show_bytes((byte_pointer)&amp;n, <span class="keyword">sizeof</span>(n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> n = <span class="number">123456789.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;long n = %lf\n&quot;</span>, n);</span><br><span class="line">    show_bytes((byte_pointer)&amp;n, <span class="keyword">sizeof</span>(n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    show_short();</span><br><span class="line">    show_long();</span><br><span class="line">    show_double();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行输出为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> n = <span class="number">1234</span></span><br><span class="line"> d2 <span class="number">04</span></span><br><span class="line"><span class="keyword">long</span> n = <span class="number">123456789</span></span><br><span class="line"> <span class="number">15</span> cd <span class="number">5b</span> <span class="number">07</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="keyword">long</span> n = <span class="number">123456789.000000</span></span><br><span class="line"> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">54</span> <span class="number">34</span> <span class="number">6f</span> <span class="number">9</span>d <span class="number">41</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-58"><a href="#2-58" class="headerlink" title="2.58"></a>2.58</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_little_endian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">short</span> n = <span class="number">0x00ff</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;n;</span><br><span class="line">    <span class="keyword">if</span> (*p) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, is_little_endian());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为只有小端机器所以大端的没办法测试。</p><p>原理是：</p><p>十六进制的 short 0x00ff，二进制形式为：<code>0000 0000 1111 1111</code>。采用小端存储为 <code>1111 1111 0000 0000</code>，强制类型转换为 unsigned char *，因此 p 指向第一位，也就是第一个 1，因此 *p 是一个非零值。</p><hr><h2 id="2-59"><a href="#2-59" class="headerlink" title="2.59"></a>2.59</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_2_59</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0x89ABCDEF</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0x76543210</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, (x &amp; <span class="number">0xff</span>) | (y &amp; <span class="number">0xffffff00</span>)); <span class="comment">// 第二的括号还可以写成 y &amp; ~0xff，~0xff = 0xffffff00</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun_2_59();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-60"><a href="#2-60" class="headerlink" title="2.60"></a>2.60</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">replace_byte</span><span class="params">(<span class="keyword">unsigned</span> x, <span class="keyword">int</span> i, <span class="keyword">unsigned</span> <span class="keyword">char</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> move = i * <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">return</span> (x &amp; ~(<span class="number">0xFF</span> &lt;&lt; move)) | b &lt;&lt; move;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#.8x\n&quot;</span>, replace_byte(<span class="number">0x12345678</span>, <span class="number">0</span>, <span class="number">0xAB</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#.8x\n&quot;</span>, replace_byte(<span class="number">0x12345678</span>, <span class="number">2</span>, <span class="number">0xAB</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行结果为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x123456ab</span></span><br><span class="line"><span class="number">0x12ab5678</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-61"><a href="#2-61" class="headerlink" title="2.61"></a>2.61</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> sizeOfInt = <span class="keyword">sizeof</span>(<span class="keyword">int</span>); <span class="comment">// l = 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;变量 int x 为：%#.8x\n&quot;</span>, x);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Condition A */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;X 的所有位都等于 1 么？%d\n&quot;</span>, !(~x));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Condition B */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;X 的所有位都等于 0 么？%d\n&quot;</span>, !(<span class="number">1</span> &amp;&amp; x));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Condition C */</span></span><br><span class="line">    <span class="keyword">int</span> shift_val = (shift_val - <span class="number">1</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;X 的最低有效字节中的位都等于 1 么？%d\n&quot;</span>, !((~(x &amp; <span class="number">0xFF</span>)) &lt;&lt; shift_val));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Condition D */</span></span><br><span class="line">    shift_val = (sizeOfInt - <span class="number">1</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;X 的最高有效字节中的位都等于 0 么？%d\n&quot;</span>, !(x &gt;&gt; shift_val));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;###############################\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func(<span class="number">0x00FFFFFF</span>);</span><br><span class="line">    func(<span class="number">0</span>);</span><br><span class="line">    func(~<span class="number">0</span>);</span><br><span class="line">    func(<span class="number">0x010FFFFF0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行结果为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">变量 <span class="keyword">int</span> x 为：<span class="number">0x00ffffff</span></span><br><span class="line">X 的所有位都等于 <span class="number">1</span> 么？<span class="number">0</span></span><br><span class="line">X 的所有位都等于 <span class="number">0</span> 么？<span class="number">0</span></span><br><span class="line">X 的最低有效字节中的位都等于 <span class="number">1</span> 么？<span class="number">1</span></span><br><span class="line">X 的最高有效字节中的位都等于 <span class="number">0</span> 么？<span class="number">1</span></span><br><span class="line">###############################</span><br><span class="line">变量 <span class="keyword">int</span> x 为：<span class="number">00000000</span></span><br><span class="line">X 的所有位都等于 <span class="number">1</span> 么？<span class="number">0</span></span><br><span class="line">X 的所有位都等于 <span class="number">0</span> 么？<span class="number">1</span></span><br><span class="line">X 的最低有效字节中的位都等于 <span class="number">1</span> 么？<span class="number">0</span></span><br><span class="line">X 的最高有效字节中的位都等于 <span class="number">0</span> 么？<span class="number">1</span></span><br><span class="line">###############################</span><br><span class="line">变量 <span class="keyword">int</span> x 为：<span class="number">0xffffffff</span></span><br><span class="line">X 的所有位都等于 <span class="number">1</span> 么？<span class="number">1</span></span><br><span class="line">X 的所有位都等于 <span class="number">0</span> 么？<span class="number">0</span></span><br><span class="line">X 的最低有效字节中的位都等于 <span class="number">1</span> 么？<span class="number">1</span></span><br><span class="line">X 的最高有效字节中的位都等于 <span class="number">0</span> 么？<span class="number">0</span></span><br><span class="line">###############################</span><br><span class="line">变量 <span class="keyword">int</span> x 为：<span class="number">0x10fffff0</span></span><br><span class="line">X 的所有位都等于 <span class="number">1</span> 么？<span class="number">0</span></span><br><span class="line">X 的所有位都等于 <span class="number">0</span> 么？<span class="number">0</span></span><br><span class="line">X 的最低有效字节中的位都等于 <span class="number">1</span> 么？<span class="number">0</span></span><br><span class="line">X 的最高有效字节中的位都等于 <span class="number">0</span> 么？<span class="number">0</span></span><br><span class="line">###############################</span><br></pre></td></tr></table></figure><hr><h2 id="2-62"><a href="#2-62" class="headerlink" title="2.62"></a>2.62</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">int_shifts_are_arithmetic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (x &gt;&gt; <span class="number">1</span>) == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = int_shifts_are_arithmetic();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-63"><a href="#2-63" class="headerlink" title="2.63"></a>2.63</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">srl</span><span class="params">(<span class="keyword">unsigned</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> xsra = (<span class="keyword">int</span>)x &gt;&gt; k;</span><br><span class="line">    <span class="keyword">size_t</span> w = <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> a = ~<span class="number">0</span>;</span><br><span class="line">    a = a &lt;&lt; (w - k);</span><br><span class="line">    <span class="keyword">return</span> xsra &amp; ~a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sra</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xsrl = (<span class="keyword">unsigned</span>) x &gt;&gt; k;</span><br><span class="line">    <span class="keyword">size_t</span> w = <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> a = ~<span class="number">0</span>;</span><br><span class="line">    a = a &lt;&lt; (w - k);</span><br><span class="line">    <span class="keyword">return</span> xsrl | a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> x = <span class="number">0b10000000000000000000000000000000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, srl(x, <span class="number">8</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, <span class="number">0b00000000100000000000000000000000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sra(x, <span class="number">8</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">0b11111111100000000000000000000000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">8388608</span></span><br><span class="line"><span class="number">8388608</span></span><br><span class="line"><span class="number">-8388608</span></span><br><span class="line"><span class="number">-8388608</span></span><br></pre></td></tr></table></figure><p>解释：</p><p>为了简便用 w=8 位来举例子。</p><p><strong>算数右移完成逻辑右移</strong></p><p>假设二进制 <code>10010110</code>，<code>k = 3</code>。则想要的结果是 <em>000</em> 10010。</p><p>然而进行算数右移得到的是 <code>n = *111*10010</code>。为了得到 <em>000</em>10010，我们可以想：如果 <code>n</code> 和 <code>00011111</code> 进行 <code>&amp;</code> 运算，则刚好是我们想要的结果 <em>000</em>10010。</p><p>那我们怎样可以产生我们想要的 <code>00011111</code> 呢？（注意题目不让用右移和除法）</p><p>如果将 <code>11111111</code> 左移 <code>w-k</code> 位是不是就有了 <em>111</em>00000 了么，再取反是不是就有了 <em>000</em>11111。</p><p>所以答案就出来了。</p><p><strong>逻辑右移完成算数右移</strong></p><p>逻辑右移完成算数右移只不过是将 <code>&amp;</code> 运算改为 <code>|</code> 运算，而且 <code>11111111</code> 左移 <code>w-k</code> 位后也不用取反。</p><hr><h2 id="2-64"><a href="#2-64" class="headerlink" title="2.64"></a>2.64</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">any_odd_one</span><span class="params">(<span class="keyword">unsigned</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">0x55555555</span>;</span><br><span class="line">    <span class="keyword">return</span> (x &amp; n) &amp;&amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> x = <span class="number">0b00010000000000000000000000000000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, any_odd_one(x));</span><br><span class="line">    x = <span class="number">0b00100000000000000000000000000000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, any_odd_one(x));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不要搞错奇偶位，是从右往左数，不是从左往右数。</strong></p><p>打印输出为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>提示：<code>0xAAAAAAAA</code> 的二进制为 <code>10101010101010101010101010101010</code>，特点是：齐位都为 1。</p><hr><h2 id="2-65"><a href="#2-65" class="headerlink" title="2.65"></a>2.65</h2><hr><h2 id="2-66"><a href="#2-66" class="headerlink" title="2.66"></a>2.66</h2><hr><h2 id="2-67"><a href="#2-67" class="headerlink" title="2.67"></a>2.67</h2><p>A. </p><blockquote><p>(C11, 6.5.7p3) “If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined”</p></blockquote><p>B.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">int_size_is_32</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> set_msb = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> beyond_msb = set_msb;</span><br><span class="line">    beyond_msb &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> set_msb &amp;&amp; !beyond_msb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, int_size_is_32());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印输出为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>见招拆招，32 位不让移动，我就分两步走，先走 31 位， 再走 1 位。</strong></p><p>C.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">int_size_is_32</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> set_msb = <span class="number">1</span> &lt;&lt; <span class="number">15</span>;</span><br><span class="line">    set_msb &lt;&lt;= <span class="number">15</span>;</span><br><span class="line">    set_msb &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> beyond_msb = set_msb;</span><br><span class="line">    beyond_msb &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> set_msb &amp;&amp; !beyond_msb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, int_size_is_32());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印输出为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>在 16 位的机器上每步最多可以移动 15 位。将 31 和 32 拆成多步，并且每步最多走 15 位。</strong></p><hr><h2 id="2-68"><a href="#2-68" class="headerlink" title="2.68"></a>2.68</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_one_mask</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> a = ~<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> w = <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> a &gt;&gt; (w - n);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    return (2&lt;&lt;(n-1)) - 1; // 这个方法更牛逼</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#.8x\n&quot;</span>, lower_one_mask(<span class="number">17</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#.8x\n&quot;</span>, lower_one_mask(<span class="number">32</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印输出为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0001ffff</span></span><br><span class="line"><span class="number">0xffffffff</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-69"><a href="#2-69" class="headerlink" title="2.69"></a>2.69</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">rotate_left</span><span class="params">(<span class="keyword">unsigned</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> w = <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> a = x &lt;&lt; n;</span><br><span class="line">    <span class="keyword">unsigned</span> b = x &gt;&gt; (w - n - <span class="number">1</span>);</span><br><span class="line">    b = b &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n = 0: %#.8x\n&quot;</span>, rotate_left(<span class="number">0x12345678</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n = 4: %#.8x\n&quot;</span>, rotate_left(<span class="number">0x12345678</span>, <span class="number">4</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n = 20: %#.8x\n&quot;</span>, rotate_left(<span class="number">0x12345678</span>, <span class="number">20</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n = 31: %#.8x\n&quot;</span>, rotate_left(<span class="number">0x12345678</span>, <span class="number">31</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印输出为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n = <span class="number">0</span>: <span class="number">0x12345678</span></span><br><span class="line">n = <span class="number">4</span>: <span class="number">0x23456781</span></span><br><span class="line">n = <span class="number">20</span>: <span class="number">0x67812345</span></span><br><span class="line">n = <span class="number">31</span>: <span class="number">0x091a2b3c</span></span><br></pre></td></tr></table></figure><p>注意：当 <code>n=0</code> 的时候，按照我的方法 <code>b</code> 要右移 32 位，但是这会产生警告：<code>&quot;Shift count &gt;= width of type&quot;，详见 2.67</code>。所以我将右移拆成了两步，先右移 (w - n - 1) 位，再右移 1 位。</p><hr><h2 id="2-70"><a href="#2-70" class="headerlink" title="2.70"></a>2.70</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fits_bits</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    x &gt;&gt;= (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> !x || !(~x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, fits_bits(INT_MAX, <span class="number">32</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, fits_bits(INT_MIN, <span class="number">32</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, fits_bits(INT_MIN, <span class="number">31</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, fits_bits(INT_MAX, <span class="number">31</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印输出为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>解释：</p><p>一个数的补码的符号位只有两种情况，要么 <code>0</code>，要么 <code>1</code>。如果一个数字 <code>x</code> 可以被表示为 <code>n</code> 位的补码，那么 <code>x</code> 的补码的第 <code>n-1</code> 位，也就是符号位要么是 <code>0</code>，要么是 <code>1</code>。如果第 <code>n-1</code> 位是 <code>1</code>，那么前面的 <code>w-n</code> 位也是 <code>1</code>，如果第 <code>n-1</code> 位是 <code>0</code>，那么前面的 <code>w-n</code> 位也是 <code>0</code>。</p><p>因此，通过上述分析，判断一个数字 <code>x</code> 能否被表示为 <code>n</code> 位的补码数，就转变成了，看 <code>x</code> 的高 <code>w-n+1</code> 位是否全 <code>0</code>，或者全 <code>1</code>。</p><hr><h2 id="2-71"><a href="#2-71" class="headerlink" title="2.71"></a>2.71</h2><p>说实话这题的题目我读了半小时才读懂。其实题目挺简单的，就是让你把无符号的 32 位的数 <code>word</code>，给拆成 4 个有符号数（每个大小为 1 byte）。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">packed_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xbyte</span><span class="params">(<span class="keyword">packed_t</span> word, <span class="keyword">int</span> bytenum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left_move = (<span class="number">3</span> - bytenum) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> right_move = <span class="number">3</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)word &lt;&lt; left_move &gt;&gt; right_move ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">packed_t</span> word = <span class="number">0x8060FF00</span>;</span><br><span class="line"><span class="comment">//  10000000 01100000 11111111 00000000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, xbyte(word, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, xbyte(word, <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, xbyte(word, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, xbyte(word, <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印输出为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">96</span></span><br><span class="line"><span class="number">-128</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-72"><a href="#2-72" class="headerlink" title="2.72"></a>2.72</h2><p>A.</p><p>因为 <code>sizeof</code> 的返回值是 <code>size_t</code> 类型的，是<strong>无符号</strong>的。所以 <code>if</code> 条件 <code>maxbytes-sizeof(val) &gt;= 0</code> 总是会成立。</p><p>B.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_int</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">void</span> *buf, <span class="keyword">int</span> maxbytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxbytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxbytes &gt;= <span class="keyword">sizeof</span>(val)) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(buf, (<span class="keyword">void</span> *) &amp;val, <span class="keyword">sizeof</span>(val));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-73"><a href="#2-73" class="headerlink" title="2.73"></a>2.73</h2><p>连同 2.74 一块做个溢出情况总结。</p><p><strong>补码加法：</strong></p><p>假设 <code>t=a+b</code>。</p><p>如果 a、b 同号，</p><p>a&gt;0，b&gt;0，如果 t&lt;=0 则正溢出。</p><p>a<0，b<0，如果 t>=0 则负溢出。</p><p>如果 a、b 异号，肯定不会溢出。</p><p><strong>补码减法：</strong></p><p>假设 <code>t=a-b</code>。</p><p>如果 a、b 同号，则肯定不会溢出。</p><p>如果 a、b 异号，</p><p>a&gt;=0，b&lt;0，如果 t&lt;0 则溢出。</p><p>a<0，b>=0，如果 t&gt;=0 则溢出。</p><p>因此，a、b 异号，t、b 同号，则判定为补码减法溢出。</p><hr><h2 id="2-74"><a href="#2-74" class="headerlink" title="2.74"></a>2.74</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tsub_ok</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> w = <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> l, m;</span><br><span class="line">    <span class="keyword">int</span> t = x - y;</span><br><span class="line">    l = (x &gt;&gt; (w - <span class="number">1</span>)) - (y &gt;&gt; (w - <span class="number">1</span>)); <span class="comment">// x、y 同号 l 为 0</span></span><br><span class="line">    m = (t &gt;&gt; (w - <span class="number">1</span>)) - (y &gt;&gt; (w - <span class="number">1</span>)); <span class="comment">// t、y 同号 l 为 0</span></span><br><span class="line">    <span class="keyword">return</span> !l || !(l &amp;&amp; (!m)); <span class="comment">// || 两边两个条件分别为：同号不会溢出；a、b 异号，t、b 同号则溢出。具体参见 2.73 的溢出情况整理。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tsub_ok(<span class="number">123456</span>, <span class="number">54321</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tsub_ok(<span class="number">2147483647</span>, <span class="number">-1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tsub_ok(<span class="number">-2147483648</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印输出为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>后来突然发现，该题目并没有限制 <code>==</code>和 <code>!=</code> 的使用，所以重新写一下该方法。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tsub_ok</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> w = <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> t = x - y;</span><br><span class="line">    <span class="comment">// 取符号位</span></span><br><span class="line">    x &gt;&gt;= (w - <span class="number">1</span>);</span><br><span class="line">    y &gt;&gt;= (w - <span class="number">1</span>);</span><br><span class="line">    t &gt;&gt;= (w - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (x == y) || !((x != y) &amp;&amp; (y == t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-75"><a href="#2-75" class="headerlink" title="2.75"></a>2.75</h2><hr><h2 id="2-76"><a href="#2-76" class="headerlink" title="2.76"></a>2.76</h2><hr><h2 id="2-77"><a href="#2-77" class="headerlink" title="2.77"></a>2.77</h2><p>A.</p><p>(x&lt;&lt;4)+x。</p><p>B.</p><p>x-(x&lt;&lt;3)。</p><p>C.</p><p>(x&lt;&lt;6)-(x&lt;&lt;2)。</p><p>D.</p><p>(x&lt;&lt;4)-(x&lt;&lt;7)。</p><hr><h2 id="2-78"><a href="#2-78" class="headerlink" title="2.78"></a>2.78</h2><p>什么叫「正确的舍入方式」？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide_power2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> w = <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> bias = (x &gt;&gt; (w - <span class="number">1</span>)) &amp; (<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (x + bias) &gt;&gt; k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, divide_power2(<span class="number">1024</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, divide_power2(<span class="number">5</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, divide_power2(<span class="number">-1024</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, divide_power2(<span class="number">-5</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印输出：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">256</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">-256</span></span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure><p>解释：</p><p>首先我们要知道，补码除以 2 的幂，是要分补码是正数、负数两种情况的。</p><p>对于正数，我们可以直接用右移操作来得出结果。</p><p>对于负数，我们就要先加上偏置（bias）再进行右移。</p><p>所以综上，除以 2 的 k 次幂可以表示为 <code>(x&lt;0 ? x+(1&lt;&lt;k)-1 : x) &gt;&gt; k</code>，其中 $bias=2^k-1=(1&lt;&lt;k)-1$。</p><p>但是对于该题，我们不可以用 <code>:?</code> 来解答。那么我们该怎么根据 x 的正、负来计算 bias 呢？（可以参考下练习题2.42）。</p><p>我们也可以认为不论正、负，其实都加了 bias。只不过，正数，<code>bias = 0</code>；负数，<code>bias = (1&lt;&lt;k)-1</code>。</p><p>我们首先将 x 算数右移 <code>w-1</code> 位，如果 x 是负数，则会得到 <code>0xFFFFFFFF</code>，如果 x 是正数，则会得到 <code>0x00000000</code>。</p><p>然后，我们就可以通过掩码来屏蔽掉适当的位来求得 bias。那么掩码该怎么确定呢？其实掩码就是 bias 本身。因为对于正数，<code>0x00000000 &amp; bias</code> 还是等于 0，对于负数 <code>0xFFFFFFFF &amp; bias</code> 就会得到 (1&lt;&lt;k)-1。</p><hr><h2 id="2-79"><a href="#2-79" class="headerlink" title="2.79"></a>2.79</h2><hr><h2 id="2-80"><a href="#2-80" class="headerlink" title="2.80"></a>2.80</h2><hr><h2 id="2-81"><a href="#2-81" class="headerlink" title="2.81"></a>2.81</h2><hr><h2 id="2-82"><a href="#2-82" class="headerlink" title="2.82"></a>2.82</h2><p>A.</p><p>false。当 x=TMin，y=0 时。</p><p>B.</p><p>true。</p><p>C.</p><p>true。</p><p>左边等于：~x+~y+1 = (~x+1)+(~y+1) -1 = -x + -y -1。</p><p>右边等于：~(x+y) = (~(x+y)+1)-1 = -(x+y)-1 = -x + -y + 1。</p><p><strong>PS：求补码的相反数：取反再加一。</strong></p><p>D.</p><p>E.</p><p>true。右移 2 位，再左移 2 位，这只会改变 32 位中最低的 2 位，结果就是把低 2 位变为 <code>00</code>。对于正数和负数来说，这会小于原始值，对于 0 来说，这不会改变值。</p><hr><h2 id="2-83"><a href="#2-83" class="headerlink" title="2.83"></a>2.83</h2><hr><h2 id="2-84"><a href="#2-84" class="headerlink" title="2.84"></a>2.84</h2><p>假设 k&lt;=n，如果。</p><p>$ Bias=2^{k-1}-1 $</p><p><strong>A. 数 7.0</strong></p><p>数 7.0 转为规格化表示为 $0.7 \times $</p><p>位表示：<code>0, 0...1, 0...111</code></p><p>E=e-Bias=1-BIas。</p><p>$f=\frac {7}{2^n}$。</p><p>M=1+f。</p><p>$V=(-1)^s \times M \times 2^E$</p><p><strong>B. 能够被准确描述的最大基数</strong></p><p>位表示：<code>0, 11...10, 11...11</code></p><p>$E=e-Bias=2^{k}-2-Bias$。</p><p>$f=\frac {2^{n-1}}{2^n}$。</p><p>M=1+f。</p><p>$V=(-1)^s \times M \times 2^E$</p><p><strong>C. 最小的规格化数的倒数</strong></p><p>位表示：<code>1,</code></p><p>$E=e-Bias$。</p><p>f=</p><p>M=1+f</p><p>$V=(-1)^s \times M \times 2^E$。</p><hr><h2 id="2-85"><a href="#2-85" class="headerlink" title="2.85"></a>2.85</h2><p><strong>A.</strong></p><p>7 的位表示为 111，那么位数 M 的表示就应该是 1.11（IEEE 标准中默认 M 前面隐藏了 1），所以小数位就是 0.25（）</p><p><strong>B.</strong></p><p><strong>C.</strong></p><hr><h2 id="2-86"><a href="#2-86" class="headerlink" title="2.86"></a>2.86</h2><p>1 个符号位，15 个阶码位，63 个小数位。$ Bias=2^{14}-1 $。</p><p><strong>最小的正非规格化数：</strong> <code>0，00...00，00...01</code></p><p>$ E=1-Bias=1-(2^{14}-1)=2-2^{14} $。$ M=f= \frac {1}{2^{63}}=2^{-63} $。</p><p>值：$ M \times 2^E=2^{-63} \times 2^{2-2^{14}} $。</p><p><strong>最小的正规格化数：</strong> <code>0，00...01，00...00</code></p><p>$ E=e-Bias=1-(2^{14}-1)=2-2^{14} $。$ M=1+f=1+ \frac {0}  {2^{63}}=1$。</p><p>值：$ M \times 2^E = 2^{2-2^{14}}$。</p><p><strong>最大的规格化数：</strong> <code>0，11...10，11...11</code></p><p>$ E=e-Bias=2^{15}-2-(2^{14}-1)=2^{14}-1 $。$ M=1+f=1+2-2^{-63}$。</p><p>值：$ M \times 2^{E}=(1+2-2^{-63}) \times 2^{2^{14}-1} $。</p>]]></content>
      
      
      <categories>
          
          <category> CSAPP 深入理解计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP 家庭作业答案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的指向常量的指针(pointer to const)和常量指针(const pointer)</title>
      <link href="/posts/728643541/"/>
      <url>/posts/728643541/</url>
      
        <content type="html"><![CDATA[<p>在 C++ 中有 <code>const</code> 常量限定符，即被限制的对象的值不可改变。</p><p>指针是指向（point to）另外一种类型的复合类型。</p><p>当指针遇上常量就会产生「常量指针」和「指针常量」。</p><p>指针有两个东西，一个是指针本身，一个是指针所指的那个变量。<strong>这两个东西都可以是常量。</strong></p><p>指针本身可以是常量，指针所指的变量也可以是常量。</p><p>逐个分析：</p><ol><li>指针本身是常量</li></ol><p><code>int *const q = &amp;i;</code></p><p><strong>也就是说指针 <code>q</code> 的值不可被改变，也就是 <code>q</code> 指向 <code>i</code> 这个事实不可被改变，也就是 <code>q</code> 不可以再指向别人了。</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> q = &amp;i;<span class="comment">// q 是 const</span></span><br><span class="line">*q = <span class="number">26</span>; <span class="comment">// OK</span></span><br><span class="line">++ q; <span class="comment">// ERROR，q 的值不可被改变</span></span><br></pre></td></tr></table></figure><ol><li>指针所指向的变量是常量</li></ol><p><code>const int *q = &amp;i;</code></p><p><strong>这里要搞清楚，<code>i</code> 的值是可以改变的，只是不能通过 <code>q</code> 来改变，</strong>因此 <code>*q = 3;// ERROR</code>。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i  = <span class="number">1</span>, j = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *q = &amp;i;<span class="comment">// (*q) 是 const</span></span><br><span class="line">*q = <span class="number">3</span>;<span class="comment">// ERROR</span></span><br><span class="line">q = &amp;j;<span class="comment">// OK</span></span><br><span class="line">i = <span class="number">3</span>;<span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>看过上边的分析，再看下面三个表达式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p1 = &amp;i;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p2 = &amp;i;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p3 = &amp;i;</span><br></pre></td></tr></table></figure><p>是不是很迷糊。其实很简单：判断上面三个表达式的含义，可以根据 <code>const</code> 和 <code>*</code> 是谁在前面。</p><ol><li><code>const</code> 在 <code>*</code> 前面，说明通过指针不可修改其指向的变量。</li><li><code>const</code> 在 <code>*</code> 后面，说明指针本身不可修改。</li></ol><p>也可以理解为：<strong><code>*</code> 前面的是对被指向对象的修饰，<code>*</code> 后面的是对指针本身的修饰。</strong></p><p>所以上边的三个表达式，前两个是一样的，是指向常量的指针(pointer to const)。第三个是常量指针(const pointer)。</p><p><strong>我觉得「指针常量」这个翻译并不好，应该叫：指向常量的指针(pointer to const)。《C++ Primer》中的术语就是：指向常量的指针(pointer to const)和常量指针(const pointer)。</strong></p><blockquote><p><a href="http://www.icourse163.org/learn/zju-9001#/learn/content?type=detail&amp;id=142003&amp;cid=166048">参考视频</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 指针 </tag>
            
            <tag> const 常量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乌合之众</title>
      <link href="/posts/785063509/"/>
      <url>/posts/785063509/</url>
      
        <content type="html"><![CDATA[<h3 id="大众没有辨别能力，因而无法判断事情的真伪，许多经不起推敲的观点，都能轻而易举的得到普遍的赞同。"><a href="#大众没有辨别能力，因而无法判断事情的真伪，许多经不起推敲的观点，都能轻而易举的得到普遍的赞同。" class="headerlink" title="大众没有辨别能力，因而无法判断事情的真伪，许多经不起推敲的观点，都能轻而易举的得到普遍的赞同。"></a>大众没有辨别能力，因而无法判断事情的真伪，许多经不起推敲的观点，都能轻而易举的得到普遍的赞同。</h3><h3 id="结群后，由于人多势众，个人会产生一种幻觉，感到自己力大无穷，不可战胜，好像没什么事是办不到的。"><a href="#结群后，由于人多势众，个人会产生一种幻觉，感到自己力大无穷，不可战胜，好像没什么事是办不到的。" class="headerlink" title="结群后，由于人多势众，个人会产生一种幻觉，感到自己力大无穷，不可战胜，好像没什么事是办不到的。"></a>结群后，由于人多势众，个人会产生一种幻觉，感到自己力大无穷，不可战胜，好像没什么事是办不到的。</h3><h3 id="人一到群体中，智商就严重降低，为了获得认同，个体愿意抛弃是非，用智商去换取那份让人倍感安全的归属感。群体有着各种狂乱的愿望，群体没有能力做任何长远的打算或思考。"><a href="#人一到群体中，智商就严重降低，为了获得认同，个体愿意抛弃是非，用智商去换取那份让人倍感安全的归属感。群体有着各种狂乱的愿望，群体没有能力做任何长远的打算或思考。" class="headerlink" title="人一到群体中，智商就严重降低，为了获得认同，个体愿意抛弃是非，用智商去换取那份让人倍感安全的归属感。群体有着各种狂乱的愿望，群体没有能力做任何长远的打算或思考。"></a>人一到群体中，智商就严重降低，为了获得认同，个体愿意抛弃是非，用智商去换取那份让人倍感安全的归属感。群体有着各种狂乱的愿望，群体没有能力做任何长远的打算或思考。</h3><h3 id="群体盲从意识会淹没个体的理性，个体一旦将自己归入该群体，其原本独立的理性就会被群体的无知疯狂所淹没。"><a href="#群体盲从意识会淹没个体的理性，个体一旦将自己归入该群体，其原本独立的理性就会被群体的无知疯狂所淹没。" class="headerlink" title="群体盲从意识会淹没个体的理性，个体一旦将自己归入该群体，其原本独立的理性就会被群体的无知疯狂所淹没。"></a>群体盲从意识会淹没个体的理性，个体一旦将自己归入该群体，其原本独立的理性就会被群体的无知疯狂所淹没。</h3><h3 id="群体在智力上总是低于孤立的个人，但是从感情及其激发的行动这个角度看，群体可以比个人表现得更好或更差，这全看环境如何。一切取决于群体所接受的暗示具有什么性质。"><a href="#群体在智力上总是低于孤立的个人，但是从感情及其激发的行动这个角度看，群体可以比个人表现得更好或更差，这全看环境如何。一切取决于群体所接受的暗示具有什么性质。" class="headerlink" title="群体在智力上总是低于孤立的个人，但是从感情及其激发的行动这个角度看，群体可以比个人表现得更好或更差，这全看环境如何。一切取决于群体所接受的暗示具有什么性质。"></a>群体在智力上总是低于孤立的个人，但是从感情及其激发的行动这个角度看，群体可以比个人表现得更好或更差，这全看环境如何。一切取决于群体所接受的暗示具有什么性质。</h3><h3 id="群众没有真正渴求过真理，面对那些不合味的证据他们充耳不闻…凡是能像他们提供幻觉的，都可以很容易的成为他们的主人；凡是让他们幻灭的，都会成为他们的牺牲品。"><a href="#群众没有真正渴求过真理，面对那些不合味的证据他们充耳不闻…凡是能像他们提供幻觉的，都可以很容易的成为他们的主人；凡是让他们幻灭的，都会成为他们的牺牲品。" class="headerlink" title="群众没有真正渴求过真理，面对那些不合味的证据他们充耳不闻…凡是能像他们提供幻觉的，都可以很容易的成为他们的主人；凡是让他们幻灭的，都会成为他们的牺牲品。"></a>群众没有真正渴求过真理，面对那些不合味的证据他们充耳不闻…凡是能像他们提供幻觉的，都可以很容易的成为他们的主人；凡是让他们幻灭的，都会成为他们的牺牲品。</h3><h3 id="群体追求和相信的从来不是什么真相和理性，而是盲从、残忍、偏执和狂热，只知道简单而极端的感情。"><a href="#群体追求和相信的从来不是什么真相和理性，而是盲从、残忍、偏执和狂热，只知道简单而极端的感情。" class="headerlink" title="群体追求和相信的从来不是什么真相和理性，而是盲从、残忍、偏执和狂热，只知道简单而极端的感情。"></a>群体追求和相信的从来不是什么真相和理性，而是盲从、残忍、偏执和狂热，只知道简单而极端的感情。</h3><h3 id="不要轻易的成为集体狂欢的一份子，这样很容易被别有用心的人利用，即使你以为自己只不过是随声附和了一声而已，实际上你已经成为了帮凶。"><a href="#不要轻易的成为集体狂欢的一份子，这样很容易被别有用心的人利用，即使你以为自己只不过是随声附和了一声而已，实际上你已经成为了帮凶。" class="headerlink" title="不要轻易的成为集体狂欢的一份子，这样很容易被别有用心的人利用，即使你以为自己只不过是随声附和了一声而已，实际上你已经成为了帮凶。"></a>不要轻易的成为集体狂欢的一份子，这样很容易被别有用心的人利用，即使你以为自己只不过是随声附和了一声而已，实际上你已经成为了帮凶。</h3><h3 id="个人一旦成为群体的一员，他所作所为就不会再承担责任，这时每个人都会暴露出自己不受到约束的一面。"><a href="#个人一旦成为群体的一员，他所作所为就不会再承担责任，这时每个人都会暴露出自己不受到约束的一面。" class="headerlink" title="个人一旦成为群体的一员，他所作所为就不会再承担责任，这时每个人都会暴露出自己不受到约束的一面。"></a>个人一旦成为群体的一员，他所作所为就不会再承担责任，这时每个人都会暴露出自己不受到约束的一面。</h3><h3 id="单独一个人必须要为他的行为承担责任—法律上或者道德上。群体不需要承担任何责任，群体就是责任，群体就是道德，群体就是法律，群体的行为自然是合理的。"><a href="#单独一个人必须要为他的行为承担责任—法律上或者道德上。群体不需要承担任何责任，群体就是责任，群体就是道德，群体就是法律，群体的行为自然是合理的。" class="headerlink" title="单独一个人必须要为他的行为承担责任—法律上或者道德上。群体不需要承担任何责任，群体就是责任，群体就是道德，群体就是法律，群体的行为自然是合理的。"></a>单独一个人必须要为他的行为承担责任—法律上或者道德上。群体不需要承担任何责任，群体就是责任，群体就是道德，群体就是法律，群体的行为自然是合理的。</h3><h3 id="群体会让每个人都在其中的错误缩小，同时让每个人的恶意被无限放大。"><a href="#群体会让每个人都在其中的错误缩小，同时让每个人的恶意被无限放大。" class="headerlink" title="群体会让每个人都在其中的错误缩小，同时让每个人的恶意被无限放大。"></a>群体会让每个人都在其中的错误缩小，同时让每个人的恶意被无限放大。</h3>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经济机器是怎样运行的</title>
      <link href="/posts/15747650/"/>
      <url>/posts/15747650/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天看了<a href="https://www.youtube.com/watch?v=rFV7wdEX-Mo">「经济机器是怎样运行的」</a>这个视频，现在自己总结下来。</p></blockquote><p>支出是经济活动的驱动力。一个人的支出是另一个人的收入。</p><p>信贷是经济活动中最重要的组成部分。信贷简单说就是个人凭借信用向银行借款以增加自己的支出。信贷会产生经济周期。经济周期分为长周期和短周期。其中长周期一般持续75-100年，短周期持续5-8年。信贷的借款人会产生债务，贷款人产生资产。</p><p>因为一个人的支出是另一个人的收入，所以通过信贷借来更多的钱，这样会增加另一个人的收入，另一个人的收入增加，就会使他的支出增加，这就会让另外的人收入也增加，通过这样一直循环，所以增长率（GDP）会呈上升趋势。但是这样也会使债务积累起来。</p><p>价格 = 支出金额 / 产销量。</p><p>如果收入的增长速度大于商品的生产速度，那么就会导致价格上升，进而导致通货膨胀。</p><p>这时央行会通过调整利率来控制通货膨胀。因为如果利率高，那人们会降低贷款频率和金额，反之利率低人们就会增加贷款频率和金额。</p><p>因为一个人的支出是另一个人的收入，当利率提高，人们贷款金额少时，市场上的资金就会变少，债务也随之减少，这样就可以抑制通胀。</p><p>如果利率提的太高，抑制过了头的话，那就会产生通货紧缩。之后央行还会再减低利率，增加债务，这样经济又会扩张。</p><p>所以短期的债务周期一般由央行决定。一般持续5-8年。</p><p>如果经济一直增长，人们手中的资产也大量增值，股票市场一片欣欣向荣。</p><p>债务负担 = 债务  收入。</p><p>这样会产生下面一种现象：收入增加 =&gt; 债务负担可承受，同时资产增值 =&gt; 人们借贷购入资产 =&gt; 人们觉得自己很富有（但是存在大量债务）。随着时间的增加，长期债务负担变大（因为债务再慢慢增长） =&gt; 为了偿还债务，人们会缩减支出 =&gt; 另一个人的收入减少 =&gt; 人们的信用减少（之所以可以信贷，就是因为借款人有信用） =&gt; 信贷变难 =&gt; 偿还成本增加 =&gt; 支出减少 =&gt; 去杠杆化 =&gt; 紧经济下滑。 </p><p>这种情况和经济衰退相似，但是不可能通过调整利率来控制挽回（这时利率已经接近0%）。</p><p>那么解决经济下滑有四种方式：</p><ol><li>削减支出。</li><li>减少债务。</li><li>财富再分配。</li><li>发行货币。</li></ol><p>个人、银行、政府、企业都会缩减开支。企业通过裁员来缩减支出，这就会导致失业率上升。同时人们也会担心自己存在银行的钱取不回来，就会产生“挤兑”的现象。挤兑就是银行被大批的存款顾客要求取回储金，因为银行没有那么多的现金储备，所以银行就极有可能会面临倒闭以及信用破产。个人债务也会产生违约。这就加重了紧急萧条。</p><p>减少债务的手段有延长还款周期、降低利率、减少还款额，以上几个手段被称为债务重组。债务重组导致债务消失，但是同时也导致收入和资产以更快的速度消失。债务负担日趋日渐沉重。</p><p>同时这也会影响到中央政府，导致政府收入减少（税收减少）。与此同时，由于失业率上升，政府需要拨出更多的失业救助金。但是政府没有足够的收入。这时政府想要增加收入，可以通过给富人加税的手段来实现财富再分配，政府通过富人的钱来救助穷人。这也会产生一个问题，富人会厌恶穷人，反过来穷人也会厌恶富人。如果萧条再持续下去的话，就会产生社会动荡。社会动荡可不得了。</p><p>为了避免社会动荡，现在还剩一个办法，就是增印货币用来购买金融资产和债券，这会增加资产的价格从而增加人们的信用。这是最简单也是最有效的方法。但是如果控制不好就会产生严重的经济失衡。</p><p>为了达到「和谐的去杠杆化」，就要通胀政策和紧缩政策达到一个平衡。如果收入比债务增长快，那经济会慢慢恢复。这个恢复时间一般要7-10年。通常人们又称之为「失去的十年」。</p><p>给大家的一些建议。</p><ol><li>不要让债务的增长速度超过收入。</li><li>不要让收入的增长速度超过生产率。这样会导致失去竞争力。</li><li>尽一切努力去提高生产率。这在长期会起到最关键的作用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 文章分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的一些「奇葩」生活习惯</title>
      <link href="/posts/2562327459/"/>
      <url>/posts/2562327459/</url>
      
        <content type="html"><![CDATA[<h3 id="我会一直保持手上干净"><a href="#我会一直保持手上干净" class="headerlink" title="我会一直保持手上干净"></a>我会一直保持手上干净</h3><p>平时回到家第一件事基本就是洗手（这应该算是个好习惯吧）。</p><p>吃完饭后我会去洗手，因为吃饭时手上会沾上油。如果吃完饭我没有立刻去洗手，那就是说明我在等家人吃完饭后帮着一起收拾饭桌，等收拾完后我再去洗手。同样因为吃饭时手上会沾上油，所以我吃饭时一般不会玩手机。我讨厌手机上油乎乎的。</p><p>平时我也会保持我所触及到的物品的干净。</p><p>反正就是手一脏我就想洗。</p><h3 id="用洗面奶洗脸前，我会先洗一遍手"><a href="#用洗面奶洗脸前，我会先洗一遍手" class="headerlink" title="用洗面奶洗脸前，我会先洗一遍手"></a>用洗面奶洗脸前，我会先洗一遍手</h3><p>我洗脸的步骤：</p><ol><li>在水龙头上用一丢丢洗面奶洗一遍手（比别人多出来的一步）。</li><li>洗脸。</li></ol><p>然后去擦脸，抹乳液。抹完乳液之前我不会碰脏东西，比如说拖把。</p><h3 id="外边穿的衣服我不会洗的很勤，贴身穿的衣服我会每天一换洗"><a href="#外边穿的衣服我不会洗的很勤，贴身穿的衣服我会每天一换洗" class="headerlink" title="外边穿的衣服我不会洗的很勤，贴身穿的衣服我会每天一换洗"></a>外边穿的衣服我不会洗的很勤，贴身穿的衣服我会每天一换洗</h3><p>外边穿的衣服如果经常洗就没有一开始买来的版型和颜色，所以我不会经常去洗，而且平时穿的也很省。这里的「省」包括但不限于：</p><p>对于裤子：</p><ol><li>我不会长时间蹲着，因为这会让膝盖后边有很多褶皱。</li><li>牛仔裤我基本不洗，注意我说的是基本（但是因为穿的省，所以不会太脏）。</li></ol><p>对于上衣外套：</p><ol><li>穿羽绒服或者是其他有「蓬松感」的外套时我不会长时间靠在椅背上。</li><li>我不会把长款的衣服直接坐在屁股底下。</li></ol><p>对于贴身的衣服，我如果脱下来隔一晚再穿上去，就会觉得贴别的膈应。</p><h3 id="我讨厌任何人用手摸我的电脑屏幕"><a href="#我讨厌任何人用手摸我的电脑屏幕" class="headerlink" title="我讨厌任何人用手摸我的电脑屏幕"></a>我讨厌任何人用手摸我的电脑屏幕</h3><p>我仔仔细细把屏幕擦干净了，好，你过来直接一个手指印摁在那了….</p><p>这种行为我就很无语。</p><p>你说我再擦一下吧，工具我还没带，不擦吧我看着难受。</p><h3 id="每次摘掉-AirPods-的时候我会顺手把脏东西清理掉"><a href="#每次摘掉-AirPods-的时候我会顺手把脏东西清理掉" class="headerlink" title="每次摘掉 AirPods 的时候我会顺手把脏东西清理掉"></a>每次摘掉 AirPods 的时候我会顺手把脏东西清理掉</h3><p>我会让 AirPods 干净的躺回去。</p><h3 id="我会「及时」删掉没用的文件"><a href="#我会「及时」删掉没用的文件" class="headerlink" title="我会「及时」删掉没用的文件"></a>我会「及时」删掉没用的文件</h3><p>比如说考研的文件，如果一直在我设备上，我就会觉得心里一直有块东西。考完研我会立即删掉文件，是的，考完试当晚我就删了。</p><p>当然这里的「及时」有时候也会给我带来麻烦，有时候想再用文件时却发现已经删了。</p><p>另外，最近在折腾音乐播放软件，因为 Apple Music 有三个月免费试用，所以我就尝试了一下。尝试过后发现并不适合我，所以我就把三个月免费试用期给关了。但是今天我又想用 Apple Music 时，发现不能免费试用了……</p><h3 id="手机上不会乱下-APP"><a href="#手机上不会乱下-APP" class="headerlink" title="手机上不会乱下 APP"></a>手机上不会乱下 APP</h3><p>比如，自从出了「微信小程序」，我手机上的 APP 就少了很多。一个软件能办的事，我不会用两个软件来办。比如说，微信小程序就可以买车票，我就不会再单独下一个购票软件。</p><p>另外我还觉得卸载了 APP 以后，手机上总会有残留。</p><p>但是今天我破例了，搞了三个音乐播放软件，淦！</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 我 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贰零贰壹年贰月</title>
      <link href="/posts/1904585190/"/>
      <url>/posts/1904585190/</url>
      
        <content type="html"><![CDATA[<h4 id="02-01"><a href="#02-01" class="headerlink" title="02.01"></a>02.01</h4><p>// …</p><p>停更了。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日更 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贰零贰壹年一月</title>
      <link href="/posts/865893437/"/>
      <url>/posts/865893437/</url>
      
        <content type="html"><![CDATA[<h4 id="01-01"><a href="#01-01" class="headerlink" title="01.01"></a>01.01</h4><p>喜迎2021！</p><hr><h4 id="01-02"><a href="#01-02" class="headerlink" title="01.02"></a>01.02</h4><p>// …</p><hr><h4 id="01-03"><a href="#01-03" class="headerlink" title="01.03"></a>01.03</h4><p>房子是一个城市的股票。人口的去留是城市的现金流。</p><hr><p>人的一生，爱情也好，友情也罢，确实会有那么几个人，成为终身伴侣、至交好友，虽然走得近，但是依然能保持亲密和优质的关系。但大部分时候，大部分人，没必要走的太近，陪伴比贴身好，雪中送炭比平日嘘寒问暖好。于江湖相望，必要时扶持一下，然后继续向前走，就是挺好的方式。</p><p>所以，不要和时间走的太近，不要和灾难走的太近，不要和大多数人走的太近，带上口罩，间隔一米，也能合作的挺好不是？ -摘自公众号：MacTalk</p><hr><p>你属狗的？一抬腿儿撒泡尿这地儿就你家的了？</p><hr><h4 id="01-04"><a href="#01-04" class="headerlink" title="01.04"></a>01.04</h4><p>// …</p><hr><h4 id="01-05"><a href="#01-05" class="headerlink" title="01.05"></a>01.05</h4><p>最终，时间会消解一切，只有自己记得自己。</p><p>不要向别人证明自己，要向自己证明自己。</p><hr><h4 id="01-06"><a href="#01-06" class="headerlink" title="01.06"></a>01.06</h4><p>// …</p><hr><h4 id="01-07"><a href="#01-07" class="headerlink" title="01.07"></a>01.07</h4><p>// …</p><hr><h4 id="01-08"><a href="#01-08" class="headerlink" title="01.08"></a>01.08</h4><p>今晚有个快递，打算吃了晚饭再去拿。吃完饭碰巧遇见快递小哥开着小三轮往校外走。我当时犹豫了一下喊不喊他，心想说不定这个不是我的那个快递，这么多人在这喊多不好意思，不如我过去快递点看看，要真是他那就打电话说明天再拿。但是犹豫了一下后，我还是选择了抓住这个机会，喊了他一下，然后取到了快递。</p><p>如果当时没有喊他，那快递就要明天才能取，而这个快递是我心心念了好久的一个东西。所以当机会来临时，还是要勇敢去争取的。</p><hr><h4 id="01-09"><a href="#01-09" class="headerlink" title="01.09"></a>01.09</h4><p>不要把学校互黑的习惯带入职场。</p><hr><h4 id="01-10"><a href="#01-10" class="headerlink" title="01.10"></a>01.10</h4><p>克服拖延吧。</p><hr><h4 id="01-11"><a href="#01-11" class="headerlink" title="01.11"></a>01.11</h4><p>在信息获取方面，我们面临的问题是信息太多，有用的没有用的都会一股脑的进入你的视线。我们要做的就是在这些海量的信息中筛选我们需要的有用的信息。</p><p>一般我们可以通过标题来判断该信息是不是糟糠。例如标题中出现什么吐血整理、看这一篇就够了，这些大概率是标题党。还有什么研究了XX个例子，总结出XX。</p><p>也不要指望看一篇文章就可以学会什么知识。你学来的可能只是一个知识点，这并不能连通成知识链。要想连接成知识链，还需要你对这方面知识有系统的感知。比如说，给你一篇英语阅读，如果不看文章直接记答案的话，那很可能记不牢。如果你看完文章做完题，再去记答案，那这样你的记忆会更深刻。</p><p>所以要想学习一门技术，最好是去看书或者是教学视频来系统的学习。其实20多个小时就可以学会一门技术。</p><p>另外，还是那句话带着问题去学习。如果你看到了一篇文章，是关于如何挑选牛奶的，正好你也有这方面疑惑，那你可能会从这篇文章中吸取比较多的东西，然后你再去实践，这样印象就会更深刻。然而当你看到一篇文章教你如何做糖醋里脊，你可能从没有做过饭，未来一段时间也不太可能会学做饭，那这篇文章对你来说可能就要属于糟糠了。但是这篇文章对你会做饭，而且又爱吃糖醋里脊的对象来说，可能就是一篇好文章。</p><hr><h4 id="01-12"><a href="#01-12" class="headerlink" title="01.12"></a>01.12</h4><p>为什么听到微信提示音会有愉悦的感觉？</p><hr><h4 id="01-13"><a href="#01-13" class="headerlink" title="01.13"></a>01.13</h4><p>// …</p><hr><h4 id="01-14"><a href="#01-14" class="headerlink" title="01.14"></a>01.14</h4><p>聚光灯效应：用来指人们认为自己很受其他人所留意著，高估自身言行举止受他人关注的程度。</p><p>关注自己的其实只有我们自己。</p><hr><h4 id="01-15"><a href="#01-15" class="headerlink" title="01.15"></a>01.15</h4><p>职场有两种人：</p><p>1、就给这么点钱，凭什么给你干。</p><p>2、只要我努力，就一定会有收获。</p><p>靠谱是一种策略，摸鱼、拍马屁也是，但要选长期最优的。 —小道消息 Fenng</p><hr><h4 id="01-16"><a href="#01-16" class="headerlink" title="01.16"></a>01.16</h4><p>// …</p><hr><h4 id="01-17"><a href="#01-17" class="headerlink" title="01.17"></a>01.17</h4><p>// …</p><hr><h4 id="01-18"><a href="#01-18" class="headerlink" title="01.18"></a>01.18</h4><p>「公平才是最大的不公平，不公平才是公平」。</p><p>差异化才会有机会。</p><hr><h4 id="01-19"><a href="#01-19" class="headerlink" title="01.19"></a>01.19</h4><p>// …</p><hr><h4 id="01-20"><a href="#01-20" class="headerlink" title="01.20"></a>01.20</h4><p>// …</p><hr><h4 id="01-21"><a href="#01-21" class="headerlink" title="01.21"></a>01.21</h4><p>// …</p><hr><h4 id="01-22"><a href="#01-22" class="headerlink" title="01.22"></a>01.22</h4><p>最近也好久没看书了，一直在准备期末考试和标数据。</p><p>今天考完了最后一门，这个学期也过完了。明天该动身回家了：）</p><p>第一学期体验了下研究生的日常生活，水的很。</p><p>其实内心也有后悔读研的想法，但是已经来了也不好走了，既来之则安之对不对。</p><p>虽说读研可能会“浪费”三年的时间，但是关键还是要看自己怎么利用这三年。</p><hr><h4 id="01-23-01-31"><a href="#01-23-01-31" class="headerlink" title="01.23 - 01.31"></a>01.23 - 01.31</h4><p>// …</p><hr><p><strong><em>最后这是我的视频号，欢迎关注：）</em></strong></p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.14/img/postImg/202101.jpeg" width = "300" height = "397" alt="图片名称" align=center /></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日更 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的2020年终总结</title>
      <link href="/posts/1569506949/"/>
      <url>/posts/1569506949/</url>
      
        <content type="html"><![CDATA[<p>这一年过得也太快了吧，几乎没怎么感觉就来到了年底。</p><p>2020年发生了好多大事：新冠、科比去世、美国大选、原油负价格、美股四次熔断等等，2020可谓不平凡。</p><p>有人说「2020年是过去十年最艰难的一年，也是未来十年最轻松的一年」。由于疫情很多人离职在家，找不到工作；有人也好久没有回到办公室，一直是远程办公。也正是因为疫情，激发了线上办公、线上教育的兴起。真是任何事物都有可能会火起来，但前提是你要有基础，才能有机会分一块蛋糕。</p><p>2020年对于我来说，发生的大事应该是考研成功上岸，来到了杭州这个美丽的城市。</p><p>2020年我读的书比我过去二十多年读的书加起来还要多（当然不能包括教材），同时也看了不少经典的电影和电视剧。</p><p>2020年我也通过读书、知识星球、公众号等渠道提升了不少的个人认知，也有幸关注到曹大、冯大、帅张、bobo老师等人。</p><p>2020年我也养成了知识付费的习惯，在极客时间、慕课网以及其他网站都学习了一些课程。</p><p>2020年身体除了还是那么瘦以外也没有其他的问题，同时也为父母和自己配置了一定的保险。</p><p>2020年我看了《乔布斯传》，并且第一次熬夜看了Apple发布会，抢了首发iPhone 12，用着还不错。</p><p>2020年我也在互联网上挣到了小几千块钱，虽然不多但是很开心，买了块Apple Watch。</p><p>2020年我买了三只鸡，表现还不错。我理财思维的建立应该是在2019年的暑假看了富爸爸这本书，然后选择买了黄金，一开始还赚了些，不过后来也是都亏回去了。投资理财方面还有待提高。</p><p>现在又是单身了，真不知当初的决定是不是正确的。</p><p>回头看看2019年定的目标。</p><ol><li>每天半小时看书没做到，但是看书方面确实是进步了。</li><li>日语也没做到。</li><li>公号就输出了一篇文章，今年的文章主要输出在网站和知乎了。</li><li>视频剪辑学了一些，但是没有像样的作品。</li></ol><p>那定下2021年的目标吧。</p><ol><li>准备实习，并且找到实习公司，工资无所谓。</li><li>看3本英文原著，专业书或小说都可，重要的是去看。</li><li>英语还要再进一步。</li></ol><p>让我们跟着操蛋的2020说拜拜，迎接新的2021吧！</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贰零二零年十二月</title>
      <link href="/posts/1004452755/"/>
      <url>/posts/1004452755/</url>
      
        <content type="html"><![CDATA[<h4 id="12-01"><a href="#12-01" class="headerlink" title="12.01"></a>12.01</h4><p>今天网站迁移工作已经差不多做完了。</p><hr><h4 id="12-02"><a href="#12-02" class="headerlink" title="12.02"></a>12.02</h4><p>// …</p><hr><h4 id="12-03"><a href="#12-03" class="headerlink" title="12.03"></a>12.03</h4><p>验证性偏差：人们常常寻找那些能证明自己正确的信息，而不是那些证明自己错误的证据。</p><hr><h4 id="12-04"><a href="#12-04" class="headerlink" title="12.04"></a>12.04</h4><ul><li><p>这水是死的，鱼是活的。</p></li><li><p>说的玄乎了点吧。这没了水，鱼怎么活啊？总不能飞到树上装鸟吧。</p></li></ul><hr><p>设计者确定其设计已经达到了完美的标准不是不能再增加任何东西，而是不能再减少任何东西。</p><hr><h4 id="12-05"><a href="#12-05" class="headerlink" title="12.05"></a>12.05</h4><p>我们或许需要表达更为清楚、不太有火药味的信息，更好地倾听，保持冷静和礼貌。</p><hr><h4 id="12-06"><a href="#12-06" class="headerlink" title="12.06"></a>12.06</h4><p>《大明王朝》</p><hr><p>优秀者抄袭，伟大者剽窃。-乔布斯</p><hr><h4 id="12-07"><a href="#12-07" class="headerlink" title="12.07"></a>12.07</h4><p>// …</p><hr><h4 id="12-08"><a href="#12-08" class="headerlink" title="12.08"></a>12.08</h4><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.9/img/postImg/20201108.jpeg" alt=""></p><hr><h4 id="12-09"><a href="#12-09" class="headerlink" title="12.09"></a>12.09</h4><p>对别人要求低一点，对自己要求高一点。</p><p>或许生活就不那么拧巴了。</p><p> 摘自：公众号「小道消息」</p><hr><h4 id="12-10"><a href="#12-10" class="headerlink" title="12.10"></a>12.10</h4><p>肝完《大明王朝》。</p><hr><h4 id="12-11"><a href="#12-11" class="headerlink" title="12.11"></a>12.11</h4><p>读书要带着问题去读，在书中找答案，这样才能记得住。</p><p>另外不要说读书了就是学习了。读书或许是为偷懒找的一种借口，或许是在变向偷懒。</p><hr><p>行有余力再读书。</p><hr><h4 id="12-12"><a href="#12-12" class="headerlink" title="12.12"></a>12.12</h4><p>躲过了双十一，没躲过双十二。</p><hr><h4 id="12-13"><a href="#12-13" class="headerlink" title="12.13"></a>12.13</h4><p>汪曾祺《下雪》</p><p>雪花想下又不想下，犹犹豫豫。</p><p>你们商量商量，自己拿个主意。</p><p>对面人家的房顶白了。</p><p>雪花拿定了主意了：</p><p>下。 ​​​</p><hr><h4 id="12-14"><a href="#12-14" class="headerlink" title="12.14"></a>12.14</h4><p>所有的规划都应该立足于几年后，而不是今天规划明天做什么。</p><hr><h4 id="12-15"><a href="#12-15" class="headerlink" title="12.15"></a>12.15</h4><p>// …</p><hr><h4 id="12-16"><a href="#12-16" class="headerlink" title="12.16"></a>12.16</h4><p>今天知乎给我推了「我的知乎十年」，我才突然意识到2020年已经接近尾声了。</p><p>说来2020年可真是不平凡的一年，发生了那么多的事，新冠、Kobe去世、奥运会延期、原油跌到负数、美国总统大选等等。希望2021年会顺利。</p><p>我的年终总结也该动笔了。</p><hr><h4 id="12-17"><a href="#12-17" class="headerlink" title="12.17"></a>12.17</h4><p>收集。理清。整理。回顾。行动。</p><hr><h4 id="12-18"><a href="#12-18" class="headerlink" title="12.18"></a>12.18</h4><p>I got your six. <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">点我查看翻译  </button><span class="hide-content">我在你的六点钟反向，也就是「我为你殿后」</span></span></p><hr><h4 id="12-19"><a href="#12-19" class="headerlink" title="12.19"></a>12.19</h4><blockquote><p>听说神不能无处不在所以创造了妈妈 到了妈妈的年龄 妈妈仍然是妈妈的守护神 妈妈这个词只是叫一叫也触动心弦 妈妈依然力大无比 好不容易到了能够安慰妈妈的年龄时 已经太懂事了 真不好意思开口说 妈妈我爱你 现在想让妈妈高兴的话 就说 我现在需要妈妈 就这一句话就足够了。</p><p>—《请回答1988》</p></blockquote><hr><h4 id="12-20"><a href="#12-20" class="headerlink" title="12.20"></a>12.20</h4><blockquote><p>所谓爱一个人，不是宽裕了想要给予，而是恳切的必须给予。不是喜欢对方的体温，而是要跟对方的体温越来越接近。即便对方一直折磨你，你想要一直讨厌对方，但怎么也讨厌不起来。不是不讨厌，而是绝对不能讨厌。</p><p>—《请回答1988》</p></blockquote><p><a href="https://music.163.com/song?id=28068737&amp;userid=426533699">걱정말아요 그대（你不要担心）</a></p><hr><h4 id="12-21"><a href="#12-21" class="headerlink" title="12.21"></a>12.21</h4><p>// …</p><hr><h4 id="12-22"><a href="#12-22" class="headerlink" title="12.22"></a>12.22</h4><p>现实中不会有阿泽这样的人，阿泽只是为了这个故事编造出来的。</p><p>德善成年后会找到一个爱人，无意中发现曾经有人爱过自己，但是当时她却没有看清。正焕在成年后遇到初恋，也早已物是人非。</p><p>错过的，终究会错过。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.12/img/postImg/20201222.jpg" alt=""></p><hr><h4 id="12-23"><a href="#12-23" class="headerlink" title="12.23"></a>12.23</h4><p>// …</p><hr><h4 id="12-24"><a href="#12-24" class="headerlink" title="12.24"></a>12.24</h4><p>// …</p><hr><h4 id="12-25"><a href="#12-25" class="headerlink" title="12.25"></a>12.25</h4><p>同理心</p><hr><p>走迷宫诀窍：一直摸着左手边的墙，就一定可以走出去。</p><hr><h4 id="12-26"><a href="#12-26" class="headerlink" title="12.26"></a>12.26</h4><p>人世间没有那么多正确，说到底，大家就是在一起搭伙过日子罢了。</p><hr><h4 id="12-27"><a href="#12-27" class="headerlink" title="12.27"></a>12.27</h4><p>要获得世俗上的成功，除了运气外你需要两个步骤：</p><ol><li><p>做正确的事；</p></li><li><p>把事做正确。</p></li></ol><p>复利神话过于强调第二点，让人忽略第一点。</p><p>如果没有方向，任何方向的风都是逆风。</p><hr><h4 id="12-28"><a href="#12-28" class="headerlink" title="12.28"></a>12.28</h4><p>「世界上很多东西，无所谓优点和缺点，只有特点。」 -吴军</p><p>深入认识一个人的过程中，会经常发现，曾经我们最欣赏他的「最大优点」，其实并不是真的优点。</p><hr><p>人生，只要照亮某个角落就够了</p><hr><h4 id="12-29"><a href="#12-29" class="headerlink" title="12.29"></a>12.29</h4><p>// …</p><hr><h4 id="12-30"><a href="#12-30" class="headerlink" title="12.30"></a>12.30</h4><p>要准备期末考试了。</p><hr><p>有枣没枣打一杆子。</p><hr><h4 id="12-31"><a href="#12-31" class="headerlink" title="12.31"></a>12.31</h4><p>再见操蛋的2020！</p><hr>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日更 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>少有人走的路</title>
      <link href="/posts/1933258000/"/>
      <url>/posts/1933258000/</url>
      
        <content type="html"><![CDATA[<p>强烈向大家推荐这本书《少有人走的路》。</p><h3 id="自律"><a href="#自律" class="headerlink" title="自律"></a>自律</h3><p>健全心理的基本前提，自律的根基：「<strong>我是个有价值的人</strong>」。</p><p>自律的四原则：1. 解决问题 2.承担责任 3.尊重事实 4.保持平衡。</p><p>神经官能症：让自己痛苦。人格失调：让别人痛苦。人格神经官能症：都痛苦。</p><p>你不能解决问题，那么你就会成为问题。</p><p>作为成年人，整个一生都充满选择和决定的机会，接受则变为自由人。</p><p>尊重事实，绘制人生地图，难处不在于从头开始，而在于要<strong>不断修订</strong>，不要故步自封。</p><p>移情：抱残守缺，与现实脱节。坚守过时的观念，对现实漠然置之。</p><p>献身真理意味着自我反省，敢于接受其他「制图者」的挑战。</p><p>不讲白色/黑色谎言。更要限制性的表达个人意见。</p><p>在需要、目标、责任之间保持平衡。其最高原则就是「放弃」。但是先要确立自我，才能放弃自我。放弃固有人格、行为模式、人生理念。</p><h3 id="爱"><a href="#爱" class="headerlink" title="爱"></a>爱</h3><p>爱：为了促进自我和他人心智成熟，而具有的一种自我完善的<em>意愿</em>。</p><p>区别爱与不爱：1.当事人的意识思维和潜意识思维的目标是否一致。 2.爱是长期、渐进的过程 3.真正意义上的爱，是爱自己也是爱他人。 3.爱是自我完善也是帮他人完善。</p><p>爱是<strong>行动</strong>，不是空想。爱是一种客观的存在，不是头脑的主观意象。「非爱」的本质就是「懒惰」。</p><p>自我界限：分清楚什么是自己的事情，什么是别人的事情，并且各自承担着各自的责任。</p><p>坠入情网，只能使自我界限的某一部分发生暂时性崩溃。真正的爱，却可以使自我界限扩大，而且不再恢复原状。</p><p>真正的爱，是自我完善的特殊体验，跟自我界限有着密切的关系。</p><p>精神贯注：被自我界限之外的对象吸引，迫使我们产生冲动，想把激情乃至生命献给对方。</p><p>贯注是爱的起点。</p><p>依赖性。没有别人就无法生存，意味着你是个寄生者，而对方是寄主。你们的关系和感情没有自由的成分。</p><p>消极性依赖人格失调。只在乎别人为自己做什么，而不考虑自己为对方付出多少。</p><p>他们不在乎依赖的对象是谁，只要有人依赖即可。</p><p>我们看中的是宠物对我们的依赖性。=&gt;「战争新娘」。</p><p>培养某种特殊嗜好是自我滋润的有效手段。eg，爱惜身体、拥有充足的实物等。</p><p>真正的爱不包括单纯的给予，还包括<em>适当</em>的拒绝，<em>及时</em>的赞美，<em>得体</em>的批评，<em>恰当</em>的争论，<em>必要</em>的鼓励，<em>有效</em>的敦促。</p><p>爱的过分，还莫如不爱，该拒绝却一味给予，不是仁慈而是伤害。</p><p>爱绝不是无原则的接受，也包括<em>必要</em>的冲突，<em>果断</em>的拒绝，<em>严厉</em>的批评。</p><p><strong>爱——永远追求心智的成熟。</strong></p><p>爱的意愿的本质，其实是一种关注。体现关注，一种最常见，最重要的方式就是<strong>倾听</strong>。</p><p>勇气，不意味着不恐惧，而是面对恐惧也能坦然行动，克服畏惧心理。</p><p>我们应当坦然接受死亡，不妨把它当成「永远的伴侣」，想象它始终与我们并肩前行。</p><p>人生唯一的安全感，来自于充分体验人生的不安全感。</p><p>「你是我们所爱的孩子，你是可爱的人。无论你做什么，无论你成为什么样的人，只要你努力且敢于冒险，我们始终都会支持你、爱你。」</p><p>做出承诺，是真正的爱的基石之一。</p><p>真正具有爱的人，绝不会随意批评别人或与对方发生冲突。诚实和谦逊。</p><p>过于谦逊，总是三缄其口是不可以的。</p><p>爱的自律。如果将感情比作奴隶，那么自律就是奴隶的主人。想象幼儿学习画画，只是随意把色彩涂到纸上，表面看上去，也许倒也颇具吸引力，但是画面其实既单调又乏味，没有任何意义可言。他们不懂得控制、调节和改变，因此「画布」上没有任何色彩，也没有独特而丰富的内涵。真正的活力与热情，离不开深刻而真挚的情感。</p><p>爱与独立。</p><h3 id="成长与宗教"><a href="#成长与宗教" class="headerlink" title="成长与宗教"></a>成长与宗教</h3><p>//..</p><h3 id="神奇的力量"><a href="#神奇的力量" class="headerlink" title="神奇的力量"></a>神奇的力量</h3><p>弗洛伊德式「说漏嘴」会揭示出潜意识与我们沟通的渴望。</p><p>打开窗让甲虫飞进来，并一把抓住。潜意识会发生作用，但不是任何人都可以察觉并且抓住的。</p><p>懒惰的一个主要特征，就是恐惧感。爱是懒惰的对立面。</p><p>将自我延伸到新的领域，意味着接受新的责任，做出新的承诺，发展新的关系，达到新的层次，经受更大的风险。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib的常见用法</title>
      <link href="/posts/2004331048/"/>
      <url>/posts/2004331048/</url>
      
        <content type="html"><![CDATA[<h3 id="plt-subplots"><a href="#plt-subplots" class="headerlink" title="plt.subplots()"></a>plt.subplots()</h3><p>返回一个包含figure和axes对象的元组。因此，通常使用<code>fig,ax = plt.subplots()</code>将元组分解为fig和ax两个变量。</p><p>首先我们先介绍下Figure、Axes和Axis吧。具体区别看下官方的图。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/20201117_1.png" alt="图片来源[matplotlib](https://matplotlib.org/1.5.1/faq/usage_faq.html#parts-of-a-figure)"></p><p>Figure是整个「画板」，也就是红色的框。在上边可以画多个图像（Axes），也就是蓝色的框。而蓝色的框才是具体的坐标轴（Axis）。</p><p>Axes是Axis的复数，Axes在这里指的是一套坐标轴，而Axis才是指的具体单个坐标轴。何为「一套坐标轴」、「单个坐标轴」呢？有人这么说：</p><blockquote><p>Axis 指 x、y 坐标轴等（如果有三维那就还有 z 轴），代表的是 “坐标轴”。而 Axes 在英文里是 Axis 的复数形式，也就是说 axes 代表的其实是 figure 当中的一套坐标轴。之所以说一套而不是两个坐标轴，是因为如果你画三维的图，axes 就代表 3 根坐标轴了。所以，在一个 figure 当中，每添加一次 subplot ，其实就是添加了一套坐标轴，也就是添加了一个 axes，放在二维坐标里就是你添加了两根坐标轴，分别是 x 轴和 y 轴。所以当你只画一个图的时候，plt.xxx 与 ax.xxx 其实都是作用在相同的图上的。</p></blockquote><p>为了加深理解，再看一个图。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/20201117_2.png" alt=""></p><p>值得注意的是，当只有一个Axes时，<code>plt.plot()</code>和 <code>ax.plot()</code> 是作用在同一张图上。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>octave for Mac安装、使用</title>
      <link href="/posts/1009752504/"/>
      <url>/posts/1009752504/</url>
      
        <content type="html"><![CDATA[<h2 id="安装octave"><a href="#安装octave" class="headerlink" title="安装octave"></a>安装octave</h2><p>首先，你的Mac上要安装好<code>Homebrew</code>。如果你不知道你的电脑装没装<code>Homebrew</code>，那你可以运行命令<code>brew -v</code>。如果显示下图则说明已经安装过。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/20201111_1.png" alt=""></p><p>如果没有的话，运行这条命令安装<code>Homebrew</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;bin&#x2F;bash -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install.sh)&quot;</span><br></pre></td></tr></table></figure><p>也可以去<a href="https://brew.sh">Homebrew官网</a>了解下。官网的介绍很明白。</p><p>下面直接运行命令<code>brew install octave</code>，然后等待安装完即可。整个安装过程可能很长，耐心。</p><hr><h2 id="octave基本使用"><a href="#octave基本使用" class="headerlink" title="octave基本使用"></a>octave基本使用</h2><p><a href="https://www.gnu.org/software/octave/">GUN Octave官网</a>是这么介绍的，Octave是一门专门用于科学计算编程的语言（Scientific Programming Language）。</p><blockquote><p>GUN Octave 是一门最初被发明用于数值计算的高级语言，它使用一种与Matlab几乎完全兼容的语言，为解决数字上线性和非线性问题、执行其他数值实验提供了方便的命令行界面（Command Line Interface, 简称CLI）。Octave有大量的可以用于解决常见数值线性代数问题，求解非线性方程，求得普通函数的积分，处理多项式，求得普通微分和微分代数方程积分的工具。它也非常易于通过用户用Octave自带语言编写的自定义函数，或使用由C，C++和其他语言编写的动态加载模块来进行扩展和定制。</p></blockquote><p>下面介绍下octave的基本用法。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><blockquote><p>注：一般用大写字母表示矩阵（matrix），小写字母表示向量（vector）。</p></blockquote><p><code>V = [1, 2 ; 3, 4]</code>。生成矩阵。</p><p><code>V = 1 : 0.1 : 2</code></p><p><code>ones(2, 3)</code></p><p><code>zeros(2, 3)</code></p><p><code>rand(2, 3)</code></p><p><code>randn(2, 3)</code></p><p><code>hist(V)</code></p><p><code>hist(V, 50)</code></p><p><code>eye(4)</code></p><p><code>help</code></p><h3 id="移动数据"><a href="#移动数据" class="headerlink" title="移动数据"></a>移动数据</h3><p><code>size(A)</code></p><p><code>size(A, 1)</code></p><p><code>length(A)</code></p><p><code>load</code></p><p><code>who</code></p><p><code>whos</code></p><p><code>clear</code></p><p><code>V = priceY(1 : 10)</code></p><p><code>save hello.mat V</code></p><p><code>save hello.txt V -ascii</code></p><p><code>A(3, 2)</code></p><p><code>A(2, : )</code></p><p><code>A([1 3], : )</code></p><p><code>A( : , 2) = [10; 11; 12]</code></p><p><code>A[A, [100 : 200 : 300]]</code></p><p><code>A( : )</code></p><p><code>C = [A B]</code></p><p><code>C = [A; B]</code></p><h3 id="计算数据"><a href="#计算数据" class="headerlink" title="计算数据"></a>计算数据</h3><p><code>A * B</code></p><p><code>A .* B</code></p><p><code>A .^ B</code></p><p><code>1 ./ A</code></p><p><code>log(A)</code></p><p><code>exp(A)</code></p><p><code>abs(A)</code></p><p><code>-V</code></p><p><code>V + 1</code></p><p><code>A&#39;</code></p><p><code>val = max(a)</code></p><p><code>[val, ind] = max(a)</code></p><p><code>max(A)</code></p><p><code>a &lt; 3</code></p><p><code>find(a &lt; 3)</code></p><p><code>[r, c] = find(A &gt; 0.7)</code></p><p><code>sum(a)</code></p><p><code>prod(a)</code></p><p><code>floor(a)</code></p><p><code>ceil(a)</code></p><p><code>max(rand(3), rand(3))</code></p><p><code>max(A, [], 1)</code></p><p><code>max(max(A))</code></p><p><code>sum(A, 1)</code></p><p><code>flipud(A)</code></p><p><code>pinv(A)</code></p><h3 id="数据绘制"><a href="#数据绘制" class="headerlink" title="数据绘制"></a>数据绘制</h3><p><code>plot(x, y)</code></p><p><code>hold on;</code></p><p><code>xlable(&#39;time&#39;)</code></p><p><code>legend(&#39;sin&#39;, cos&#39;&#39;)</code></p><p><code>title(&#39;my plot&#39;)</code></p><p><code>print -dpng &#39;myplot.png&#39;</code></p><p><code>close</code></p><p><code>figure(1); plot(t, y1);</code></p><p><code>subplot(1, 2, 1);</code></p><p><code>axis([0.5 1 -1 1])</code></p><p><code>clf</code></p><p><code>imggesc(A)</code></p><p><code>imagesc(A), colorbar, colormap gray;</code></p><h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贰零贰零年十一月</title>
      <link href="/posts/3096828/"/>
      <url>/posts/3096828/</url>
      
        <content type="html"><![CDATA[<h4 id="11-01"><a href="#11-01" class="headerlink" title="11.01"></a>11.01</h4><p>到了最后一步，一定要「不要脸，不要钱，不要命」，懂这九个字，大多数事情都有机会去做。</p><p><br /></p><p><strong>当孩子的学识和见识远超父母的时候，亲子相处模式就应该做出相应的调整。</strong></p><p><strong>父母应该停止对孩子的人生提供一些孩子根本就不会遵从的建议，而应该把孩子当做资源，向孩子咨询自己的人生困惑，这才是孩子回报父母的方式。</strong></p><hr><h4 id="11-02"><a href="#11-02" class="headerlink" title="11.02"></a>11.02</h4><p>注释应该是注释Why，而不是How和What。</p><hr><h4 id="11-03"><a href="#11-03" class="headerlink" title="11.03"></a>11.03</h4><p>摸鱼结束。</p><hr><h4 id="11-04"><a href="#11-04" class="headerlink" title="11.04"></a>11.04</h4><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.3/img/postImg/jilu/20201104.jpeg" alt=""></p><hr><h4 id="11-05"><a href="#11-05" class="headerlink" title="11.05"></a>11.05</h4><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.3/img/postImg/jilu/20201105.jpeg" alt=""></p><hr><h4 id="11-06"><a href="#11-06" class="headerlink" title="11.06"></a>11.06</h4><p>不要等一件事情做不下去了，才开始准备。</p><hr><h4 id="11-07"><a href="#11-07" class="headerlink" title="11.07"></a>11.07</h4><p>「What I cannot create, I do not understand.」</p><p>只有创造一个东西，才算真正弄懂一个问题。</p><hr><h4 id="11-08"><a href="#11-08" class="headerlink" title="11.08"></a>11.08</h4><p>//…</p><hr><h4 id="11-09"><a href="#11-09" class="headerlink" title="11.09"></a>11.09</h4><p>《风声》。</p><hr><h4 id="11-10"><a href="#11-10" class="headerlink" title="11.10"></a>11.10</h4><p>现在已经找不到大一时做编程题的感觉了。可以静下心来半天、一天甚至是一周来想解法。现在浮躁的很。</p><hr><h4 id="11-11"><a href="#11-11" class="headerlink" title="11.11"></a>11.11</h4><p>不要网贷。找熟人借钱会觉得不好意思。网贷就没有这个阻碍，反而还可能会加剧网贷频率。而且，还钱还有个延后期，会有个「寒号鸟」效应。</p><blockquote><p>「寒号鸟」的故事：</p><p>山脚下有一堵石崖，崖上有一道缝，寒号鸟就把这道缝当作自己的窝。石崖前面有一条河，河边有一棵大杨树，杨树上住着喜鹊。寒号鸟和喜鹊面对面住着，成了邻居。</p><p>几阵秋风，树叶落尽，冬天快要到了。</p><p>有一天，天气晴朗。喜鹊一早飞出去，东寻西找，衔回来一些枯草，就忙着做窝，准备过冬。寒号鸟却整天出去玩，累了就回来睡觉。喜鹊说：“寒号鸟，别睡了，大好晴天，赶快做窝。”</p><p>寒号鸟不听劝告，躺在崖缝里对喜鹊说：“傻喜鹊，不要吵，太阳高照，正好睡觉。”</p><p>冬天说到就到，寒风呼呼地刮着。喜鹊住在温暖的窝里。寒号鸟在崖缝里冻得直打哆嗦，不停地叫着：“哆啰啰，哆啰啰，寒风冻死我，明天就做窝。”</p><p>第二天清早，风停了，太阳暖暖的，好像又是春天了。喜鹊来到崖缝前劝寒号鸟：“趁天晴，快做窝，现在懒惰，将来难过。”</p><p>寒号鸟还是不听劝告，伸伸懒腰，答道：“傻喜鹊，别啰嗦，天气暖和，得过且过。”</p><p>寒冬腊月，大雪纷飞。北风像狮子一样狂吼，崖缝里冷得像冰窖。寒号鸟重复着哀号：“哆啰啰，哆啰啰，寒风冻死我，明天就做窝。”</p><p>天亮了，太阳出来了，喜鹊在枝头呼唤寒号鸟。可是，寒号鸟已经在夜里冻死了。</p></blockquote><p>要认真对待生活，不能得过且过，更不能懒惰，否则后果不堪设想。</p><hr><h4 id="11-12"><a href="#11-12" class="headerlink" title="11.12"></a>11.12</h4><p>//…</p><hr><h4 id="11-13"><a href="#11-13" class="headerlink" title="11.13"></a>11.13</h4><p>做事不要愣头青似的往前冲。首先要考虑战略，战略最重要的一项就是时间加成，要日复一日，每天进步一点点。</p><hr><h4 id="11-14"><a href="#11-14" class="headerlink" title="11.14"></a>11.14</h4><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.3/img/postImg/jilu/20201114.jpeg" alt=""></p><hr><h4 id="11-15"><a href="#11-15" class="headerlink" title="11.15"></a>11.15</h4><p>《Band of Brothers》</p><p><br /></p><p>Permission to be human.</p><p>Nature to be comanded must to be obeyed.</p><p>Expression rather than impression.</p><hr><h4 id="11-16"><a href="#11-16" class="headerlink" title="11.16"></a>11.16</h4><p>孙子兵法中，计谋的计是算计的计。开打之前先计算打胜的概率。胜算远大于失败，就All In压倒性投入去打，争取获得压倒性成功。</p><p><br /></p><p>英国哲学家罗素说，人类友谊天长地久是一个谎言，必须建立在三个理性前提下：<strong><em>平等的感情、相似的价值观和交集的生活体验</em></strong>。</p><p><br /></p><p><strong><em>救急不救穷。</em></strong></p><hr><h4 id="11-17"><a href="#11-17" class="headerlink" title="11.17"></a>11.17</h4><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.3/img/postImg/jilu/20201117.jpeg" alt=""></p><hr><h4 id="11-18"><a href="#11-18" class="headerlink" title="11.18"></a>11.18</h4><p>Great minds discuss ideas（伟人谈论想法）</p><p>Average minds discuss events（普通人谈论事件）</p><p>Small minds discuss people（庸人谈论他人）</p><p><br /></p><p>《教父》里的人生观：第一步要努力实现自我价值，第二步要全力照顾好家人，第三步要尽可能帮助善良的人，第四步为族群发声，第五步为国家争荣誉。事实上作为男人，前两步成功，人生已算得上圆满，做到第三步堪称伟大，而随意颠倒次序的那些人，一般不值得信任。修身齐家治国平天下。</p><hr><h4 id="11-19"><a href="#11-19" class="headerlink" title="11.19"></a>11.19</h4><p>// …</p><hr><h4 id="11-20"><a href="#11-20" class="headerlink" title="11.20"></a>11.20</h4><p>// …</p><hr><h4 id="11-21"><a href="#11-21" class="headerlink" title="11.21"></a>11.21</h4><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.3/img/postImg/jilu/20201121.png" alt=""></p><hr><h4 id="11-22"><a href="#11-22" class="headerlink" title="11.22"></a>11.22</h4><p>// …</p><hr><h4 id="11-23"><a href="#11-23" class="headerlink" title="11.23"></a>11.23</h4><p>all that is real is rational and all that is rational is real.</p><hr><h4 id="11-24"><a href="#11-24" class="headerlink" title="11.24"></a>11.24</h4><p>King of Omniscience 懂王</p><hr><h4 id="11-25"><a href="#11-25" class="headerlink" title="11.25"></a>11.25</h4><p>Man is born free, but he is everywhere in chains.</p><p>人生而自由，却又无往不在枷锁之中。</p><p>— Jean-Jacques Rousseau  卢梭</p><hr><h4 id="11-26"><a href="#11-26" class="headerlink" title="11.26"></a>11.26</h4><p>好文：《<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md">提问的智慧</a>》</p><hr><h4 id="11-27"><a href="#11-27" class="headerlink" title="11.27"></a>11.27</h4><p>People learn when they’re surprised.</p><hr><h4 id="11-28-11-30"><a href="#11-28-11-30" class="headerlink" title="11.28 - 11.30"></a>11.28 - 11.30</h4><p>网站换了新模板，还没全部迁移完。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日更 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题「哈希表」相关</title>
      <link href="/posts/2387435811/"/>
      <url>/posts/2387435811/</url>
      
        <content type="html"><![CDATA[<h4 id="数组中两个数的和为给定值（简单）"><a href="#数组中两个数的和为给定值（简单）" class="headerlink" title="数组中两个数的和为给定值（简单）"></a><a href="https://leetcode-cn.com/problems/two-sum/description/">数组中两个数的和为给定值（简单）</a></h4><p>暴力算法在这里就不讲了。</p><p>这里介绍下用「哈希表」来解决此题。</p><p>为什么会想到哈希表呢？这是因为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(n)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;(<span class="keyword">int</span>) map.get(n), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>时间复杂度：O()。</p><p>空间复杂度：O()。</p><hr><h4 id="判断数组是否含有重复元素（简单）"><a href="#判断数组是否含有重复元素（简单）" class="headerlink" title="判断数组是否含有重复元素（简单）"></a><a href="https://leetcode-cn.com/problems/contains-duplicate/description/">判断数组是否含有重复元素（简单）</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashmap.containsKey(nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hashmap.put(nums[i], <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>时间复杂度：O()。</p><p>空间复杂度：O()。</p><hr><h4 id="最长和谐序列（简单）"><a href="#最长和谐序列（简单）" class="headerlink" title="最长和谐序列（简单）"></a><a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/description/">最长和谐序列（简单）</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            hashMap.put(num, hashMap.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key : hashMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashMap.containsKey(key + <span class="number">1</span>)) &#123;</span><br><span class="line">                ret = Math.max(ret, hashMap.get(key) + hashMap.get(key + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>时间复杂度：O()。</p><p>空间复杂度：O()。</p><hr><h4 id="最长连续序列（困难）"><a href="#最长连续序列（困难）" class="headerlink" title="最长连续序列（困难）"></a><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/description/">最长连续序列（困难）</a></h4><p>复杂度分析：</p><p>时间复杂度：O()。</p><p>空间复杂度：O()。</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode 刷题之数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题「栈和队列」相关</title>
      <link href="/posts/1477059771/"/>
      <url>/posts/1477059771/</url>
      
        <content type="html"><![CDATA[<h4 id="用栈实现队列（简单）"><a href="#用栈实现队列（简单）" class="headerlink" title="用栈实现队列（简单）"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/description/">用栈实现队列（简单）</a></h4><p>栈的特点是「先进后出」。队列的特点是「先进先出」。现在要求使用<em>后进先出</em>的栈实现一个<em>先进先出</em>的队列。也就是要保证栈顶的元素始终是队首的元素。</p><p>方法一：</p><p>我们可以用两个栈来实现。其中一个栈用来存储数据，我们称为「数据栈」，另外一个栈用来辅助将数据倒序<code>push</code>进第一个栈的，我们称为「辅助栈」。因为，这样可以让数据栈的数据保持新来的数一直在栈顶，这样可以实现「先进先出」。</p><p>画图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/leetcoding/stackAndQueue/1_1.jpeg" alt=""></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 数据栈</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        <span class="comment"># 辅助栈</span></span><br><span class="line">        self.stack2 = []</span><br><span class="line">        <span class="comment"># 数据的个数，用来指向栈顶元素</span></span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Push element x to the back of queue.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 先把数据栈里的数据放到辅助栈</span></span><br><span class="line">        <span class="keyword">while</span> self.stack1:</span><br><span class="line">            self.stack2.append(self.stack1.pop())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在数据栈中压入新来的数</span></span><br><span class="line">        self.stack2.append(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 再将辅助栈的数据放回数据栈</span></span><br><span class="line">        <span class="keyword">while</span> self.stack2:</span><br><span class="line">            self.stack1.append(self.stack2.pop())</span><br><span class="line"></span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.stack1.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the front element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.stack1 != []:</span><br><span class="line">            <span class="keyword">return</span> self.stack1[self.size - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns whether the queue is empty.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.stack1 == []</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>时间复杂度：入队O(n)，出队O(1)，取队首元素O(1)，判空O(1)。</p><p>空间复杂度：入队O(n)，出队O(1)，取队首元素O(1)，判空O(1)。</p><p>方法二：</p><p>还是使用两个栈，只不过现在两个栈中都存放数据。两个栈的区别是，只有当出栈<code>pop</code>时，才把<code>stack1</code>的数据放到<code>stack2</code>中，然后<code>return stack2.pop()</code>。为了实现<code>peek</code>方法，同时还要维护一个<code>front</code>变量，使其一直指向<code>stack1</code>的栈底元素，因为只是peek一下，所以不用像<code>pop</code>那样将<code>stack1</code>的数据移动到<code>stack2</code>中，这样可在O(1)的复杂度实现<code>peek</code>方法。</p><p>画图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/leetcoding/stackAndQueue/1_2.jpeg" alt=""></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line">        self.sizeOfStack2 = <span class="number">0</span></span><br><span class="line">        self.front = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Push element x to the back of queue.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 如果stack1空，则</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack1:</span><br><span class="line">            self.front = x</span><br><span class="line">        self.stack1.append(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">                self.sizeOfStack2 += <span class="number">1</span></span><br><span class="line">        self.sizeOfStack2 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the front element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 如果stack2不为空，就直接返回其栈顶元素</span></span><br><span class="line">        <span class="keyword">if</span> self.stack2:</span><br><span class="line">            <span class="keyword">return</span> self.stack2[self.sizeOfStack2 - <span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 如果为空，因为只是peek一下，所以不用将stack1的数据转移到stack2中，直接返回维护好的front即可。</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.front</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns whether the queue is empty.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.stack1 == [] <span class="keyword">and</span> self.stack2 == []</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>时间复杂度：入队O(1)，出队均摊复杂度O(1)，取队首元素O(1)，判空O(1)。</p><p>空间复杂度：入队O(n)，出队O(1)，取队首元素O(1)，判空O(1)。</p><hr><h4 id="用队列实现栈（简单）"><a href="#用队列实现栈（简单）" class="headerlink" title="用队列实现栈（简单）"></a><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/description/">用队列实现栈（简单）</a></h4><p>要用队列来实现栈的特性，就是要保证队首的元素始终是栈顶的元素。</p><p>可以用两个队列来实现，一个是数据队列，一个是辅助队列。辅助队列的作用是在将新元素入数据队列前，先将数据队列数据移动到辅助队列，然后数据队列入队新元素，最后将辅助队列里的数据移动回数据队列。</p><p>但是，仔细观察整个过程可以发现，只需要一个队列就可以实现。首先将新元素入队，并且假设新元素所在位置为<code>n</code>。然后将前<code>n-1</code>个元素出队再入队。</p><p>画图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/leetcoding/stackAndQueue/1_3.jpeg" alt=""></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.l1 = collections.deque()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Push element x onto stack.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(self.l1)</span><br><span class="line">        <span class="comment"># 将新元素入队</span></span><br><span class="line">        self.l1.append(x)</span><br><span class="line">        <span class="comment"># 将前n-1个元素出队再入队</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            self.l1.append(self.l1.popleft())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes the element on top of the stack and returns that element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.l1.popleft()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the top element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.l1[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns whether the stack is empty.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.l1</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>时间复杂度：入栈O(n)，出栈O(1)，取栈顶元素O(1)，判空O(1)。</p><p>空间复杂度：入栈O(n)，出栈O(1)，取栈顶元素O(1)，判空O(1)。</p><hr><h4 id="最小值栈（简单）"><a href="#最小值栈（简单）" class="headerlink" title="最小值栈（简单）"></a><a href="https://leetcode-cn.com/problems/min-stack/description/">最小值栈（简单）</a></h4><p>为了能在常数时间内检索到栈内的最小元素，我们需要借助另外一个辅助栈来存储每次栈操作（push、pop、peek）后的最小值。</p><p>每次入栈都要检查辅助栈的栈顶元素和新入栈的元素谁更小，然后将小值入辅助栈。出栈只需要将两个栈同时出栈一个元素即可。</p><p>画图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/leetcoding/stackAndQueue/1_4.jpeg" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; xStack;</span><br><span class="line">    Deque&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        xStack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        minStack.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        xStack.push(x);</span><br><span class="line">        minStack.push(Math.min(minStack.peek(), x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        xStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> xStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>时间复杂度：O(1)，每个操作最多调用两次栈操作。</p><p>空间复杂度：O(n)。</p><hr><h4 id="用栈实现括号匹配（简单）"><a href="#用栈实现括号匹配（简单）" class="headerlink" title="用栈实现括号匹配（简单）"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/description/">用栈实现括号匹配（简单）</a></h4><p>可以借助栈的先进后出特性来解此题。</p><p>只要是<code>左括号</code>就入栈，如果是<code>右括号</code>则出栈一个元素，并且判断两者是否是一对，如果是一对，则继续处理下一个字符，否则括号不匹配<code>return false</code>。处理完所有括号以后，如果栈不空，则说明还有左括号没有配对<code>return false</code>。否则<code>return true</code>。</p><p>画图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/leetcoding/stackAndQueue/1_5.jpeg" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack &lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> cTop = stack.pop();</span><br><span class="line">                <span class="keyword">boolean</span> r1 = c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; cTop != <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">                <span class="keyword">boolean</span> r2 = c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; cTop != <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">                <span class="keyword">boolean</span> r3 = c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; cTop != <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(r1 || r2 || r3) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>时间复杂度：O(n)。</p><p>空间复杂度：O(n)。</p><hr><h4 id="数组中元素与下一个比它大的元素之间的距离（中等）"><a href="#数组中元素与下一个比它大的元素之间的距离（中等）" class="headerlink" title="数组中元素与下一个比它大的元素之间的距离（中等）"></a><a href="https://leetcode-cn.com/problems/daily-temperatures/description/">数组中元素与下一个比它大的元素之间的距离（中等）</a></h4><p>这题可以用「单调栈」求解。所谓单调栈就是，通过一些巧妙地处理，使每次入栈操作后栈内元素都保持有序（单调递增、递减的）。单调栈通常用来处理<code>Next Greater Element</code>问题。</p><p>假设数据为[2, 4, 1, 3, 5]。我们可以将这组数据想象成<code>五个不同身高的人并列站立</code>，他们的身高分别为<code>2</code>，<code>4</code>，<code>1</code>，<code>3</code>，<code>5</code>。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/leetcoding/stackAndQueue/1_6.jpeg" alt=""></p><p>矮个子右边第一个高个子会挡住矮个子的视线。我们现在想求<code>2</code>的<code>Next Greater Element</code>，该怎么办呢？只需要看<code>2</code>右边谁第一个个子比他高那就是谁。显然第一个高个子是<code>4</code>。所以<code>2</code>的<code>Next Greater Element</code>就是<code>4</code>。同理，<code>4</code>的<code>Next Greater Element</code>就是<code>5</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = T.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.isEmpty() &amp;&amp; s.peek() &lt;= T[i]) &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ret[i] = s.isEmpty() ? -<span class="number">1</span> : s.peek();</span><br><span class="line">            s.push(T[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别急接着往下看。</p><p>为了提高代码执行效率，我们应该「从右往左」处理数据，这好像有点「预测未来」的感觉，就是提前知道了谁比你高，不用去一个个的和下一个比。</p><p>代码中我们借助了栈这种先进后出的数据结构。并且将数据倒着入栈。while循环可以帮助我们将两个高个子之间的矮个子排除掉。通过这些可以保证栈里的数据按照「高个在下，矮个在上」排序。</p><p>画图如下:</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/leetcoding/stackAndQueue/1_7.jpeg" alt=""></p><p>可以按照上图一步一步的走一遍，加深理解。</p><p>对于本题，思路和上面一样，就是入栈的不是数值，而是下标，这点要注意区分。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = T.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.isEmpty() &amp;&amp; T[s.peek()] &lt;= T[i]) &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ret[i] = s.isEmpty() ? <span class="number">0</span> : s.peek() - i;</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>时间复杂度：O(n)。不要看到这里有嵌套循环就觉得应该是O(n^2)的复杂度。其实对于内层的while循环，最多执行<code>数组长度</code>遍，每个元素入栈一次，但是出栈最多一次。</p><p>空间复杂度：O(n)。</p><hr><h4 id="循环数组中比当前元素大的下一个元素（中等）"><a href="#循环数组中比当前元素大的下一个元素（中等）" class="headerlink" title="循环数组中比当前元素大的下一个元素（中等）"></a><a href="https://leetcode-cn.com/problems/next-greater-element-ii/description/">循环数组中比当前元素大的下一个元素（中等）</a></h4><p>这题大概的思路还是用单调栈来处理，但是对于循环数组，该怎么处理呢？比如对于循环数组[1, 2, 1]，末尾的<code>1</code>通过绕一圈才找到<code>Next Greater Element</code>2。</p><p>对于这题，可以想到将数组长度翻倍变为[1, 2, 1, 1, 2, 1]，然后直接套用上题解法得到结果数组<code>ret=[2, -1, 2, 2, -1, -1]</code>然后取前3位即可。</p><p>然而一般我们对于循环数组，可以用「取余」操作来处理循环，从而模拟了数组长度翻倍的效果。</p><hr><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[l];</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span> * l - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.isEmpty() &amp;&amp; s.peek() &lt;= nums[i % l]) &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ret[i % l] = s.isEmpty() ? -<span class="number">1</span> : s.peek();</span><br><span class="line">            s.push(nums[i % l]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>时间复杂度：O(n)。</p><p>空间复杂度：O(n)。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode 刷题之数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈和队列 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题「数组与矩阵」相关</title>
      <link href="/posts/369926292/"/>
      <url>/posts/369926292/</url>
      
        <content type="html"><![CDATA[<h4 id="把数组中的0移到末尾（简单）"><a href="#把数组中的0移到末尾（简单）" class="headerlink" title="把数组中的0移到末尾（简单）"></a><a href="https://leetcode-cn.com/problems/move-zeroes/description/">把数组中的0移到末尾（简单）</a></h4><p>暴力解法就不说了。下面介绍下双指针的思路。</p><p>现在的思路就是我们假想又开辟了一个新的数组，但是这个新数组和原数组占用同一片空间。也就是我们让原数组具有「双重人格」。一会表示原数组，一会表示我们假想的新数组。</p><p>新数组的内容为原数组中的非零元素。并保持相对顺序。由指针<code>lastNonZeroFoundAt</code>来控制新数组。</p><p>两个指针，一个用来遍历原数组，一个<code>lastNonZeroFoundAt</code>用来操作新数组，初始值为0。</p><p>程序开始，当我们遍历到一个非零元素就将该元素赋值给<code>nums[lastNonZeroFoundAt]</code>，然后<code>lastNonZeroFoundAt ++</code>。</p><p>最后，将新数组的非零元素后面填充0。这里我们并没有将0移动，我们移动的是非零元素。所以将非零元素移到前面以后，后面的就是0。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastNonZeroFoundAt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[lastNonZeroFoundAt] = nums[i];</span><br><span class="line">                lastNonZeroFoundAt ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lastNonZeroFoundAt; i &lt; nums.length; ++ i) &#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>时间复杂度：O(n)。</p><p>空间复杂度：O(1)。</p><p>在此基础上在简便一点。我们同时移动非零元素和0。</p><p>同样是两个指针。现在一个快一个慢。当快的遇到非零元素时就和慢的交换元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> lastNonZeroFoundAt = <span class="number">0</span>, cur = <span class="number">0</span>; cur &lt; nums.length; ++ cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[cur] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = nums[lastNonZeroFoundAt];</span><br><span class="line">                nums[lastNonZeroFoundAt] = nums[cur];</span><br><span class="line">                nums[cur] = t;</span><br><span class="line">                lastNonZeroFoundAt ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>时间复杂度：O(n)。</p><p>空间复杂度：O(1)。</p><hr><h4 id="改变矩阵维度（简单）"><a href="#改变矩阵维度（简单）" class="headerlink" title="改变矩阵维度（简单）"></a><a href="https://leetcode-cn.com/problems/reshape-the-matrix/description/">改变矩阵维度（简单）</a></h4><p>简单的方法是，通过一个队列来将数组内容全部取出，然后再按照要求填入到新数组中。这个方法我就不写代码了，很容易想到。</p><p>除了上述方法，我们还可以通过控制数组下标来解决这个问题。我们引入一个新的变量<code>count</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] matrixReshape(<span class="keyword">int</span>[][] nums, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">int</span> m, n;</span><br><span class="line">        m = nums.length;;</span><br><span class="line">        n = nums[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (m * n != r * c || m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[r][c];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) &#123;</span><br><span class="line">                res[count / c][count % c] = nums[i][j];</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>时间复杂度：O(m * n)。</p><p>空间复杂度：O(m * n)。</p><hr><h4 id="找出数组中最长的连续-1（简单）"><a href="#找出数组中最长的连续-1（简单）" class="headerlink" title="找出数组中最长的连续 1（简单）"></a><a href="https://leetcode-cn.com/problems/max-consecutive-ones/description/">找出数组中最长的连续 1（简单）</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxCount = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxCount = Math.max(count, maxCount);</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(count, maxCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>时间复杂度：O(n)。</p><p>空间复杂度：O(1)。</p><hr><h4 id="有序矩阵查找（中等）"><a href="#有序矩阵查找（中等）" class="headerlink" title="有序矩阵查找（中等）"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/description/">有序矩阵查找（中等）</a></h4><p>复杂度分析：</p><p>时间复杂度：O()。</p><p>空间复杂度：O()。</p><hr><h4 id="找出数组中最长的连续-1（简单）-1"><a href="#找出数组中最长的连续-1（简单）-1" class="headerlink" title="找出数组中最长的连续 1（简单）"></a><a href="https://leetcode-cn.com/problems/max-consecutive-ones/description/">找出数组中最长的连续 1（简单）</a></h4><p>复杂度分析：</p><p>时间复杂度：O()。</p><p>空间复杂度：O()。</p><hr><h4 id="找出数组中最长的连续-1（简单）-2"><a href="#找出数组中最长的连续-1（简单）-2" class="headerlink" title="找出数组中最长的连续 1（简单）"></a><a href="https://leetcode-cn.com/problems/max-consecutive-ones/description/">找出数组中最长的连续 1（简单）</a></h4><p>复杂度分析：</p><p>时间复杂度：O()。</p><p>空间复杂度：O()。</p><hr><h4 id="找出数组中最长的连续-1（简单）-3"><a href="#找出数组中最长的连续-1（简单）-3" class="headerlink" title="找出数组中最长的连续 1（简单）"></a><a href="https://leetcode-cn.com/problems/max-consecutive-ones/description/">找出数组中最长的连续 1（简单）</a></h4><p>复杂度分析：</p><p>时间复杂度：O()。</p><p>空间复杂度：O()。</p><hr><h4 id="找出数组中最长的连续-1（简单）-4"><a href="#找出数组中最长的连续-1（简单）-4" class="headerlink" title="找出数组中最长的连续 1（简单）"></a><a href="https://leetcode-cn.com/problems/max-consecutive-ones/description/">找出数组中最长的连续 1（简单）</a></h4><p>复杂度分析：</p><p>时间复杂度：O()。</p><p>空间复杂度：O()。</p><hr><h4 id="找出数组中最长的连续-1（简单）-5"><a href="#找出数组中最长的连续-1（简单）-5" class="headerlink" title="找出数组中最长的连续 1（简单）"></a><a href="https://leetcode-cn.com/problems/max-consecutive-ones/description/">找出数组中最长的连续 1（简单）</a></h4><p>复杂度分析：</p><p>时间复杂度：O()。</p><p>空间复杂度：O()。</p><hr><h4 id="找出数组中最长的连续-1（简单）-6"><a href="#找出数组中最长的连续-1（简单）-6" class="headerlink" title="找出数组中最长的连续 1（简单）"></a><a href="https://leetcode-cn.com/problems/max-consecutive-ones/description/">找出数组中最长的连续 1（简单）</a></h4><p>复杂度分析：</p><p>时间复杂度：O()。</p><p>空间复杂度：O()。</p><hr><h4 id="找出数组中最长的连续-1（简单）-7"><a href="#找出数组中最长的连续-1（简单）-7" class="headerlink" title="找出数组中最长的连续 1（简单）"></a><a href="https://leetcode-cn.com/problems/max-consecutive-ones/description/">找出数组中最长的连续 1（简单）</a></h4><p>复杂度分析：</p><p>时间复杂度：O()。</p><p>空间复杂度：O()。</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode 刷题之数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组与矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题「树」相关</title>
      <link href="/posts/494471984/"/>
      <url>/posts/494471984/</url>
      
        <content type="html"><![CDATA[<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="树的高度（简单）"><a href="#树的高度（简单）" class="headerlink" title="树的高度（简单）"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/">树的高度（简单）</a></h4><p>采用深度优先遍历。</p><p>当<code>root is None</code>时，则<code>return 0</code>。</p><p>否则，返回左、右子树深度的最大值 + 1。</p><p>如果当前结点为空，则其高度为0。否则，就分别求其左、右子树的高度，然后取两个高度中的最大值 ，加1, 就是当前结点的高度。</p><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">Python</button></li><li class="tab"><button type="button" data-href="#1-2">Java</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxDepth(self, root: TreeNode) -&gt; int:</span><br><span class="line">        return 0 if not root else max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="平衡二叉树（简单）"><a href="#平衡二叉树（简单）" class="headerlink" title="平衡二叉树（简单）"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/description/">平衡二叉树（简单）</a></h4><p>平衡二叉树：一个二叉树每个节点的左、右两个子树的高度差的绝对值不超过 1 。</p><p>空树也是平衡树（左、右子树的高度差为0）。</p><p>若不空，则计算当前节点左、右子树的高度差，如果高度差的绝对值不超过1，则平衡，否则不平衡。<br><div class="tabs" id="2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2-1">Python</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isBalanced(self, root: TreeNode) -&gt; bool:</span><br><span class="line">        def height(root: TreeNode) -&gt; int:</span><br><span class="line">            if not root:</span><br><span class="line">                return 0</span><br><span class="line">            return max(height(root.left), height(root.right)) + 1</span><br><span class="line"></span><br><span class="line">        if not root:</span><br><span class="line">            return True</span><br><span class="line">        return abs(height(root.left) - height(root.right)) &lt;&#x3D; 1 and self.isBalanced(root.left) and self.isBalanced(root.right)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><p>下面提供另一种解法。</p><p>分别求左、右子树的高度，然后判断左、右子树的高度差。以及左、右子树的高度是否等于-1（-1的由来：如果当前结点的孩子节点的左、右子树的高度差大于1，那么就会返回-1）。</p><p>最后，判断根节点的高度是不是大于等于0。因为只要是树中有一个结点不是平衡树，则整棵树就不是平衡树。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftHeight = height(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightHeight = height(root.right);</span><br><span class="line">        <span class="keyword">if</span>((Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>) || leftHeight == -<span class="number">1</span> || rightHeight == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="两节点的最长路径（简单）"><a href="#两节点的最长路径（简单）" class="headerlink" title="两节点的最长路径（简单）"></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/description/">两节点的最长路径（简单）</a></h4><p>题目中说「这条路径可能穿过也可能不穿过根结点」，所以对于每一棵子树的根节点，都可能是直径路径经过的结点。如图，根节点为<code>2</code>的这棵子树就是正确答案。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/leetcoding/1_2_3_1.jpeg" alt=""></p><p>定义全局变量<code>ans</code>表示要求的直径长度所经过的结点个数。路径长度为两节点间经过的<em>边</em>的个数，也就等于结点数减1。所以最后求的直径长度为<code>ans - 1</code>。</p><p>下面我们分别求左、右子树的高度，然后<code>+1</code>，也就是所经过的结点个数。再和<code>ans</code>比较，取数值大者。</p><p>最后将<code>ans - 1</code>就是正确结果。<br><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">Python</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def diameterOfBinaryTree(self, root: TreeNode) -&gt; int:</span><br><span class="line">        self.ans &#x3D; 1</span><br><span class="line">        def height(root):</span><br><span class="line">            if not root:</span><br><span class="line">                return 0</span><br><span class="line">            leftHeight &#x3D; height(root.left)</span><br><span class="line">            rightHeight &#x3D; height(root.right)</span><br><span class="line">            self.ans &#x3D; max(self.ans, leftHeight + rightHeight + 1)</span><br><span class="line">            return max(leftHeight, rightHeight) + 1</span><br><span class="line">        height(root)</span><br><span class="line">        return self.ans - 1</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><hr><h4 id="翻转树（简单）"><a href="#翻转树（简单）" class="headerlink" title="翻转树（简单）"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/description/">翻转树（简单）</a></h4><p>？？？？？？？？？？？？？？？？？</p><p>下面这个解法1是我挖的一个坑。↓。中计了。</p><p>在二叉树的遍历算法上做更改。</p><p>其实就是一个前序遍历，不过就是将打印结点值换成了交换结点值。</p><p>那中序遍历、后续遍历行不行呢？答案是，前序、后序遍历可以，中序遍历就不可以。那为什么中序不可以呢？</p><p>？？？？？？？？？？？？？？？？？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 正解1</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def invertTree(self, root: TreeNode) -&gt; TreeNode:</span><br><span class="line">        if not root:</span><br><span class="line">            return None</span><br><span class="line">            </span><br><span class="line">        t &#x3D; root.left</span><br><span class="line">        root.left &#x3D; root.right</span><br><span class="line">        root.right &#x3D; t</span><br><span class="line">        </span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)</span><br><span class="line">        return root</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正解2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><hr><h4 id="归并两棵树（简单）"><a href="#归并两棵树（简单）" class="headerlink" title="归并两棵树（简单）"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/description/">归并两棵树（简单）</a></h4><p>该题就是创建一个二叉树，不过创建的数据来自两棵二叉树。</p><p>我再贴一个创建二叉树的算法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正解</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span>(<span class="params">self, t1: TreeNode, t2: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t1:</span><br><span class="line">            <span class="keyword">return</span> t2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t2:</span><br><span class="line">            <span class="keyword">return</span> t1</span><br><span class="line"></span><br><span class="line">        merged = TreeNode(t1.val + t2.val)</span><br><span class="line">        merged.left = self.mergeTrees(t1.left, t2.left)</span><br><span class="line">        merged.right = self.mergeTrees(t1.right, t2.right)</span><br><span class="line">        <span class="keyword">return</span> merged</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createBT</span>(<span class="params">root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">    data = <span class="built_in">input</span>()</span><br><span class="line">    <span class="keyword">if</span> d == `<span class="comment">#`:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    root = TreeNode(d)</span><br><span class="line">    root.left = createBT(root.left)</span><br><span class="line">    root.right = createBT(root.right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><hr><h4 id="判断路径和是否等于一个数（简单）"><a href="#判断路径和是否等于一个数（简单）" class="headerlink" title="判断路径和是否等于一个数（简单）"></a><a href="https://leetcode-cn.com/problems/path-sum/description/">判断路径和是否等于一个数（简单）</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正解</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: TreeNode, <span class="built_in">sum</span>: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span> == root.val</span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, <span class="built_in">sum</span> - root.val) <span class="keyword">or</span> self.hasPathSum(root.right, <span class="built_in">sum</span> - root.val)</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: TreeNode, <span class="built_in">sum</span>: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        que_node = collections.deque([root])</span><br><span class="line">        que_val = collections.deque([root.val])</span><br><span class="line">        <span class="keyword">while</span> que_node:</span><br><span class="line">            now = que_node.popleft()</span><br><span class="line">            temp = que_val.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> now.left <span class="keyword">and</span> <span class="keyword">not</span> now.right:</span><br><span class="line">                <span class="keyword">if</span> temp == <span class="built_in">sum</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> now.left:</span><br><span class="line">                que_node.append(now.left)</span><br><span class="line">                que_val.append(now.left.val + temp)</span><br><span class="line">            <span class="keyword">if</span> now.right:</span><br><span class="line">                que_node.append(now.right)</span><br><span class="line">                que_val.append(now.right.val + temp)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="统计路径和等于一个数的路径数量（中等）"><a href="#统计路径和等于一个数的路径数量（中等）" class="headerlink" title="统计路径和等于一个数的路径数量（中等）"></a><a href="https://leetcode-cn.com/problems/path-sum-iii/description/">统计路径和等于一个数的路径数量（中等）</a></h4><hr><h4 id="子树（简单）"><a href="#子树（简单）" class="headerlink" title="子树（简单）"></a><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/description/">子树（简单）</a></h4><p>用到了判断两棵树是否相等的算法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubtree</span>(<span class="params">self, s: TreeNode, t: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> <span class="keyword">not</span> t:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> t:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isSameTree(s, t) <span class="keyword">or</span> self.isSubtree(s.left, t) <span class="keyword">or</span> self.isSubtree(s.right, t)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> <span class="keyword">not</span> t:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> t:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> s.val == t.val <span class="keyword">and</span> self.isSameTree(s.left, t.left) <span class="keyword">and</span> self.isSameTree(s.right, t.right)</span><br></pre></td></tr></table></figure><hr><h4 id="树的对称（简单）"><a href="#树的对称（简单）" class="headerlink" title="树的对称（简单）"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/description/">树的对称（简单）</a></h4><hr><h4 id="最小路径（简单）"><a href="#最小路径（简单）" class="headerlink" title="最小路径（简单）"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/description/">最小路径（简单）</a></h4><hr><h4 id="统计左叶子节点的和（简单）"><a href="#统计左叶子节点的和（简单）" class="headerlink" title="统计左叶子节点的和（简单）"></a><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/description/">统计左叶子节点的和（简单）</a></h4><hr><h4 id="相同节点值的最大路径长度（中等）"><a href="#相同节点值的最大路径长度（中等）" class="headerlink" title="相同节点值的最大路径长度（中等）"></a><a href="https://leetcode-cn.com/problems/longest-univalue-path/">相同节点值的最大路径长度（中等）</a></h4><hr><h4 id="间隔遍历（中等）"><a href="#间隔遍历（中等）" class="headerlink" title="间隔遍历（中等）"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/description/">间隔遍历（中等）</a></h4><hr><h4 id="找出二叉树中第二小的节点（简单）"><a href="#找出二叉树中第二小的节点（简单）" class="headerlink" title="找出二叉树中第二小的节点（简单）"></a><a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/description/">找出二叉树中第二小的节点（简单）</a></h4><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode 刷题之数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题「链表」相关</title>
      <link href="/posts/3775416685/"/>
      <url>/posts/3775416685/</url>
      
        <content type="html"><![CDATA[<h4 id="找出两个链表的交点（简单）"><a href="#找出两个链表的交点（简单）" class="headerlink" title="找出两个链表的交点（简单）"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/">找出两个链表的交点（简单）</a></h4><p>该题要求时间复杂度为O(N)。如果想用两个指针分别指向两个链表，然后遍历求解，这样就需要两层循环，显然不符合时间复杂度O(N)的要求</p><p>对于正确解法的理解可以看下这张图⬇️</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.1/img/postImg/leetcoding/linkedList/1_1_1_1.jpeg" alt=""></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        ha, hb = headA, headB</span><br><span class="line">        <span class="keyword">while</span> ha != hb:</span><br><span class="line">            ha = ha.<span class="built_in">next</span> <span class="keyword">if</span> ha <span class="keyword">else</span> headB</span><br><span class="line">            hb = hb.<span class="built_in">next</span> <span class="keyword">if</span> hb <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> ha</span><br></pre></td></tr></table></figure><p>*另外补充下，如果只是判断两个链表是不是有共同结点，可以这么做</p><ol><li>将两个链表首尾相连，然后判断后一个链表是不是循环链表</li><li>直接比较两个链表的尾结点相不相等</li></ol><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/leetcoding/linkedList/1_1_1_2.jpeg" alt=""></p><hr><h4 id="链表反转（简单）"><a href="#链表反转（简单）" class="headerlink" title="链表反转（简单）"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/description/">链表反转（简单）</a></h4><p>这里要用到两个指针，一个指向当前结点，一个指向新链表的头结点（当前结点的上一个结点）</p><p><img src="/https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/leetcoding/linkedList/1_1_2_1.jpeg" alt=""></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            temp = cur.<span class="built_in">next</span> </span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = temp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><p>*另外可以用递归的方式反转链表：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        p = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">        head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><hr><h4 id="合并两个有序链表（简单）"><a href="#合并两个有序链表（简单）" class="headerlink" title="合并两个有序链表（简单）"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/description/">合并两个有序链表（简单）</a></h4><p>下面是直接合并两个链表的操作，没有用到递归。</p><p>大体思路如下：</p><p>若两个链表都非空，则从最左边开始比较两个链表的结点值。谁小，要谁。并将小值对应的链表的指针后移一位。如此往复。直至其中一个链表的结点全部走完。最后，只需要将没走完的链表接在新链表的尾巴上就OK了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        head = ListNode(<span class="literal">None</span>)</span><br><span class="line">        ret = head <span class="comment">#ret用来记录新链表的头结点，并将其的next返回</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &gt; l2.val:</span><br><span class="line">                head.<span class="built_in">next</span> = ListNode(l2.val)</span><br><span class="line">                head = head.<span class="built_in">next</span></span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                head.<span class="built_in">next</span> = ListNode(l1.val)</span><br><span class="line">                head = head.<span class="built_in">next</span></span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            head.<span class="built_in">next</span> = l1</span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            head.<span class="built_in">next</span> = l2</span><br><span class="line">        <span class="keyword">return</span> ret.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>下面是递归实现的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">            <span class="keyword">return</span> l2 <span class="comment">#假设l1就是为空，所以只需返回l2就好了。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt; l2.val: <span class="comment">#假设l1只有一个结点，且比l2小。所以l1就是返回链表的头结点。</span></span><br><span class="line">            l1.<span class="built_in">next</span> = self.mergeTwoLists(l1.<span class="built_in">next</span>, l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.<span class="built_in">next</span> = self.mergeTwoLists(l1, l2.<span class="built_in">next</span>)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure><p>递归的话，不要去纠结细节。要有<strong>宏观</strong>上的感觉。</p><p>递归我们只需要关注两件事 1.递归终止的条件是什么 2.递归体内部要做的是什么</p><p>比如这题，宏观上的递归思路就是：</p><p>递归终止的条件是什么？</p><p>终止条件就是，当其中之一的链表变为空时，则return。</p><p>递归体内部做的是是什么？</p><p>递归体内部做的是，比较两个链表当前结点值的大小。小的一方，则后边跟上递归调用。</p><p>递归调用传参该怎么传？</p><p>传参只需要将小的结点除去就OK了。用「.next」</p><p>我画了个图，便于理解。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/leetcoding/linkedList/1_1_3_1.jpeg" alt=""></p><hr><h4 id="删除链表的倒数第N个节点（中等）"><a href="#删除链表的倒数第N个节点（中等）" class="headerlink" title="删除链表的倒数第N个节点（中等）"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第N个节点（中等）</a></h4><p>直接写的思路是：</p><p>首先求出链表的长度。然后再从头遍历至待删除结点，将其删除即可。</p><p>这里有几个特殊情况需要注意：1）当<code>length == n</code>时，这时只需要将<code>head.next</code>返回就可以了。其中包括<code>length == 1</code>这种情况；2）当<code>n == 1</code>时，将最后一个结点置空即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        cur = head</span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> length == n:</span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        cur = head</span><br><span class="line">        l = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; length - n:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            cur.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p>进阶版是用<strong>一趟扫描</strong>实现。</p><p>如果用一趟扫描，我们面对的问题是什么呢？我们不知道链表的长度，所以不知道该删除的结点到底在哪。</p><p>那么怎样才能找到那个待删除的结点呢？题目中给出了<code>n</code>的值，那可以从<code>n</code>的值作为突破点。</p><p>首先需要一个<code>fast</code>指针，让它先跑<code>n</code>步。因为<code>fast = head</code>，所以等<code>fast</code>跑完<code>n</code>步时，其实是指向第<code>n+1</code>个结点。此时，若<code>fast</code>指向空结点，那说明这满足<code>length == n</code>这种情况，所以要<code>return head.next</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/leetcoding/linkedList/1_1_4_1.jpeg" alt=""></p><p>下面还需要一个<code>slow</code>结点，指向链表的头结点。因为这时<code>fast</code>已经跑出去<code>n+1</code>步了，所以只需让<code>fast</code>跑到链表的尾结点即可，这时<code>slow</code>指向的下一个结点就是待删除结点。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/leetcoding/linkedList/1_1_4_2.jpeg" alt=""></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        fast = head</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> fast <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span> <span class="comment"># length == n 的情况</span></span><br><span class="line"></span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><hr><h4 id="两两交换链表中的节点（中等）"><a href="#两两交换链表中的节点（中等）" class="headerlink" title="两两交换链表中的节点（中等）"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">两两交换链表中的节点（中等）</a></h4><p>基本思路如下：</p><p>首先我们改造一下题目给的无头链表。将其变为<strong>带头结点</strong>的链表。这样可以让整体的操作更具一般性，不需要将前两个结点在循环外边交换。可以使每两个需要交换的结点的前面都有一个结点，这样可以让结点在交换时，链表不至于断掉，<code>bbefore.next = after</code>。看图理解下。</p><p>然后需要两个指针，分别指向待操作的两个结点的<code>前一个结点</code>，和<code>后一个结点</code>。交换结点的时候，处理好指针的指向就好。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#交换结点</span></span><br><span class="line"></span><br><span class="line">before.<span class="built_in">next</span>, after.<span class="built_in">next</span> = after.<span class="built_in">next</span>, before</span><br><span class="line">bbefore.<span class="built_in">next</span> = after</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/leetcoding/linkedList/1_1_5_1.jpeg" alt=""></p><p>然后就循环就完了呗。若结点个数是偶数个，则都换。若奇数个，则最后一个不换。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        new_head = ListNode(<span class="literal">None</span>)</span><br><span class="line">        new_head.<span class="built_in">next</span> = head</span><br><span class="line">        bbefore = new_head</span><br><span class="line">        <span class="keyword">while</span> bbefore.<span class="built_in">next</span> <span class="keyword">and</span> bbefore.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            before, after = bbefore.<span class="built_in">next</span>, bbefore.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            before.<span class="built_in">next</span>, after.<span class="built_in">next</span> = after.<span class="built_in">next</span>, before</span><br><span class="line">            bbefore.<span class="built_in">next</span> = after</span><br><span class="line"></span><br><span class="line">            bbefore = before</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> new_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><hr><h4 id="删除排序链表中的重复元素（简单）"><a href="#删除排序链表中的重复元素（简单）" class="headerlink" title="删除排序链表中的重复元素（简单）"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/description/">删除排序链表中的重复元素（简单）</a></h4><p>暴力解法，大体思路如下：</p><p>需要两个指针，一个指向当前结点，一个指向 需要判断后面是否有相同结点值 的结点。</p><p>然后就是遍历链表，判断<code>tag.val == cur.val</code>否？若相等，则删除。若不等，则说明这个有序链表中就不会再出现<code>tag</code>指向的结点值，所以<code>tag</code>后移一位。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        tag = head</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> tag.val == cur.val:</span><br><span class="line">                tag.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tag = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><hr><h4 id="两数相加-II（中等）"><a href="#两数相加-II（中等）" class="headerlink" title="两数相加 II（中等）"></a><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/description/">两数相加 II（中等）</a></h4><p>考虑到链表中，位数的顺序和我们进行运算的顺序是相反的，那么我们可以使用「栈」这种「后进先出」的数据结构。</p><p>假设初始情况下，给的链表是如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/leetcoding/linkedList/1_1_7_1.jpeg" alt=""></p><p>然后，我们将两个链表分别压进两个栈中。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/leetcoding/linkedList/1_1_7_2.jpeg" alt=""></p><p>压栈完成后，开始出栈，并进行运算。</p><p>每出栈一位就进行一步加法运算，这里要特别注意存在<strong>进位</strong>的情况。代码中我们用<code>carry</code>来表示进位值。</p><p>还有一个需要注意的地方是，我们在建立结果链表时，不是正序建立的，而是<em>逆序</em>建立的。这样加法运算完成后，直接可以返回正确的链表。当然如果不这么做的话，你也可以另外声明一个节点来记录正序链表的头指针，在加法运算完成后直接返回即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        stack1, stack2 = [], []</span><br><span class="line">        cur = l1</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            stack1.append(cur.val)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        cur = l2</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            stack2.append(cur.val)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        ret = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> stack1 <span class="keyword">or</span> stack2 <span class="keyword">or</span> carry != <span class="number">0</span>:</span><br><span class="line">            a = <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> stack1 <span class="keyword">else</span> stack1.pop()</span><br><span class="line">            b = <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> stack2 <span class="keyword">else</span> stack2.pop()</span><br><span class="line">            curnode = ListNode((a + b + carry) % <span class="number">10</span>)</span><br><span class="line">            carry = (a + b + carry) // <span class="number">10</span></span><br><span class="line"></span><br><span class="line">            curnode.<span class="built_in">next</span> = ret</span><br><span class="line">            ret = curnode</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p><br /></p><p>还有一种解法，是先将短的链表在高位补0，使两个链表长度相同。然后再反转两条链表。最后进行加法计算。如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/leetcoding/linkedList/1_1_7_3.jpeg" alt=""></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        a, b = l1, l2</span><br><span class="line">        tag = <span class="number">0</span> <span class="comment">#短的（需要补0）的链表</span></span><br><span class="line">        dif = <span class="number">0</span> <span class="comment">#两个链表的长度差</span></span><br><span class="line">        <span class="comment">#完成补0</span></span><br><span class="line">        <span class="keyword">while</span> a <span class="keyword">or</span> b:</span><br><span class="line">            tag = <span class="number">1</span> <span class="keyword">if</span> <span class="keyword">not</span> a <span class="keyword">else</span> <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> a <span class="keyword">or</span> <span class="keyword">not</span> b:</span><br><span class="line">                dif += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> a: a = a.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> b: b = b.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> tag == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">while</span> dif &gt; <span class="number">0</span>:</span><br><span class="line">                t = ListNode(<span class="number">0</span>)</span><br><span class="line">                t.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = t</span><br><span class="line">                dif -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> tag == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">while</span> dif &gt; <span class="number">0</span>:</span><br><span class="line">                t = ListNode(<span class="number">0</span>)</span><br><span class="line">                t.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = t</span><br><span class="line">                dif -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#反转两条链表</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            t = l1.<span class="built_in">next</span></span><br><span class="line">            l1.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = l1</span><br><span class="line">            l1 = t</span><br><span class="line">        l1 = pre</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            t = l2.<span class="built_in">next</span></span><br><span class="line">            l2.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = l2</span><br><span class="line">            l2 = t</span><br><span class="line">        l2 = pre</span><br><span class="line"></span><br><span class="line">        <span class="comment">#加法计算</span></span><br><span class="line">        ret = <span class="literal">None</span></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> carry != <span class="number">0</span>:</span><br><span class="line">            a = <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> l1 <span class="keyword">else</span> l1.val</span><br><span class="line">            b = <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> l2 <span class="keyword">else</span> l2.val</span><br><span class="line">            curnode = ListNode((a + b + carry) % <span class="number">10</span>)</span><br><span class="line">            carry = (a + b + carry) // <span class="number">10</span></span><br><span class="line"></span><br><span class="line">            curnode.<span class="built_in">next</span> = ret</span><br><span class="line">            ret = curnode</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> l1: l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> l2: l2 = l2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><hr><h4 id="回文链表（简单）"><a href="#回文链表（简单）" class="headerlink" title="回文链表（简单）"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/description/">回文链表（简单）</a></h4><p>思路：</p><p>首先新建一个链表，其内容为初始链表的反转。</p><p>然后同时遍历两条链表，并判断相应结点值是否相等，若有一个不等，则不是回文链表。否则，是。</p><p>先看是回文链表的图。可见对应结点的值都是相等的：</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/leetcoding/linkedList/1_1_8_1.jpeg" alt=""></p><p>再看个不是回文链表的图：</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/leetcoding/linkedList/1_1_8_2.jpeg" alt=""></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">        cur = head</span><br><span class="line">        new_head = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            t = ListNode(cur.val)</span><br><span class="line">            t.<span class="built_in">next</span> = new_head</span><br><span class="line">            new_head = t</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val != new_head.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">            new_head = new_head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><br /></p><p>还有一种是利用<code>list</code>。大体思路和上面一样。</p><p>在pythonpython3中，借助<code>切片</code>可以很方便的生成列表的反向副本，生成反向列表副本的代码为：<code>vals[::-1]</code>。</p><p><a href="https://zhuanlan.zhihu.com/p/184951582">点我了解更多关于切片的知识</a>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">        vals = []</span><br><span class="line">        curnode = head</span><br><span class="line">        <span class="keyword">while</span> curnode <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            vals.append(curnode.val)</span><br><span class="line">            curnode = curnode.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> vals == vals[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><br /></p><p>这里提一个方法：可以设置<em>快慢指针</em>，慢指针一次走一步，快指针一次走两步。这样当快指针走到尾部时，慢指针正好走到中间。然后反转后半部分链表，将其和前半部分对比。完成后再将后半部分的链表复原（不复原也可，但是一般都不希望链表结构被改变）。</p><hr><h4 id="分隔链表（中等）"><a href="#分隔链表（中等）" class="headerlink" title="分隔链表（中等）"></a><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/description/">分隔链表（中等）</a></h4><p>本题的难点我认为是，怎样计算划分后的每段链表的长度？请看下图：</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/leetcoding/linkedList/1_1_9_1.jpeg" alt=""></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitListToParts</span>(<span class="params">self, root: ListNode, k: <span class="built_in">int</span></span>) -&gt; List[ListNode]:</span></span><br><span class="line">        <span class="comment"># 现在我们假设链表长度为5，k=3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回值</span></span><br><span class="line">        ret = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果传来空链表，则直接返回长度为k的空list</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                ret.append(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算链表的长度</span></span><br><span class="line">        cur = root</span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># amount中每个值代表将链表分割后，每段的长度。具体的计算过程请看本题的第一张图。</span></span><br><span class="line">        amount = []</span><br><span class="line">        x = length // k</span><br><span class="line">        y = length % k</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            t = x</span><br><span class="line">            <span class="keyword">if</span> y &gt; <span class="number">0</span>:</span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line">                y -= <span class="number">1</span></span><br><span class="line">            amount.append(x)</span><br><span class="line">            x = t</span><br><span class="line">        <span class="comment"># 现在amount的值为[2, 2, 1]</span></span><br><span class="line"></span><br><span class="line">        amount.reverse()</span><br><span class="line">        <span class="comment"># 将amount反转一下，变为[1, 2, 2]。因为后面要用pop()方法来取其中的值。</span></span><br><span class="line">        <span class="comment"># 我们取值的顺序应该和最终生成的List的长度顺序保持一致。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> times <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            temp_head = root</span><br><span class="line"></span><br><span class="line">            pre = <span class="literal">None</span></span><br><span class="line">            l = amount.pop()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">                pre = root</span><br><span class="line">                root = root.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> l != <span class="number">0</span>:</span><br><span class="line">                pre.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">                ret.append(temp_head)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret.append(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p>简化一下上个解法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitListToParts</span>(<span class="params">self, root: ListNode, k: <span class="built_in">int</span></span>) -&gt; List[ListNode]:</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">for</span> N <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1001</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">break</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        width, remainder = <span class="built_in">divmod</span>(N, k)</span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            head = write = ListNode(<span class="literal">None</span>)</span><br><span class="line">            tag = <span class="number">1</span> <span class="keyword">if</span> i &lt; remainder <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(width + tag):</span><br><span class="line">                write.<span class="built_in">next</span> = write = ListNode(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur: cur = cur.<span class="built_in">next</span></span><br><span class="line">            ans.append(head.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><hr><h4 id="奇偶链表（中等）"><a href="#奇偶链表（中等）" class="headerlink" title="奇偶链表（中等）"></a><a href="https://leetcode-cn.com/problems/odd-even-linked-list/description/">奇偶链表（中等）</a></h4><p>思路如下：</p><p>需要两个指针，<code>p</code>用来指奇数位置，<code>q</code>用来指偶数位置。</p><p>每次循环都让<code>p</code>移到下一个奇数位置。<code>q</code>移到下一个偶数位置。这样就会产生两个子链表，一条为全部奇数的链表，另一条为全部偶数的链表。最后将两条链表首位连接即可。</p><p>对于<em>链表总结点数为偶数</em>个的情况，则需要一个<code>pre_p</code>指针来指向上一个<code>p</code>结点。方便最后连接奇、偶两个子链表。</p><p>看图。其中黄线代表最后连接奇、偶两个子链表。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/leetcoding/linkedList/1_1_10_1.jpeg" alt=""></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        p = head</span><br><span class="line">        q = head.<span class="built_in">next</span></span><br><span class="line">        right = head.<span class="built_in">next</span></span><br><span class="line">        pre_p = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">and</span> q:</span><br><span class="line">            pre_p = p</span><br><span class="line">            p.<span class="built_in">next</span> = q.<span class="built_in">next</span></span><br><span class="line">            p = q.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                q.<span class="built_in">next</span> = p.<span class="built_in">next</span></span><br><span class="line">                q = p.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                q.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">            pre_p.<span class="built_in">next</span> = right</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> p.<span class="built_in">next</span>:</span><br><span class="line">            p.<span class="built_in">next</span> = right</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode 刷题之数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贰零贰零年十月</title>
      <link href="/posts/1326793566/"/>
      <url>/posts/1326793566/</url>
      
        <content type="html"><![CDATA[<h4 id="10-01"><a href="#10-01" class="headerlink" title="10.01"></a>10.01</h4><p>「可是人这东西是要把自己附在什么上面才能生存的。」大岛说，「不能不那样。你也难免不知不觉的如法炮制。如歌德所说，世间万物无一不是隐喻(metaphor)。」</p><p><br /></p><p>幸福是寓言，不幸是故事。</p><hr><h4 id="10-02"><a href="#10-02" class="headerlink" title="10.02"></a>10.02</h4><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.3/img/postImg/jilu/20201002.jpeg" alt=""></p><hr><h4 id="10-03"><a href="#10-03" class="headerlink" title="10.03"></a>10.03</h4><p>读书。看剧。</p><hr><h4 id="10-04"><a href="#10-04" class="headerlink" title="10.04"></a>10.04</h4><p>不太重要的人和太重要的人，都不需要经常见。</p><p>不太重要的人，你只需要给他亮出「肌肉」，告诉他这里有利益可以交换，足够了。不用和他们谈什么感情，纯属浪费。</p><p>太重要的人，平时各忙各的，见不见面无所谓，需要的时候，自然在那里。这种感情，无需耗费精力维系。</p><p>三观不一致的人，很难走到一起。朋友是吸引来的，不是经营来的。</p><p>另外，我们没有自己想象的那么脆弱，脆弱到需要那么多的朋友。</p><p><br /></p><p>强烈推荐《Person of Interest》</p><hr><h4 id="10-05"><a href="#10-05" class="headerlink" title="10.05"></a>10.05</h4><p>没有启发性的东西。</p><hr><h4 id="10-06"><a href="#10-06" class="headerlink" title="10.06"></a>10.06</h4><p>行有余力再读书。</p><p>我们应当把时间、精力，全部都投入到那个关键事情上，尽快让它达到阈值。然后再去学习其他东西。否则，就会出现自己的事情没做好，学习其他东西也没收获。能力不够时，是撑不起那些从公众号、星球等看到的见识的。</p><hr><h4 id="10-07"><a href="#10-07" class="headerlink" title="10.07"></a>10.07</h4><p>这也太魔幻了吧。我买到了一个屏幕有白斑的iPad，我又卖出了一个屏幕有白斑的Mac。</p><hr><h4 id="10-08"><a href="#10-08" class="headerlink" title="10.08"></a>10.08</h4><p>今天更魔幻。我在学校遇到了初中同学。你敢信？</p><p>今天吃完饭本来想去学习的，结果跑去和舍友打球了。说巧不巧的就在球场和我初中同学偶遇了。一开始我就看着面熟，等后来一问还真是，真的是太巧了。</p><hr><h4 id="10-09"><a href="#10-09" class="headerlink" title="10.09"></a>10.09</h4><p>谦逊而执着，腼腆而无畏。</p><hr><h4 id="10-10"><a href="#10-10" class="headerlink" title="10.10"></a>10.10</h4><p>药品批准文号格式为「国药准（试）字 + 字母 + 8位数字」。其中「药」代表是药品，「准」字代表国家批准生产的药品。「试」代表国家批准试生产的药品（一般遇不到。</p><p>字母包括 H、Z、S、 B、T、F、J。分别代表药品不同类别：H 代表化学药品，Z 代表中成药，S 代表生物制品，B 代表保健药品，T 代表体外化学诊断试剂，F 代表药用辅料，J 代表进口分包装药品。</p><p>这些字母就是药品类别<strong>拼音的首字母</strong>。</p><p>买药要买<strong>H</strong>的，这种药毛利率相对要低，30%左右。相反，中成药的毛利率最少也有50%，更甚者可以达到80%。</p><p>况且，大多数时候顾客买的药只是些「安慰剂」。比如感冒药，吃药或者不吃药，都是一周就能好。</p><hr><h4 id="10-11"><a href="#10-11" class="headerlink" title="10.11"></a>10.11</h4><p>你不能解决问题，那么你就会成为问题。</p><hr><h4 id="10-12"><a href="#10-12" class="headerlink" title="10.12"></a>10.12</h4><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.3/img/postImg/jilu/20201012.jpeg" alt=""></p><hr><h4 id="10-13"><a href="#10-13" class="headerlink" title="10.13"></a>10.13</h4><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.3/img/postImg/jilu/20201013.png" alt=""></p><hr><h4 id="10-14"><a href="#10-14" class="headerlink" title="10.14"></a>10.14</h4><p>今天凌晨看了12的发布会，想搞一手。</p><hr><h4 id="10-15"><a href="#10-15" class="headerlink" title="10.15"></a>10.15</h4><p>焦虑不会改变未发生的，更不会改变已经发生的。佛系一点。</p><hr><h4 id="10-16"><a href="#10-16" class="headerlink" title="10.16"></a>10.16</h4><p>Nothing is written.</p><p><br /></p><p>人们不知道他们想要什么，直到你把它摆在他们面前。</p><p><br /></p><p>盲人摸象、小马过河、卖油翁、庖丁解牛。</p><hr><h4 id="10-17"><a href="#10-17" class="headerlink" title="10.17"></a>10.17</h4><p>有很多事情，需要坚持，才能看到有价值的回报。</p><p>但更难的是，你需要判断，到底什么事情，值得坚持。</p><hr><h4 id="10-18"><a href="#10-18" class="headerlink" title="10.18"></a>10.18</h4><p>不要对自己从没做过的事引以为傲，不要对自己从未见过的人恨之入骨。</p><hr><h4 id="10-19"><a href="#10-19" class="headerlink" title="10.19"></a>10.19</h4><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.3/img/postImg/jilu/20201019.jpeg" alt=""></p><hr><h4 id="10-20"><a href="#10-20" class="headerlink" title="10.20"></a>10.20</h4><p>《Changing of the Guards》</p><hr><h4 id="10-21"><a href="#10-21" class="headerlink" title="10.21"></a>10.21</h4><p>快和慢都是一种能力，重要的是保持好自己的节奏。</p><p><br /></p><p>纽约时间比加州时间早三个小时， 但加州时间并没有变慢。 有人22岁就毕业了， 但等了五年才找到好的工作； 有人25岁就当上CEO， 却在50岁去世； 也有人迟到50岁才当上CEO， 然后活到90岁。 有人依然单身， 同时也有人已婚。 奥巴马55岁就退休， 川普70岁才开始当总统。 世上每个人本来就有自己的发展时区， 身边有些人看似走在你前面， 也有人看似走在你后面， 但其实每个人在自己的时区有自己的步程。 不用嫉妒或嘲笑他们， 他们都在自己的时区里， 你也是。 生命就是等待正确的行动时机， 所以，放轻松， 你没有落后，你没有领先， 在命运为你安排的属于自己的时区里， 一切都准时。</p><hr><h4 id="10-22"><a href="#10-22" class="headerlink" title="10.22"></a>10.22</h4><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.3/img/postImg/jilu/20201022.png" alt=""></p><p>Q:我们将要飞向何方？</p><p>A:我要去海滩上整点薯条。</p><p>Q:你误会我的意思了伙计。我说的是咱们这一辈子的目标。我们活着是为了什么？</p><p>A:为了待会去码头整点薯条。</p><p><br /></p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.3/img/postImg/jilu/20201022_1.png" alt=""></p><hr><h4 id="10-23"><a href="#10-23" class="headerlink" title="10.23"></a>10.23</h4><p>12到了，真香。正在研究中。</p><hr><h4 id="10-24"><a href="#10-24" class="headerlink" title="10.24"></a>10.24</h4><p>《我脑袋里的怪东西》。</p><hr><h4 id="10-25"><a href="#10-25" class="headerlink" title="10.25"></a>10.25</h4><p>凡他人承受的，有很大可能性会落在自己身上，这是一个非常沉痛的人生体会。但困难和挫折不是坏事，对于内心强大的人，它们会让我们更加坚强。</p><hr><h4 id="10-26"><a href="#10-26" class="headerlink" title="10.26"></a>10.26</h4><p>你有药，我一定有病么？</p><hr><h4 id="10-27"><a href="#10-27" class="headerlink" title="10.27"></a>10.27</h4><p>“在这世界上，我最爱拉伊哈”，麦夫鲁特自言自语道。</p><p><br /></p><p>不要高估一个月的努力，也不要低估一年的努力。</p><hr><h4 id="10-28"><a href="#10-28" class="headerlink" title="10.28"></a>10.28</h4><p>//…</p><hr><h4 id="10-29"><a href="#10-29" class="headerlink" title="10.29"></a>10.29</h4><p>两天没看书了。</p><hr><h4 id="10-30"><a href="#10-30" class="headerlink" title="10.30"></a>10.30</h4><p>Code Tells You How, Comments Tell You Why.</p><hr><h4 id="10-31"><a href="#10-31" class="headerlink" title="10.31"></a>10.31</h4><p>这个商业社会里，如果没什么家底儿，又不能赚钱，那就是个孬货。</p><p><br /></p><p>这个月刷了30道LeetCode，读了6本书。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日更 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我终于开学啦</title>
      <link href="/posts/799305869/"/>
      <url>/posts/799305869/</url>
      
        <content type="html"><![CDATA[<p>九月十八号，距离我元旦放寒假已经过去了将近九个月。</p><p>一场突如其来的疫情夺去了我在本科最后的半年时光。原本打算好的一切计划都被迫取消。等过些年回头再看，我们2020年真的是在见证历史。</p><p>考研准备了将近一年的时间，也是如愿考上了心仪的学校。当初选学校，我最关注的就是城市。综合各方面因素，我最终选择了杭州。</p><p>报道当天就在一直下雨，那种朦朦胧胧的小雨。我也没带伞，辛亏当时地铁站有迎新的学长，找他们借了一次性雨衣。好心的学长看我还有个电脑包，就又多给我一个。</p><p>报道都挺顺利的，几分钟搞定。</p><p>唯一糟糕的事情就是，我的快递报道那天没到。所以晚上我就没有被褥睡，这就很尴尬了。不过幸好我舍友多拿了一床冬天的被，我把被子从中间对叠，一边垫在下面，一边用来盖，就这样凑合和了一宿。</p><hr><p>今天写这篇文章的时候终于出太阳了。</p><p>我暑假期间选的导师，昨天给我发消息说，他那边名额满了让我再联系下其他的导师。我赶紧又看了下其他导师的信息，赶紧发了邮件。被导师拒绝确实有点伤心，我的实力也可能是不够，希望研究生三年可以好好地提升下自己。加油！</p><p>今晚迎新，明天就开始上课了。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac使用Timemachine自动备份</title>
      <link href="/posts/790217334/"/>
      <url>/posts/790217334/</url>
      
        <content type="html"><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>我相信很多人都有丢失文件的经历，然后想尽各种办法找回数据。我就中过一次枪。所以说与其等到真的意外丢失了文件再着急，不如从现在开始，养成随时备份的好习惯。</p><p>对于Mac用户，Timemachine你值得一试。</p><h4 id="准备硬盘"><a href="#准备硬盘" class="headerlink" title="准备硬盘"></a>准备硬盘</h4><p>首先，我们需要一块移动硬盘。我直接用的是在老电脑上卸下来的，500GB。然后在网上买了个透明的硬盘盒。如果没有老电脑可以拆，在网上买块新的也行。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/Timemachine/1.jpeg" alt=""></p><p><strong><a href="https://union-click.jd.com/jdc?e=&amp;p=AyIGZRtfEAQTBVwdWh0yFgBSHV4UBhQAUhJrUV1KWQorAlBHU0VeBUVNR0ZbSkdETlcNVQtHRVNSUVNLXANBRA1XB14DS10cQQVYD21XHgNSHF0QAxYBUhxSJXxqfCVIC3AAdwFPcyx2fRJkIU1BfUQeC2UaaxUDEwRWHVgRChs3ZRtcJUN8B1QaWRcBFgZlGmsVBhoPXB1SFQUVA1ceaxICGzdVH1wRABcGXBtdFGxTRAcrayUBIjdlG2sWMlBpVxxcFgVGBlRLXkECFwFRHVIVBkJUBh5dRwMaDlVJCBAyEAZUH1I%3D">透明移动硬盘盒（点我购买）价格：24.9元</a></strong></p><p><strong><a href="https://union-click.jd.com/jdc?e=&amp;p=AyIGZRNdEQoXAV0eUyUGFAZcG1wcBRAPXSsfSlpMWGVCHlBDUAxLBQNQVk4YCQQAQB1AWQkFHUVBRhkSQw9THUJVEEMFSgxUVxZPI0AOFgFUElsSCxUFXRNrRVRlZwB%2FG0tiRWEiQzxLemEAA0tTUw4eN1QrWxQDEQRTGF8dCyI3VRxrVGwVDlceWiUDIgdRE1McCxMGXB5ZEQQiAFUSaxUGFQNXHlocAhQGO1oYRzIiN1YrayUCIgRlWTUXBkUOUxNfFFUbV1AeWxMLGwABTwwcVRIAUxlbHQFCVWUZWhQGGw%3D%3D">西部数据（WD）移动硬盘 2.5寸 USB3.0 价格：349元</a></strong></p><h4 id="初始化硬盘"><a href="#初始化硬盘" class="headerlink" title="初始化硬盘"></a>初始化硬盘</h4><p>准备好硬盘后，下边要对硬盘进行初始化。</p><p>打开系统自带的「磁盘工具」，在左侧选中自己的硬盘，点击上方的「抹掉」。在弹出的对话框中，名称自己随便设置一个，格式选择「Mac OS 扩展（区分大小写 日志式）」（默认项）。最后点击「抹掉」，等待完成即可。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/Timemachine/2.png" alt=""></p><p><strong>建议让Timemachine独占硬盘</strong></p><h4 id="加密磁盘"><a href="#加密磁盘" class="headerlink" title="加密磁盘"></a>加密磁盘</h4><p>当做完上述步骤后，Mac会自动提示你是否使用该硬盘对Mac备份。同时为了数据的安全性，建议在弹出的对话框中勾选「给备份磁盘加密」。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/Timemachine/4.png" alt=""></p><p>随后在弹出的对话框中输入密码和提示信息即可。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/Timemachine/5.png" alt=""></p><p>这个加密过程是非常缓慢的，加密速度大概在20~30MB之间。如果加密100GB的数据，大概耗时1小时左右。不过，加密过程可以中断，你可以随时把硬盘推出，等下次你再接上硬盘的时候，Mac会自动进行上次未完成的加密。</p><h4 id="排除不需要备份项"><a href="#排除不需要备份项" class="headerlink" title="排除不需要备份项"></a>排除不需要备份项</h4><p>我们还可以根据自己的需求选择不需要备份的文件。</p><p>打开时间机器-》选项，将不需要备份的文件添加上去即可。</p><p>我自己没有排除。下载项啥的我也备份了，省的到时候再去重新下载了。</p><h4 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h4><p>() 菜单 &gt;“系统偏好设置”，然后点按「时间机器」。然后点按「选择备份磁盘」，选中你刚才初始化的硬盘。首次备份的话，时间会很长。但是以后Timemachine会只备份更改过的数据，所以会很快完成备份。</p><p>记得把「自动备份」勾选上。这样以后会自动进行备份，不需要人为干涉。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/Timemachine/6.png" alt=""></p><h4 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h4><p>在菜单栏点按时间机器的图标，然后点按「进入时间机器」，会出现如下界面。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/Timemachine/7.png" alt=""></p><p>是不是很酷。</p><p>现在你就可以选择需要还原的数据进行还原了。</p>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Timemachine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TensorFlow使用中遇到的问题（macOS）</title>
      <link href="/posts/1935262646/"/>
      <url>/posts/1935262646/</url>
      
        <content type="html"><![CDATA[<h4 id="TensorFlow安装报错RuntimeError-dictionary-changed-size-during-iteration"><a href="#TensorFlow安装报错RuntimeError-dictionary-changed-size-during-iteration" class="headerlink" title="TensorFlow安装报错RuntimeError: dictionary changed size during iteration"></a>TensorFlow安装报错RuntimeError: dictionary changed size during iteration</h4><blockquote><p>TensorFlow版本：1.15.3</p><p>Python版本 ：3.7.3</p><p>macOS版本：10.15.6</p></blockquote><p>解决方案：</p><p>vim打开报错的文件</p><p><code>vim /Applications/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.7/lib/python3.7/linecache.py</code></p><p>找到第48行，做如下修改</p><p><code>for mod in list(sys.modules.values()): # 原来是 for mod in sys.modules.values():</code></p><p>因为linecache.py是只读的，所以退出vim编辑器时，需采用强制保存命令</p><p><code>:w !sudo tee %</code></p><p>然后，输入密码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">W12: Warning: File &quot;&#x2F;etc&#x2F;hosts&quot; has changed and the buffer was changed in Vim as well</span><br><span class="line">See &quot;:help W12&quot; for more info.</span><br><span class="line">[O]K, (L)oad File:</span><br></pre></td></tr></table></figure><p>这里按<code>L</code>即可，表示重新载入文件</p><p>至此，搞定</p><hr><h4 id="tensoeflow-v2-版本中-xavier-initializer-初始化替换函数tf-compat-v1-contrib-layers-xavier-initializer-seed-0"><a href="#tensoeflow-v2-版本中-xavier-initializer-初始化替换函数tf-compat-v1-contrib-layers-xavier-initializer-seed-0" class="headerlink" title="tensoeflow v2 版本中 xavier_initializer 初始化替换函数tf.compat.v1.contrib.layers.xavier_initializer(seed=0))"></a>tensoeflow v2 版本中 xavier_initializer 初始化替换函数tf.compat.v1.contrib.layers.xavier_initializer(seed=0))</h4><p><code>initializer=tf.compat.v1.initializers.glorot_uniform(seed=0)</code></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy常见用法</title>
      <link href="/posts/4214116711/"/>
      <url>/posts/4214116711/</url>
      
        <content type="html"><![CDATA[<h3 id="numpy-pad"><a href="#numpy-pad" class="headerlink" title="numpy.pad()"></a>numpy.pad()</h3><p>用来填充数据，可以按指定方式填充numpy数组。</p><blockquote><p>pad(array,  pad_width,  mode,  **kwargs)</p><p>返回值：数组</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr2D = np.array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">print(<span class="built_in">str</span>(np.pad(arr2D, ((<span class="number">1</span>,<span class="number">1</span>), (<span class="number">1</span>, <span class="number">1</span>)), <span class="string">&#x27;constant&#x27;</span>, constant_values=(<span class="number">8</span>, <span class="number">9</span>))))</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印如下：</span></span><br><span class="line">[[<span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line"> [<span class="number">8</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">9</span>]</span><br><span class="line"> [<span class="number">8</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">9</span>]</span><br><span class="line"> [<span class="number">8</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">9</span>]</span><br><span class="line"> [<span class="number">8</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span>]]</span><br></pre></td></tr></table></figure><blockquote><p>为了容易理解，这里用二维数组做示范</p><p>((1,1), (1, 1)) 该参数项的前一个(1,1)对应着一维，第二个(1,1)对应着二维。如果是高维数组的话，就往后继续补。拿三维举例，就是((1,1), (1,1), (1,1))</p><p>里边的数字1表示在当前维度上的前边和后边分别填充多大形状。也可以选择其他数字</p><p>画了个图，方便理解</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/np_pad_1.jpeg" alt=""></p><p>第3个参数为填充的方式</p><blockquote><p>constant：用连续一样的值填充。有参数项constant_values =（x, y）时前面用x填充，后面用y填充。缺省值为用0填充</p><p>edge：用边缘值填充</p><p>linear_ramp：边缘递减的填充方式</p><p>maximum, mean, median, minimum分别用最大值、均值、中位数和最小值填充</p><p>reflect, symmetric：对称填充。前一个是关于边缘对称，后一个是关于边缘外的空气对称</p><p>wrap：用原数组后面的值填充前面，前面的值填充后面</p><p>当然也可以用其他自定义的方式填充</p></blockquote><h3 id="numpy-中的几种乘法"><a href="#numpy-中的几种乘法" class="headerlink" title="numpy 中的几种乘法"></a>numpy 中的几种乘法</h3><p>1). np.dot()</p><p>同线性代数的矩阵乘法。</p><p>2). np.multiply() 或 *</p><p>计算的是矩阵对应位置元素的乘积。</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/np_pad_2.jpeg" alt=""></p><h3 id="numpy-中-ndarray-和-array区别"><a href="#numpy-中-ndarray-和-array区别" class="headerlink" title="numpy 中 ndarray 和 array区别"></a>numpy 中 ndarray 和 array区别</h3><p>我们可以使用<code>np.array()</code>创建一个<code>ndarry</code>。<code>np.array()</code>是一个返回<code>ndarry</code>对象的方法。</p><h3 id="numpy-中-shuffle-与-permutation-的区别"><a href="#numpy-中-shuffle-与-permutation-的区别" class="headerlink" title="numpy 中 shuffle 与 permutation 的区别"></a>numpy 中 shuffle 与 permutation 的区别</h3><p>两者都是<code>洗牌</code>的功能。区别是：shuffle直接打乱原数据，而permutation是保留原数据顺序，返回一个新的被打乱的数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">print(np.random.permutation(x))</span><br><span class="line">print(np.random.shuffle(x))</span><br><span class="line">np.random.shuffle(x)</span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印如下</span></span><br><span class="line">[<span class="number">6</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">4</span> <span class="number">3</span> <span class="number">5</span>]</span><br><span class="line"><span class="literal">None</span></span><br><span class="line">[<span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span> <span class="number">6</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="np-mean"><a href="#np-mean" class="headerlink" title="np.mean()"></a>np.mean()</h3><p>求取均值，可以求全部数据均值，也可以按行（列）求取均值</p><p>其中参数<code>aixa</code>表示在哪个维度上取均值，0对所有元素取均值</p><p><img src="https://cdn.jsdelivr.net/gh/IamXGW/CDN-for-xuguangwei.com@2.1.7/img/postImg/np_mean_1.jpeg" alt=""></p><p>画了个图，hhh</p><h3 id="Numpy-中将多维数组转换为一维数组"><a href="#Numpy-中将多维数组转换为一维数组" class="headerlink" title="Numpy 中将多维数组转换为一维数组"></a>Numpy 中将多维数组转换为一维数组</h3><p>ravel()：如果没有必要，不会产生源数据的副本 。</p><p>flatten()：返回源数据的副本 。</p><p>squeeze()：只能对维数为1的维度降维。</p><p>除此之外，<code>reshape(-1)</code>也可以「拉平」多维数组。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达深度学习（DeepLearning.ai）提及的论文</title>
      <link href="/posts/3232742656/"/>
      <url>/posts/3232742656/</url>
      
        <content type="html"><![CDATA[<h3 id="第一课《神经网络和深度学习》"><a href="#第一课《神经网络和深度学习》" class="headerlink" title="第一课《神经网络和深度学习》"></a>第一课《神经网络和深度学习》</h3><p>无</p><h3 id="第二课《改善神经网络：超参调整，正则化和优化》"><a href="#第二课《改善神经网络：超参调整，正则化和优化》" class="headerlink" title="第二课《改善神经网络：超参调整，正则化和优化》"></a>第二课《改善神经网络：超参调整，正则化和优化》</h3><h4 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h4><blockquote><p><a href="http://www.jmlr.org/papers/volume15/srivastava14a/srivastava14a.pdf?utm_content=buffer79b43&amp;utm_medium=social&amp;utm_source=twitter.com&amp;utm_campaign=buffer">Srivastava, Nitish, et al. “Dropout: a simple way to prevent neural networks from overfitting.” The journal of machine learning research 15.1 (2014): 1929-1958.</a></p></blockquote><h4 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h4><blockquote><p><a href="https://arxiv.org/pdf/1412.6980.pdf">Kingma, Diederik P., and Jimmy Ba. “Adam: A method for stochastic optimization.” arXiv preprint arXiv:1412.6980 (2014).</a></p></blockquote><h3 id="第三课《结构化机器学习项目》"><a href="#第三课《结构化机器学习项目》" class="headerlink" title="第三课《结构化机器学习项目》"></a>第三课《结构化机器学习项目》</h3><p>无</p><h3 id="第四课《卷积神经网络CNN》"><a href="#第四课《卷积神经网络CNN》" class="headerlink" title="第四课《卷积神经网络CNN》"></a>第四课《卷积神经网络CNN》</h3><h4 id="LeNet-5"><a href="#LeNet-5" class="headerlink" title="LeNet-5"></a>LeNet-5</h4><blockquote><p><a href="http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf">LeCun, Yann, et al. “Gradient-based learning applied to document recognition.” Proceedings of the IEEE 86.11 (1998): 2278-2324.</a></p></blockquote><h4 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h4><blockquote><p><a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf">Krizhevsky, Alex, Ilya Sutskever, and Geoffrey E. Hinton. “Imagenet classification with deep convolutional neural networks.” Advances in neural information processing systems. 2012.</a></p></blockquote><h4 id="VGG-16"><a href="#VGG-16" class="headerlink" title="VGG-16"></a>VGG-16</h4><blockquote><p><a href="https://arxiv.org/pdf/1409.1556.pdf">Simonyan, Karen, and Andrew Zisserman. “Very deep convolutional networks for large-scale image recognition.” arXiv preprint arXiv:1409.1556 (2014).</a></p></blockquote><h3 id="ps-Andrew-Ng-推荐阅读顺序：AlexNet-gt-VGG-gt-LeNet"><a href="#ps-Andrew-Ng-推荐阅读顺序：AlexNet-gt-VGG-gt-LeNet" class="headerlink" title="ps: Andrew Ng 推荐阅读顺序：AlexNet &gt; VGG &gt; LeNet"></a>ps: Andrew Ng 推荐阅读顺序：AlexNet &gt; VGG &gt; LeNet</h3><h4 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h4><blockquote><p><a href="http://openaccess.thecvf.com/content_cvpr_2016/papers/He_Deep_Residual_Learning_CVPR_2016_paper.pdf">He, Kaiming, et al. “Deep residual learning for image recognition.” Proceedings of the IEEE conference on computer vision and pattern recognition. 2016.</a></p></blockquote><h4 id="Network-in-network"><a href="#Network-in-network" class="headerlink" title="Network in network"></a>Network in network</h4><blockquote><p><a href="https://arxiv.org/pdf/1312.4400.pdf">Lin, Min, Qiang Chen, and Shuicheng Yan. “Network in network.” arXiv preprint arXiv:1312.4400 (2013).</a></p></blockquote><h4 id="Inception-Network"><a href="#Inception-Network" class="headerlink" title="Inception Network"></a>Inception Network</h4><blockquote><p><a href="https://www.cv-foundation.org/openaccess/content_cvpr_2015/papers/Szegedy_Going_Deeper_With_2015_CVPR_paper.pdf">Szegedy, Christian, et al. “Going deeper with convolutions.” Proceedings of the IEEE conference on computer vision and pattern recognition. 2015.</a></p></blockquote><h4 id="OverFeat"><a href="#OverFeat" class="headerlink" title="OverFeat"></a>OverFeat</h4><blockquote><p><a href="https://arxiv.org/pdf/1312.6229">Sermanet, Pierre, et al. “Overfeat: Integrated recognition, localization and detection using convolutional networks.” arXiv preprint arXiv:1312.6229 (2013).</a></p></blockquote><h4 id="YOLO"><a href="#YOLO" class="headerlink" title="YOLO"></a>YOLO</h4><blockquote><p><a href="https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Redmon_You_Only_Look_CVPR_2016_paper.pdf">Redmon, Joseph, et al. “You only look once: Unified, real-time object detection.” Proceedings of the IEEE conference on computer vision and pattern recognition. 2016.</a></p></blockquote><h4 id="R-CNN"><a href="#R-CNN" class="headerlink" title="R-CNN"></a>R-CNN</h4><blockquote><p><a href="http://openaccess.thecvf.com/content_cvpr_2014/papers/Girshick_Rich_Feature_Hierarchies_2014_CVPR_paper.pdf">Girshick, Ross, et al. “Rich feature hierarchies for accurate object detection and semantic segmentation.” Proceedings of the IEEE conference on computer vision and pattern recognition. 2014.</a></p></blockquote><h4 id="Fast-R-CNN"><a href="#Fast-R-CNN" class="headerlink" title="Fast R-CNN"></a>Fast R-CNN</h4><blockquote><p><a href="http://openaccess.thecvf.com/content_iccv_2015/papers/Girshick_Fast_R-CNN_ICCV_2015_paper.pdf">Girshick, Ross. “Fast r-cnn.” Proceedings of the IEEE international conference on computer vision. 2015.</a></p></blockquote><h4 id="Faster-R-CNN"><a href="#Faster-R-CNN" class="headerlink" title="Faster R-CNN"></a>Faster R-CNN</h4><blockquote><p><a href="http://papers.nips.cc/paper/5638-faster-r-cnn-towards-real-time-object-detection-with-region-proposal-networks.pdf">Ren, Shaoqing, et al. “Faster r-cnn: Towards real-time object detection with region proposal networks.” Advances in neural information processing systems. 2015.</a></p></blockquote><h4 id="Siamese-Network"><a href="#Siamese-Network" class="headerlink" title="Siamese Network"></a>Siamese Network</h4><blockquote><p><a href="https://www.cv-foundation.org/openaccess/content_cvpr_2014/papers/Taigman_DeepFace_Closing_the_2014_CVPR_paper.pdf">Taigman, Yaniv, et al. “Deepface: Closing the gap to human-level performance in face verification.” Proceedings of the IEEE conference on computer vision and pattern recognition. 2014.</a></p></blockquote><h4 id="FaceNet"><a href="#FaceNet" class="headerlink" title="FaceNet"></a>FaceNet</h4><blockquote><p><a href="https://www.cv-foundation.org/openaccess/content_cvpr_2015/papers/Schroff_FaceNet_A_Unified_2015_CVPR_paper.pdf">Schroff, Florian, Dmitry Kalenichenko, and James Philbin. “Facenet: A unified embedding for face recognition and clustering.” Proceedings of the IEEE conference on computer vision and pattern recognition. 2015.</a></p></blockquote><h4 id="Visualizing-and-understanding-convolutional-networks"><a href="#Visualizing-and-understanding-convolutional-networks" class="headerlink" title="Visualizing and understanding convolutional networks"></a>Visualizing and understanding convolutional networks</h4><blockquote><p><a href="https://arxiv.org/pdf/1311.2901">Zeiler, Matthew D., and Rob Fergus. “Visualizing and understanding convolutional networks.” European conference on computer vision. Springer, Cham, 2014.</a></p></blockquote><h4 id="Neural-Style-Transfer"><a href="#Neural-Style-Transfer" class="headerlink" title="Neural Style Transfer"></a>Neural Style Transfer</h4><blockquote><p><a href="https://arxiv.org/pdf/1508.06576">Gatys, Leon A., Alexander S. Ecker, and Matthias Bethge. “A neural algorithm of artistic style.” arXiv preprint arXiv:1508.06576 (2015).</a></p></blockquote><h3 id="第五课《序列模型》"><a href="#第五课《序列模型》" class="headerlink" title="第五课《序列模型》"></a>第五课《序列模型》</h3><h4 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h4><blockquote><p><a href="https://arxiv.org/pdf/1409.1259">Cho, Kyunghyun, et al. “On the properties of neural machine translation: Encoder-decoder approaches.” arXiv preprint arXiv:1409.1259 (2014).</a></p><p><a href="https://arxiv.org/pdf/1412.3555">Chung, Junyoung, et al. “Empirical evaluation of gated recurrent neural networks on sequence modeling.” arXiv preprint arXiv:1412.3555 (2014).</a></p></blockquote><h4 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h4><blockquote><p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.676.4320&amp;rep=rep1&amp;type=pdf">Hochreiter, Sepp, and Jürgen Schmidhuber. “Long short-term memory.” Neural computation 9.8 (1997): 1735-1780.</a></p></blockquote><h4 id="t-SNE"><a href="#t-SNE" class="headerlink" title="t-SNE"></a>t-SNE</h4><blockquote><p><a href="http://www.jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf">Maaten, Laurens van der, and Geoffrey Hinton. “Visualizing data using t-SNE.” Journal of machine learning research 9.Nov (2008): 2579-2605.</a></p></blockquote><h4 id="Analogy-reasoning"><a href="#Analogy-reasoning" class="headerlink" title="Analogy reasoning"></a>Analogy reasoning</h4><blockquote><p><a href="https://www.aclweb.org/anthology/N13-1090.pdf">Mikolov, Tomas, Wen-tau Yih, and Geoffrey Zweig. “Linguistic regularities in continuous space word representations.” Proceedings of the 2013 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies. 2013.</a></p></blockquote><h4 id="A-neural-probabilistic-language-model"><a href="#A-neural-probabilistic-language-model" class="headerlink" title="A neural probabilistic language model"></a>A neural probabilistic language model</h4><blockquote><p><a href="http://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf">Bengio, Yoshua, et al. “A neural probabilistic language model.” Journal of machine learning research 3.Feb (2003): 1137-1155.</a></p></blockquote><h4 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h4><blockquote><p><a href="https://arxiv.org/pdf/1301.3781.pdf%5D">Mikolov, Tomas, et al. “Efficient estimation of word representations in vector space.” arXiv preprint arXiv:1301.3781 (2013).</a></p></blockquote><h4 id="Negative-Sampling"><a href="#Negative-Sampling" class="headerlink" title="Negative Sampling"></a>Negative Sampling</h4><blockquote><p><a href="https://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf">Mikolov, Tomas, et al. “Distributed representations of words and phrases and their compositionality.” Advances in neural information processing systems. 2013.</a></p></blockquote><h4 id="GloVe"><a href="#GloVe" class="headerlink" title="GloVe"></a>GloVe</h4><blockquote><p><a href="https://www.aclweb.org/anthology/D14-1162.pdf">Pennington, Jeffrey, Richard Socher, and Christopher Manning. “Glove: Global vectors for word representation.” Proceedings of the 2014 conference on empirical methods in natural language processing (EMNLP). 2014.</a></p></blockquote><h4 id="Debiasing-word-embeddings"><a href="#Debiasing-word-embeddings" class="headerlink" title="Debiasing word embeddings"></a>Debiasing word embeddings</h4><blockquote><p><a href="http://papers.nips.cc/paper/6228-man-is-to-computer-programmer-as-woman-is-to-homemaker-debiasing-word-embeddings.pdf">Bolukbasi, Tolga, et al. “Man is to computer programmer as woman is to homemaker? debiasing word embeddings.” Advances in neural information processing systems. 2016.</a></p></blockquote><h4 id="Seq-2-Seq-amp-machine-translation"><a href="#Seq-2-Seq-amp-machine-translation" class="headerlink" title="Seq 2 Seq &amp; machine translation"></a>Seq 2 Seq &amp; machine translation</h4><blockquote><p><a href="https://arxiv.org/pdf/1409.3215">Sutskever, I., O. Vinyals, and Q. V. Le. “Sequence to sequence learning with neural networks.” Advances in NIPS (2014).</a><br><a href="https://arxiv.org/pdf/1406.1078">Cho, Kyunghyun, et al. “Learning phrase representations using RNN encoder-decoder for statistical machine translation.” arXiv preprint arXiv:1406.1078 (2014).</a></p></blockquote><h4 id="Image-captioning"><a href="#Image-captioning" class="headerlink" title="Image captioning"></a>Image captioning</h4><blockquote><p><a href="https://arxiv.org/pdf/1412.6632">Mao, Junhua, et al. “Deep captioning with multimodal recurrent neural networks (m-rnn).” arXiv preprint arXiv:1412.6632 (2014).</a><br><a href="https://www.cv-foundation.org/openaccess/content_cvpr_2015/papers/Vinyals_Show_and_Tell_2015_CVPR_paper.pdf">Vinyals, Oriol, et al. “Show and tell: A neural image caption generator.” Proceedings of the IEEE conference on computer vision and pattern recognition. 2015.</a></p><p><a href="https://www.cv-foundation.org/openaccess/content_cvpr_2015/papers/Karpathy_Deep_Visual-Semantic_Alignments_2015_CVPR_paper.pdf">Karpathy, Andrej, and Li Fei-Fei. “Deep visual-semantic alignments for generating image descriptions.” Proceedings of the IEEE conference on computer vision and pattern recognition. 2015.</a></p></blockquote><h4 id="Bleu"><a href="#Bleu" class="headerlink" title="Bleu"></a>Bleu</h4><blockquote><p><a href="http://www.mt-archive.info/00/IBM-2001-Papineni.pdf">Papineni, Kishore, et al. “BLEU: a method for automatic evaluation of machine translation.” Proceedings of the 40th annual meeting on association for computational linguistics. Association for Computational Linguistics, 2002.</a></p></blockquote><h4 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h4><blockquote><p><a href="https://arxiv.org/pdf/1409.0473">Bahdanau, Dzmitry, Kyunghyun Cho, and Yoshua Bengio. “Neural machine translation by jointly learning to align and translate.” arXiv preprint arXiv:1409.0473 (2014).</a></p><p><a href="http://www.jmlr.org/proceedings/papers/v37/xuc15.pdf">Xu, Kelvin, et al. “Show, attend and tell: Neural image caption generation with visual attention.” International conference on machine learning. 2015.</a></p></blockquote><h4 id="CTC-cost"><a href="#CTC-cost" class="headerlink" title="CTC cost"></a>CTC cost</h4><blockquote><p><a href="https://mediatum.ub.tum.de/doc/1292048/file.pdf">Graves, Alex, et al. “Connectionist temporal classification: labelling unsegmented sequence data with recurrent neural networks.” Proceedings of the 23rd international conference on Machine learning. ACM, 2006.</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python切片延展</title>
      <link href="/posts/3552669358/"/>
      <url>/posts/3552669358/</url>
      
        <content type="html"><![CDATA[<p>一般切片的操作都很简单，比如对于一个list，我们要用切片取部分内容，可以有如下操作：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(L[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>对于<code>L[i:j]</code>有，从第<code>i</code>个开始取，取到第<code>j-1</code>个为止。同样对于str和tuple都可以这样操作。</p><hr><p>下边说个不一样的：</p><p>现在我们有二维数组，<br>                    <code>[1, 2, 3, 4]</code><br>                   <code>[5, 6, 7, 8]</code><br>               <code>[9, 10, 11, 12]</code><br>             <code>[13, 14, 15, 16]</code></p><p>1.现在如果我们想取<code>[2, 3]</code>，那么该怎么操作呢？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>], [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>]])</span><br><span class="line">&gt;&gt;&gt;print(a[:<span class="number">1</span> , <span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line">[[<span class="number">2</span> <span class="number">3</span>]]</span><br></pre></td></tr></table></figure><p>2.现在如果我们想取<code>[6, 7, 8]</code>呢？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;print(a[<span class="number">1</span>:<span class="number">2</span> , <span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line">[[<span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]]</span><br></pre></td></tr></table></figure><p>3.现在如果我们想取<code>2, 6</code>呢？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;print(a[:<span class="number">2</span> , <span class="number">1</span>:<span class="number">2</span>])</span><br><span class="line">[[<span class="number">2</span>]</span><br><span class="line"> [<span class="number">6</span>]]</span><br></pre></td></tr></table></figure><p>4.现在如果我们想取<code>8, 12, 16</code>呢？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;print(a[<span class="number">1</span>: , <span class="number">3</span>:])</span><br><span class="line">[[ <span class="number">8</span>]</span><br><span class="line"> [<span class="number">12</span>]</span><br><span class="line"> [<span class="number">16</span>]]</span><br></pre></td></tr></table></figure><p>通过以上几个例子我们可以发现，这中间多了个逗号<code>,</code>。逗号<code>,</code>前边表示对二维数组的「行」进行操作，逗号<code>,</code>后边表示对二维数组的「列」进行操作。对「行」「列」的操作，又都遵循上边第一个一维数组的例子。从第<code>i</code>个开始取，取到第<code>j-1</code>个为止</p><p>如果我们想取「整行」或者「整列」呢？</p><p>1.现在如果我们想取前两行呢？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;print(a[:<span class="number">2</span> , ])</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]]</span><br></pre></td></tr></table></figure><p>2.现在如果我们想取第0-2列呢？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;print(a[: , <span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    [[ <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line">    [ <span class="number">5</span>  <span class="number">6</span>]</span><br><span class="line">    [ <span class="number">9</span> <span class="number">10</span>]</span><br><span class="line">    [<span class="number">13</span> <span class="number">14</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另外，如果从第0个开始，则这个0可以省略。如果取到最后一个位置，则也可以省略。<br>比如，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">&gt;&gt;&gt;print(a[<span class="number">0</span>:<span class="number">5</span>])</span><br><span class="line">&gt;&gt;&gt;print(a[:])</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贰零贰零年九月</title>
      <link href="/posts/3391579802/"/>
      <url>/posts/3391579802/</url>
      
        <content type="html"><![CDATA[<h4 id="9-21"><a href="#9-21" class="headerlink" title="9.21"></a>9.21</h4><p>第一次进学校我就感叹，这才是大学该有的样子嘛。</p><p>今天开学第一节课是上的英语。老师直接英文授课，这我就有点懵了，以前哪受过这待遇啊。而且还有很多的口语练习。。。</p><p>我班的女孩子英语真的是一个比一个溜👍。</p><hr><h4 id="9-22"><a href="#9-22" class="headerlink" title="9.22"></a>9.22</h4><p>刘云衫指出，在古典教育中，教育的最重要的功能就是「认识自己」。「认识自己」是每个人一生都要面对的问题。</p><p>因为，只有认识了自己，才能开始慢慢拖离外界环境设定的条条框框。在哪里工作？稳不稳定？有对象了么？怎么还没结婚？房子几平米啊？；才会开始真正去思索自己在社会中的位置到底是什么；才会开始学会选择，也学会放弃；才能开始更加平静地和这个社会，同时也是和自己相处。</p><hr><h4 id="9-23"><a href="#9-23" class="headerlink" title="9.23"></a>9.23</h4><p>王国维，《人间词话》中的「三重境」。</p><p>昨夜西风凋碧树，独上西楼，望尽天涯路。<em>放眼望去看见的都是大佬。</em></p><p>衣带渐宽终不悔，为伊消得人憔悴。<em>从大佬的某个分享，获得一点灵感，便开始实操，如痴如醉。</em></p><p>蓦然回首，那人却在灯火阑珊处。<em>通过不断地复盘学习，你是大佬，但你浑然不知。</em></p><p>「IT`S EASIER TO FOOL PEOPLE THAN TO CONVINCE THEM THAT THEY HAVE BEEN FOOLED.」~MARK TWAIN</p><hr><h4 id="9-24"><a href="#9-24" class="headerlink" title="9.24"></a>9.24</h4><p>情商这件事，没有阅历，提升不了什么的。</p><p><br/></p><p>一个年轻人，没读上什么好学校，干啥啥不行，吃啥啥不剩。那你能改变自己的，<strong>是要让自己细心一点</strong>。这是让你走向优秀的前提。</p><p>你过去的马马虎虎，导致了你的烂，和你的烂成绩，所以你读不了好学校。</p><p>因为如果你足够细心，只要考试过程中把你会的题目都答对，你就足以进入一个好一点的学校。这根本不是智力上的差异。</p><p>就这么简单的道理，早知道，早受益。</p><hr><h4 id="9-25"><a href="#9-25" class="headerlink" title="9.25"></a>9.25</h4><p>给三年后的自己写了封信。</p><hr><h4 id="9-26"><a href="#9-26" class="headerlink" title="9.26"></a>9.26</h4><p>不要同情自己，同情自己是卑劣懦夫干的勾当。</p><hr><h4 id="9-27"><a href="#9-27" class="headerlink" title="9.27"></a>9.27</h4><p>放大别人的价值，就是放大自己的价值。</p><p>帮助别人成长，就是实现自我成长。</p><p>富人互捧，穷人互拆。</p><p><br /></p><p>无知和弱小不是生存的障碍，傲慢才是。</p><p>我们都是阴沟里的虫子，但总还是得有人仰望星空。</p><p>银河系猎户座旋臂有两颗文明的流星划过，宇宙记住了他们的光芒。</p><p>你们认为没有路，是因为没有学会不择手段。</p><p>给岁月以文明而不是给文明以岁月。</p><hr><h4 id="9-28"><a href="#9-28" class="headerlink" title="9.28"></a>9.28</h4><p>《青春大概》</p><p><br /></p><p>格局要大，Ego要小。</p><hr><h4 id="9-29"><a href="#9-29" class="headerlink" title="9.29"></a>9.29</h4><p>这几天感冒了，很难受。</p><h4 id="9-30"><a href="#9-30" class="headerlink" title="9.30"></a>9.30</h4><p>按照代码行数来评判程序员的工作是不合理的。但我坚信，谈论质的前提，是量。</p><p>只有量变，才能引发质变。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日更 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高效表达技巧</title>
      <link href="/posts/3886809511/"/>
      <url>/posts/3886809511/</url>
      
        <content type="html"><![CDATA[<blockquote><p>高效表达=定主题+搭架子+填素材</p></blockquote><h3 id="定主题"><a href="#定主题" class="headerlink" title="定主题"></a>定主题</h3><p>主题：对所讨论的内容持有的观点或想法。 </p><p>讲话要先抛主题，以便别人可以清楚地理解你所表达的内容核心。</p><h3 id="搭架子"><a href="#搭架子" class="headerlink" title="搭架子"></a>搭架子</h3><p>这里有三个模板：</p><ol><li>时间轴（最常用）</li><li>问题-原因-解决方案（what-why-how）</li><li>FAB（Feature-Advantage-Benefit 属性-优势-利益）</li></ol><h5 id="时间轴"><a href="#时间轴" class="headerlink" title="时间轴"></a>时间轴</h5><p>以时间为序，如：「过去-现在-将来」，或者按时间的发展顺序，比如要告诉别人去处理一件事，可以用「首先-然后-最后」</p><p>这是最常用的一种表达逻辑</p><h5 id="问题-原因-解决方案"><a href="#问题-原因-解决方案" class="headerlink" title="问题-原因-解决方案"></a>问题-原因-解决方案</h5><p>首先要提出问题是什么，然后总结下原因，最重要的是要告诉解决方案是什么。</p><p>落脚点是「How」，这也符合职场「结果导向」的特征。</p><h5 id="FAB（属性-优势-利益）"><a href="#FAB（属性-优势-利益）" class="headerlink" title="FAB（属性-优势-利益）"></a>FAB（属性-优势-利益）</h5><p>这个可以用来介绍产品。比如要你介绍百乐 「CAPLESS  Decimo」这款钢笔，你就可以这样说：</p><ol><li>这款钢笔最大的特点是「按动出尖」   （属性）</li><li>这样可以方便的单手操作，不用另一只手去拔笔帽。    （优势）</li><li>很方便学生、记者或者是需要速记的人员使用。    （利益）</li></ol><p>同时，FAB框架也很适合做「自我介绍」，转换下就是（基本情况-过人之处-可提供的帮助）</p><h3 id="填素材"><a href="#填素材" class="headerlink" title="填素材"></a>填素材</h3><p>素材有二</p><ol><li>数据</li><li>故事</li></ol><h5 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h5><p>这里又包括「数据筛选」和「数据解释」</p><p>数据筛选：不要每个数据一个不拉的都描述出来，往往代表结果的数据是最重要的</p><p>数据解释：数据本身没有意义，你才是意义的缔造者 。</p><p>比如乔布斯就是一个教科书式的例子。乔布斯在IPhone诞生200天的时候说， 他们共卖出了400W部手机。用400W除以200天，也就是每天卖出了2W部手机。</p><p>我们分析下， 这里如果乔布斯只是说卖了400w部手机，人们可能不会有直观的感受，但如果说每天卖出2W部人们的感受就会很明显。</p><p>再比如，「每年卖出三亿杯，杯子连起来可以绕地球一圈」</p><h5 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h5><p>「世界上所有的故事都包含了3要素，冲突、行动、结局  —杰里.克里夫」</p><p>记住，这里的「冲突」是关键</p>]]></content>
      
      
      <categories>
          
          <category> 个人成长 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 表达技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的2019年终总结</title>
      <link href="/posts/2792942006/"/>
      <url>/posts/2792942006/</url>
      
        <content type="html"><![CDATA[<p>这是我第一次写年终总结， 我也没什么经验， 我试着写写吧。</p><p>学习方面， 2019年我最大的事就是准备考研， 考研我从18年下学期就开始陆陆续续的准备了（买书而已），19年开学来了就真正开始准备了。 好像说真正准备其实也是没有下多大功夫， 感觉战线拉一年有点长， 怕后期乏力。可是今年却考的不如意， 英语难数学难，专业课还难。自我感觉今年是凉了， 可是没考上我又心有不甘， 一旦踏上考研的路， 这就是条不归路。 我也在审视我自己是否真的适合考研， 还是应该踏踏实实的去找个工作。 马上面临毕业， 毕业后何去何从， 以前并没有想过这个问题， 可这一天终究会来到。</p><p>健康方面， 因为在准备考研， 所以每天的作息很规律， 每日三餐正常吃， 体重还是那样没有变化， 不增也不减。</p><p>生活方面， 因为在准备考研所以其他的事情都给考研让路， 也并没有什么特别的， 只是简单的和兄弟聚了几次会， 吹了几次牛逼。</p><p>目来源， 都是花爸妈的， 虽说大部分同学都是这样， 但是我却觉得自己这么大了，该尝试自己管自己了。 2020年我要有自己的收入来源。</p><p>文字水平确实是太差， 心里的想法也没能很好的表达出来。</p><p>在这里我顺便写下我2020的规划吧</p><ul><li>如果二战的话，要有自己的收入来源</li><li>每天阅读半小时， 多读些专业相关、经济学与金融方面的书</li><li>将睡前的半小时改为看书</li><li>提高自己的英语水平， 不过我还没有想好定个什么样的目标会比较合适</li><li>重新把日语拾起来， 想办法挣点</li><li>每周要锻炼三四天， 跳跳绳之类的增加下心肺功能顺便长长腹肌</li><li>bobo老师数据结构课</li><li>学习视频剪辑，拍视频，搞b站，干</li><li>公众号输出文章</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
